<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[别了，2018]]></title>
    <url>%2Fpost%2Fyear-end-summary-2018%2F</url>
    <content type="text"><![CDATA[2018，当敲下这几个数字时，仍然觉得新鲜。也是去年这个时候，还在回顾17，期待18。 好像也没过多久每到这样新旧交替的时候，遗憾、希望总是主旋律。一年又一年，兴许这一年真的太忙。还没有好好认真的审视这一年，就悄然逝去了。 18年是收获，艰难，繁忙，挑战，迷茫，释然，期待的一年。 收获在18年伊始，17年下半年的付出，也算是有了些回应了，尽管这个过程也不是这么的顺利。也因了那些收获，生活变得忙碌。整个人的重心基本都基本都放在了工作上，令人欣慰的是，一群共事的兄弟姐妹们都很赞，老大对我也不错。 老爸常在我面前说我妈很能吃苦，我心里想的是，你们都很能吃苦，才可能坚持一个方向做了十多年。可能耳濡目染吧，之前极少加班，18年跳槽，尽管万科这边加班习以为常，也很快适应。有时按点下班，大家都会开玩笑说，咦，你今天不加班呀。项目组很忙，任务很重，周期短，沟通对接困难，流程繁杂，对接好几个外部系统，时确实实现困难的地方，与管理层沟通，往往得不到换位的思考，其实大家的心情的目的都是一样的，信任很重要。 繁杂的工作内容、需要频繁的和人沟通。我的薄弱弱的很明显，并且太直，喜怒都放在脸上和言语间。有时在想，幸好我当初入的是这行，不用担心办公室政治，程序员都还是比较简单的（题外话）沟通是门大学问。有尝试读过朋友推荐的《高情商沟通学》，在读了前面三章后，觉得太费劲，与人沟通时时都要讲策略，那太累。这方面我始终做不到很好，只能说慢慢提高了。 犹记得刚参加工作时候，老大跟我说，如果一份工作不能给你带来能力的提升或者同等适合的工资，留下来也只会让自己不断抱怨。于是他走了，一直都感恩他对于一个初入职场的菜鸟的照顾。在意识到上家公司可能要挂的时候，毅然辞职。奶酪就在那里不增一直减。忙碌之余，很多时候在审问自己，来这边你又收获学到了什么。一边又陷入那样的感觉，一边是渐长的年龄和生活。我想，我也成为了小时候认为的“大人”，除了远方，还有眼前的生活。是什么阻挡你想改变的内心，是贪图安稳的心，生活的压力和经济能力啊(手动笑哭脸)。 思及此，有些茫然跟无奈。 以上碎碎念这么多，大多关乎工作，也说重心基本都在工作上了。2018，两场旅行，有趣，印象深刻。最后沿着茶卡盐湖，一个人慢慢走的时候，很平静。适当让别人了解自己的想法，适当表现自己，让别人看到自己的付出，毕竟会哭的孩子，有奶吃。想到这里，突然好想爹妈，出来好几天，想家了。2018，专升本考试通过……不多说了，自己的遗憾只能慢慢修补，长大徒伤悲。2018，生活质量在变的更好。2018，思想有很大转变。2018，认识了几个熟悉的朋友。2018，完成了大多数在年初列的todolist 相信，会越来越好。 回头看，觉得时光如逝；身处当下又总是被繁事叨扰，觉得太过于慢，时常希望日子过的快些。也许这就是生活本身的模样。2019，本命年，该给生活多一些空间。希望技术可以更好，多读些书，多交朋友，少熬夜，多锻炼，多陪家人，减肥，找男票(捂脸✿◡‿◡))，发展副业O(∩_∩)O]]></content>
      <categories>
        <category>year-end summary</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高并发解决方案]]></title>
    <url>%2Fpost%2F%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[昨天今天开始在面试过程中，经常会被问到一些底层的东西，比如jvm调优、数据库存储引擎、反射机制啊、高并发是如何解决的啊…武汉这边底层好像挖的很深，对于平常疲于业务代码的程序员来说，可能没有涉及到。面试面航母，工作拧螺丝，突然想起某人的吐槽，O(∩_∩)O 尽管这样，还是自己知识面的缺失，对于高并发，确实是实际工作中头疼的问题，借以此篇，学习总结下吧。 在互联网项目中，高并发，高可用，分布式和集群，都是很常见的名词，因为一旦用户量上来了，这些都是需要考虑到的。网上很多资料多余高并发这块，有句话我觉得总结的很精辟，“尽量把用户请求往前面推”，我理解的是，能让用户少和数据库交互，就减少数据库压力。所以在这中间我们需要可以引入很多的技术。 比如缓存、如果页面中需要展示的资源很多，并且每个用户都看到都是相同的，经常被请求的资源，我们就可以引进缓存技术，在我们项目中，就用到了redis，因为redis是单线程的，尽管这样，它能承受的并发量也有50万，既可以保证线程安全，也可以将数据放在缓存数据库中，减少关系型数据库的访问压力。 比如页面静态化，对于一些可能不会经常改动的数据，比如详情页等，这也是需要发送大量的请求，但是每位用户访问的资源，渲染的页面都是相同的，使用页面静态化是种不错的选择，毕竟静态的页面响应的速度也会快很多，并且有利于搜索引擎，SEO优化。同时也隐藏了服务端，防止黑客攻击等产生的静态页面，我们还可以搭建nginx集群，做负载均衡，分担压力。 比如引入中间件，假设服务层的某个方法处理的业务过多，并且经常会被调用的，会有很高的阻塞风险，为了应用解耦，可以映入消息中间件技术，只需要向消息队列中生产一条消息，在消息调用方监听到消息后执行对应的操作即可。而我们的主业务又不会收到影响。 比如采用分布式和集群，分布式和集群两者区别在于，分布式是逻辑上是统一的，但是做的事情是不一样的，集群是做的事情是完全一样的，只用于分担压力而已。一台服务器扛不住，就多加几台，从硬件上解决，对于高并发，是很好的解决方案，当然也要在公司支出允许条件下 还有很多，比如图片较多是，一般采取云存储等等]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis数据持久化]]></title>
    <url>%2Fpost%2Fredis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Redis将内存存储和持久化存储相结合，即可提供数据访问的高效性，又可保证数据存储的安全性 一、Redis数据持久化机制介绍redis中默认的持久化方案是rdb方式，该机制是值在指定时间间隔将内存中的数据集快照写入dump.rdb文件中 1、RDB持久化：该机制是指在指定的时间间隔内将内存中的数据集快照写入磁盘。在redis安装目录/bin/dump.rdb 文件中有如下设置： 我们也可以通过配置文件来修改redis服务器快照频率，使用vim redis安装目录/bin/dump.rdb文件，修改上图所标志的，假设将60s内修改10个key发生变化，产生快照。当我们使用rm -rf dump.rdb 删除该文件时，在一分钟内设置10个值，会发现dump.rdb有重新自动创建了 注意：dump.rdb文件生成的位置,它是设置是在redis.conf文件中 “dir ./“ 这段配置指的是服务器启动时的当前路径。即如果在root目录下直接启动redis，该文件就产生在root目录下！！ 2、AOF(append only file)持久化:该机制将以日志的形式记录服务器所处理的每一个写操作，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。 AOF日志持久化机制的开启以及三种同步方式配置： 开启aof缓存方案后，向redis中缓存后，就可以看到bin/appendonly.aof 文件，查看该配置文件就可以看到刚刚设置进去的值。 3、同时应用AOF和RDB。4、无持久化：可通过配置的方式禁用Redis服务器的持久化功能，不推荐 二、RDB与AOF对比总结RDB优势 数据的备份和恢复非常方便，因为一个数据库只有一个持久化文件 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。 RDB劣势 系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。 AOF优势 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。 对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。 如果日志过大，Redis可以自动启用rewrite机制迅速“瘦身”(也可手动触发aof的rewrite操作，命令： bgrewriteaof) AOF日志格式清晰、易于理解，很容易用AOF日志文件完成数据的重建。 AOF劣势 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis在项目中使用场景]]></title>
    <url>%2Fpost%2Fredis%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[在我们商城中首页中有大量的分类广告，并且网站的首页会有很大的访问量，如果每次访问都查询数据库，数据库的压力会变的很大，性能也会大大降低，经常会有卡顿。所以需要引入redis持久化缓存方案！ 一、pom依赖和配置参见前面spring-data-redis的使用；需要配置jedis连接池、连接工厂、redisTemplate模板等 二、redis缓存方案（以首页广告为例）1、明确存储数据类型：因为首页广告有很多分类，并且每个分类中有很多条广告，所以采用的是Hash数据结构,Hash的key是广告的分类id,存储在redis中key命名为content.主要思想就是查询的时候做缓存，执行增删改从操作时候清空缓存。 2、查询：在根据分类广告的查询方法中，首先判断redis缓存中是否存在key为content的value，如果存在直接返回即可，如果不存在走数据库查询。注意使用redisTemplate连接redis，需要try…catch…否则页面中为空，影响用户体验！123456789101112131415161718192021222324252627@Overridepublic List&lt;TbContent&gt; findContentByCategoryId(Long categoryId) &#123; // 判断缓存是否为空，不为空优先从缓存中取 List&lt;TbContent&gt; contents = null; try &#123; contents = (List&lt;TbContent&gt;) redisTemplate.boundHashOps(&quot;content&quot;).get(categoryId); // 如果不为空 直接从缓存中取 if(contents!=null)&#123; return contents; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if(contents==null)&#123; // 缓存为空从数据库中取 contents = contentMapper.findContentByCategoryId(categoryId); &#125; try &#123; redisTemplate.boundHashOps(&quot;content&quot;).put(categoryId,contents); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return contents;&#125; 3、修改：在后台管理系统修改了广告的信息后，需要考虑两个方面，一是广告的分类id没有被修改，另方面分类id没有变化。 123456789101112131415@Overridepublic void update(TbContent content)&#123; // 判断是否修改了广告分类 Long categoryIdPresist = contentMapper.selectByPrimaryKey(content.getId()).getCategoryId(); // 修改了分类 if(categoryIdPresist.longValue() != content.getCategoryId().longValue())&#123; // 因为两个分类都有变化 所以需要都清除 redisTemplate.boundHashOps(&quot;content&quot;).delete(content.getCategoryId()); &#125; // 无论是否修改了分类，都需要将原来分类数据清空 redisTemplate.boundHashOps(&quot;content&quot;).delete(categoryIdPresist); contentMapper.updateByPrimaryKey(content);&#125; 4、删除和新增按照广告分类id，将缓存清空即可，注意执行删除操作时候，需要将清空缓存操作放在前面，否则分类id无法被获取到！ 三、redis存储时效性数据在有些系统中用户注册完毕之后，需要向用户邮箱发送激活账户的邮件，如果三天之内没有验证，就会失效，重新验证用户信息。这是可以使用到redis存储值的时效性做到，将用户手机号和随机激活码作为key和value，并设置失效时间即可做到 四、计数器redis是单线程的服务器，并且可以处理50万的并发量（并不是同时进行，而是类似队列快速运行），redis中提供了incr和decr的方法，在原有的数值上+1和-1操作，这两个方法在一些场景中很有用，比如在数据库某些表数据上万条级别时，经常需要进行分片操作，数据库分片之后对于主键的控制为了避免主键并发重复可以使用redis来控制；同时在商城的秒杀模块，需要记录商品的剩余量，可以将商品剩余量存到redis中，利用redis的单线程特性，即使存在并发抢单的情况下，redis使用decr方法来记录剩余量。注意：redis是内存服务器，需要将被持久化的数据持久化到硬盘中！！]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring data redis使用]]></title>
    <url>%2Fpost%2Fspring-data-redis%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[接上篇，spring框架对很多优秀的技术进行了封装，此篇总结项目中使用到了spring data redis 1、导入pom依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- spring相关jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- redis相关jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.7.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 2、spring配置文件因为redis本质也是数据库，所以也需要配置连接工厂、模板，redis连接相关配置 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath*:config/*.properties&quot;/&gt; &lt;!-- jedis连接池配置 --&gt; &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大空闲数--&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;redis.maxIdle&#125;&quot;/&gt; &lt;!-- 连接最长等待时间--&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;$&#123;redis.maxWait&#125;&quot;/&gt; &lt;!-- 在提取一个 jedis 实例时，是否提前进行验证操作；如果为 true， 则得到的 jedis 实例均是可用的--&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;$&#123;redis.testOnBorrow&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置连接工厂--&gt; &lt;bean id=&quot;JedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot; p:host-name=&quot;$&#123;redis.host&#125;&quot; p:port=&quot;$&#123;redis.port&#125;&quot; p:password=&quot;$&#123;redis.pass&#125;&quot; p:pool-config-ref=&quot;poolConfig&quot;/&gt; &lt;!-- 配置模板--&gt; &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;JedisConnectionFactory&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、属性文件redis-config.properties，定义redis配置中的常量12345678910111213&lt;!-- 连接ip和端口 --&gt;redis.host=127.0.0.1redis.port=6379&lt;!-- 配置密码 --&gt;redis.pass=&lt;!-- 指定存储的数据库，在redis.conf文件中定义了16个数据库 --&gt;redis.database=0&lt;!-- 最大空闲数 --&gt;redis.maxIdle=300&lt;!-- 连接最长等待时间 --&gt;redis.maxWait=3000&lt;!-- 开启验证 --&gt;redis.testOnBorrow=true 4、操作五种数据类型A.String类型123456789101112131415161718192021222324252627/** * 使用redis 存储 string */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext-redis.xml&quot;)public class StoreString &#123; @Autowired private RedisTemplate redisTemplate; @Test public void add()&#123; redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;本上神&quot;); &#125; @Test public void getValue()&#123; String value = (String) redisTemplate.boundValueOps(&quot;name&quot;).get(); System.out.println(value); &#125; @Test public void delete()&#123; redisTemplate.delete(&quot;name&quot;); &#125;&#125; B.Hash类型1234567891011121314151617181920212223242526272829303132333435363738394041/** * 存储Hash类型的集合 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext-redis.xml&quot;)public class StoreHash &#123; @Autowired private RedisTemplate redisTemplate; @Test public void add()&#123; redisTemplate.boundHashOps(&quot;hashTest&quot;).put(&quot;name&quot;,&quot;jack&quot;); redisTemplate.boundHashOps(&quot;hashTest&quot;).put(&quot;age&quot;,23); redisTemplate.boundHashOps(&quot;hashTest&quot;).put(&quot;gender&quot;,&quot;boy&quot;); &#125; @Test public void get()&#123; // 获取所有的key Set keys = redisTemplate.boundHashOps(&quot;hashTest&quot;).keys(); List values = redisTemplate.boundHashOps(&quot;hashTest&quot;).values(); System.out.println(keys); System.out.println(values); // 根据key获取value String str = (String) redisTemplate.boundHashOps(&quot;hashTest&quot;).get(&quot;name&quot;); System.out.println(str); &#125; @Test public void remove()&#123; redisTemplate.boundHashOps(&quot;hashTest&quot;).delete(&quot;age&quot;,&quot;gender&quot;); &#125; @Test public void delete()&#123; redisTemplate.delete(&quot;hashTest&quot;); &#125;&#125; C.List类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 存储List类型的集合 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext-redis.xml&quot;)public class StoreList &#123; @Autowired private RedisTemplate redisTemplate; /** * 左压栈 - 相当于 栈内存存储方式 先入后出，后入先出 */ @Test public void leftPush()&#123; redisTemplate.boundListOps(&quot;student&quot;).leftPush(&quot;sl&quot;); redisTemplate.boundListOps(&quot;student&quot;).leftPush(&quot;zyt&quot;); redisTemplate.boundListOps(&quot;student&quot;).leftPush(&quot;zzy&quot;); &#125; /** * 右压栈 -- 相当于 队列数据结构 先入先出，后入后出 */ @Test public void rightPush()&#123; redisTemplate.boundListOps(&quot;classes&quot;).rightPush(&quot;class 01&quot;); redisTemplate.boundListOps(&quot;classes&quot;).rightPush(&quot;class 02&quot;); redisTemplate.boundListOps(&quot;classes&quot;).rightPush(&quot;class 03&quot;); redisTemplate.boundListOps(&quot;classes&quot;).rightPush(&quot;class 01&quot;); &#125; @Test public void get()&#123; List student = redisTemplate.boundListOps(&quot;student&quot;).range(0, 10); List classes = redisTemplate.boundListOps(&quot;classes&quot;).range(0, 10); System.out.println(student); System.out.println(classes); &#125; // 查找某个元素 @Test public void searchByIndex()&#123; String student = (String) redisTemplate.boundListOps(&quot;student&quot;).index(0); System.out.println(student); &#125; // 移除List集合的元素 ，可以指定删除数量 @Test public void remove()&#123; redisTemplate.boundListOps(&quot;classes&quot;).remove(1,&quot;class01&quot;); &#125; // 移除整个集合 @Test public void delete()&#123; redisTemplate.delete(&quot;classes&quot;); &#125;&#125; D.Set类型1234567891011121314151617181920212223242526272829303132333435363738394041/** * 使用redis存储set集合 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext-redis.xml&quot;)public class StoreSet &#123; @Autowired private RedisTemplate redisTemplate; @Test public void add()&#123; redisTemplate.boundSetOps(&quot;friend&quot;).add(&quot;zz&quot;,&quot;gg&quot;,&quot;tt&quot;,&quot;aa&quot;); &#125; // 调用 members()方法 列举所有成员 @Test public void get()&#123; Set friends = (Set) redisTemplate.boundSetOps(&quot;friend&quot;).members(); System.out.println(friends); &#125; /** * 删除Set集合中值 */ @Test public void remove()&#123; redisTemplate.boundSetOps(&quot;friend&quot;).remove(&quot;aa&quot;,&quot;老高&quot;); &#125; /** * 删除增个Set集合 */ @Test public void delete()&#123; redisTemplate.delete(&quot;friend&quot;); &#125;&#125; 5、总结与注意 需要注入redisTemplate(前提已经在spring配置文件中已经配置)，通过redisTemplate.bound”+${redis支持存储的五种数据类型}+”Ops(“${redis存储的key}”)方法调用增删改方法进行操作，除了String类型的方法名为boundValueOps() 删除整个value直接调用redisTemplate.delete(“${key}”); List数据类型可以允许有重复的值，所以在删除的时候也可以指定删除的个数；并且因为是有序的，可以调用index(idx)来获取对应的元素 List数据类型很特殊，可以模拟栈（左压栈）和队列（右压栈）两种数据类型 Hash类型，可以向HashSet集合那样获取所有的key和value，根据key来获取value Set类型，获取所有的元素调用的是members()方法.. 设置失效时间，五种数据类型都可以设置失效时间，使用redisTemplate.boundXxxOps().expire(设置失效时间,设置失效单位);]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis五种数据类型及应用场景]]></title>
    <url>%2Fpost%2Fredis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[redis作为nosql数据库的一员，主要是以key-value方式存储，尽管key只能是字符串类型，但是value可以有五种类型，分别是String、Hash、List、Set、zset，此篇主要总结五种数据类型存储方式，以及应用场景、常见命令等。 五种数据类型的特点 String类型 Hash类似map集合，小key（value中的key）不能重复，适用于json对象 List类似list集合，有序可以重复，但是值得注意的是，List类型分为左压栈和右压栈，左压栈相当于栈的数据结构，有压栈相当于队列的数据结构，所以这种特性决定了存储的先后的，取值的顺序不同。比如左压栈存的是1,2,3,4 取的是4,3,2,1;而右压栈存的是1,2,3取的是1,2,3 Set类型，类似hashset集合，无序，不可重复；只是Set类型只能放字符串 ZSet类型，拥有Set和List的特点，有序，不可重复 常见命令 字符串操作 set/get 存值取值，单值操作 mset/mget 存取多个值 incr/decr key 加一减一操作【常用分表分片主键生成策略等】 setrange/getrange key offset value setrange 方法 如果被替换的字符串长度没有被替换的长，原来被替换的剩余部分将会被保存 username abcdefgh; setrange username 7 &quot;a&quot; //abcdefah getrange key start end 获取key从索引start到end之间的字符串 list 操作 链表底层是数组所以使用push: lpush key value1 value2… //在指定链表key中的前面插入值 rpush key value1 value2 //在后面插入值 lrange key 0 -1 //获取所有集合数据 lpushx key value //只有key存在，且对应的key中没有插入的value时 返回插入 链表前面元素的数量，否则失败返回0 rpushx key value lpop key //删除链表数据的第一个并返回，如果没有key就返回nil rpop key //删除最后个并返回 llen key //返回链表数据的个数，如果没有指定的key返回0 lrem key count value //删除链表中count个value值 lset key index value //在链表key中指定索引index位置插入value lindex key index //返回链表key索引为index的值 ltrim key start stop //保留链表key 索引为start-stop之间的值【包括start和stop】 rpoplpush list01 list02 //删除list01中最后个元素插入到链表list02头中 hash 操作 键值对 hset student sid 001 hget student hmset/hmget hsetnx hexists hlen hincrby hgetall/hkeys/hvals //获取所有键值对、获取所有key、获取所有值 hdel key field.. //一次性删除多个字段 set 操作 无序去重、【聚合】 sadd key value… //向key中插入值 scard key //返回成员数量 smembers key //获取所有成员 sismembers key member //判断member是否为key中的值 spop key //删除key中第一个值并返回 srem key member member.. //批量删除多个值 srandmember key count //count可省 随机获取key中count个成员 smove set01 set02 member //将member从set01移动到set02 【聚合】 求差集和并集时，key1和key2位置不空结果不同 sdiff key1 key2… //差集 sunion key1 key2… //并集 sinter key1 key2… //交集 sdiffstore newkey key1 key2… //将差集存储到新的newkey中 ZSet ZADD key score member [score] [member] ZINCRBY key increment member ZCARD key ZCOUNT key min max ZRANGE key start stop [WITHSCORES] ZREVRANGE key start stop [WITHSCORES] ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] ZRANK key member ZREVRANK key member ZSCORE key member ZREM key member [member …] ZREMRANGEBYRANK key start stop ZREMRANGEBYSCORE key min max 其他 keys * //查找redis数据库中所有的key值 del key1 key2… //批量删除多个值 exists key //判断值是否存在 1 存在 0 不存在 rename key newkey //修改名称 expire key seconds //为key设置过期时间 s为单位 ttl key //查看key过期剩余时间 当 key 不存在时,返回 -2。当 key 存在但没有设置剩余生存时间时,返回 -1 persist key //持久化存储，消除过期时间 MOVE key db //redis.conf配置文件中定义了redis默认库为16个 randomkey //随机返回一个key type key //返回key类型 string list hash set sortedSet 事务 开启事务 multi 取消事务 discard 退出 exec]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis简介及安装备份]]></title>
    <url>%2Fpost%2Fredis%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[Redis和Memcached、MongoDB类似，也是分布式缓存服务器，因为是缓存服务器，占据内存，所以比关系型数据库访问的速度快很多。同时对于高并发处理，redis远大于tomcat的承受能力，redis大概最大能承受50万的并发量，而tomcat只能达到几百，同时redis是单线程的，所以我们通常会将一些经常访问的资源放到redis中缓存，减轻服务器和数据库的压力。之后会持续记录redis相关操作…此篇主要记录redis安装步骤 如果只是学习redis的操作，可以下载window版本，直接解压，运行客户端和服务端即可；如果是部署到Linux上去，则需要编译，因为redis是有c++写的，linux上压缩包相当于是源码，而且linux的厂商也不同，所以需要使用c++编译。 1、安装gcc环境1yum install gcc-c++ 如果你和我也报了一样的错误： 1214] PYCURL ERROR 6 - &quot;Couldn‘t resolve host ‘ftp.isu.edu.tw‘&quot;Trying other mirror.http://ftp.stu.edu.tw/Linux/CentOS/6.5/os/i386/Packages/mlocate-0.22.2-4.el6.i686.rpm: [Errno 14] PYCURL ERROR 6 - &quot;Couldn‘t resolve host ‘ftp.stu.edu.tw‘&quot;Trying other mirror. 就需要修改 /etc/resolv.conf 配置，在原有的nameserver之上多加一行 nameserver 8.8.8.8 2、上传linux版本的redis,并解压1234//使用CRT，alt+p进入上传窗口，执行 put F:\java\redis\redis-3.2.8.tar.gz（本地redis压缩包）// 切换回原来窗口tar -zxvf redis-3.2.8.tar.gz -C /usr/local(目录随意) 3、编译并安装123// 进入redis解压的目录，执行makemake install PREFIX=/usr/local/redis 4、启动方法一： 切换到安装目录/usr/local/redis/bin，执行./redis-server – 该种方法不太好是，当前窗口不能再有其他的操作，否则服务就停了方法二： 复制源码包中的redis.conf文件到redis的安装目录下的bin目录 cp /usr/local/redis-3.0.0/redis.conf /usr/local/redis/bin/ 并修改该配置文件中的“daemonize no”改成“daemonize yes”，在输入 ./redis-server ./redis.conf 启动 5、查看和关闭进程12ps aux|grep rediskill 6379 6、启动客户端：123456/usr/local/redis/bin/redis-cli -h ip地址 -p 6379auth &quot;&quot; 引号内要填写密码 以上命令输入ip地址和密码前提是：修改redis.conf配置文件 service iptables stop 关闭linux防火墙]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[别了，2017]]></title>
    <url>%2Fpost%2Fyear-end-summary-2017%2F</url>
    <content type="text"><![CDATA[傍晚，望着窗外，看着天色一点一点暗下去，直到看不清路上的行人，印象中冬日从傍晚的微光到黑暗就是那么一瞬间的事情，而这个过程却显的特别漫长，我从未认真体会过这个过程，正如从未认真观察过生活。17年这最后的几个小时，时间可以再慢些.. 又到年终了，一年又一年，一直在遗憾，一直在向前，这样想想倒也还不错。17年发生的事还挺多，只是一时不知道如何开始下笔，很多事越长大越羞于表达自己。2018年，23了，想想也很可怕。认识的人越来越多，种类越来越多，内心真实想法每每呼之欲出时，被理智扼杀在抬头之时。成长在享受成人的特权之时，也要失去些东西。 这几天，被18岁刷屏了，90后将舞台让给00后，仿佛当年初次听说90后开始担当重任也就是昨天。想想自己的18岁，在做什么呢？被高考折磨的抓耳挠腮，如果能回到那时，我一定对当时的自己说，放松就好，条条道路通罗马。烦恼过后并没有给现在的自己带来什么。此时的自己并不感激当时努力过的自己，反而都是遗憾。记忆里充斥压抑和高中班主任的言语打击。 今日心血来潮，上豆瓣看看,上次动态还停留在六年前，此时再瞧瞧六年前的自己，想找个洞把自己埋了..当时自以为的“烦恼”和“永远”，也是把自己逗乐了。当年多愁善感，如今权当看笑话了。但是回头想想，我们再也没有当初的那份勇气。少年不知愁滋味，为赋新词强说愁。而今识得愁滋味，欲说还休，却道天凉好个秋。 过去的终将成为历史，此时过去的每一秒，在时间的长河里不会再来，记录才显得珍贵。 2017年初，制定的计划中，依旧很多没有完成，还有很多正在进行中，这一年有过满足，告别，迷茫，绝望，奋斗，但这些终将会随着半小时后留在17年。上半年的舒适过后，下半年便是各种忙碌。技术上还是有很多的尝试，一月份小程序刚发布，组里就计划开发一款，很幸运学习到新东西就应用到实际项目中。但是很遗憾，离开了擎木。下半年变动虽然很大，但是收获还是很多，在项目中成长始终是最快的，下半年开始，学到了很多技术，过程很辛苦，但是慢慢来吧。语言都是相通的，因为后台，前台的很多东西恍然大悟的感觉。 2018年，一半是延续，一半是收获。正如那句话说的 在暗处野蛮生长，终有一日馥郁芬芳… 祝福2018，好运！ 写于2017年12月31日 晚。]]></content>
      <categories>
        <category>year-end summary</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data ElasticSearch快速入门]]></title>
    <url>%2Fpost%2FSpring%20Data%20ElasticSearch%2F</url>
    <content type="text"><![CDATA[接上篇，ElasticSearch通常和Spring Data ES整合起来使用，前文曾经介绍过Spring data 统一持久层框架，就包括Spring data elasticsearch,Spring data redis等非关系型数据库。使用与Spring整合，很多东西都放在Spring的配置文件中，会使全文检索变得不那么复杂。所以此篇记录下Spring Data ElasticSearch 的相关用法。 入门程序：1、导入jar包：（题主使用的maven）12345678910111213141516171819202122232425262728&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 如果使用到了junit测试，需要导入测试包--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; 2、配置Spring配置文件：需要引入名称空间，配置 Client、elasticsearchTemplate、接口和服务类所在包1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:elasticsearch=&quot;http://www.springframework.org/schema/data/elasticsearch&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/data/elasticsearch http://www.springframework.org/schema/data/elasticsearch/spring-elasticsearch-1.0.xsd&quot;&gt; &lt;!-- 配置扫描repository路径 --&gt; &lt;elasticsearch:repositories base-package=&quot;com.leahshi.dao&quot; /&gt; &lt;!-- 配置spring 扫描路径 @Repository @Service @Controller --&gt; &lt;context:component-scan base-package=&quot;com.leahshi&quot; /&gt; &lt;!-- 配置elasticSearch连接 此处可以配置集群搜索服务器 --&gt; &lt;elasticsearch:transport-client id=&quot;client&quot; cluster-nodes=&quot;localhost:9300&quot; /&gt; &lt;!-- 配置elasticSearch模板，注意id的值只能是elasticsearchTemplate --&gt; &lt;bean id=&quot;elasticsearchTemplate&quot; class=&quot;org.springframework.data.elasticsearch.core.ElasticsearchTemplate&quot;&gt; &lt;constructor-arg name=&quot;client&quot; ref=&quot;client&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 3、定义实体类：123456789101112131415161718192021222324package com.leahshi.domain;import org.springframework.data.annotation.Id;import org.springframework.data.elasticsearch.annotations.Document;import org.springframework.data.elasticsearch.annotations.Field;import org.springframework.data.elasticsearch.annotations.FieldIndex;import org.springframework.data.elasticsearch.annotations.FieldType;// 声明文档对象 indexName:索引名称（必填） type 文档类型 @Document(indexName = &quot;index03&quot;, type = &quot;article&quot;)public class Article &#123; // 声明主键 @Id // 声明字段 是否分词，是否在映射中存储分词信息 建立索引采用的分词器 搜索是采用的分词器 字段类型 @Field(index = FieldIndex.not_analyzed, store = true, type = FieldType.Integer) private Integer id; @Field(index = FieldIndex.analyzed, analyzer = &quot;ik&quot;, store = true, searchAnalyzer = &quot;ik&quot;, type = FieldType.String) private String title; @Field(index = FieldIndex.analyzed, analyzer = &quot;ik&quot;, store = true, searchAnalyzer = &quot;ik&quot;, type = FieldType.String) private String content; // getter/setter方法&#125; 以上主要有三个注解： @Document：indexName属性指定索引库的名称，相当于指定数据库的名称，必填 @Id：注意不要和jpa的注解导出 @Field：type属性必须指定，还可以指定分词器的类型、搜索分词器类型，是否分词，是否建立索引，是否存储该字段 注意：建立索引标准，字段为String类型可以考虑建立索引，如果为数值型可以无需分词，因为ElasticSearch只是对中文分词支持很差，数值型和英文支持很好，使用默认分词即可。index取值：index = FieldIndex.not_analyzed：不分词、index = FieldIndex.analyzed：分词、index = FieldIndex.no：不建立索引另外，经过测试发现，尽管上面实体主键的映射类型为integer，但在索引库中查看最终还是映射为string类型.. 4、持久层 XxxRepository：因为Spring data elasticsearch遵从Spring data规范，所以只要熟悉Spring Data JPA，就可以实现无缝对接操作索引库。命名查询、排序查询、分页条件查询等jpa支持的，它都支持。所有API都相似，所以用起来很顺手！！XxxRepository也值需要继承一个ElasticSearchRepository接口，就可无需定义实现类，操作文档对象。 5、业务层：和其他业务层规范相似，略 6、测试类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.leahshi.test; import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.elasticsearch.core.ElasticsearchTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.leahshi.domain.Article;import com.leahshi.service.IArticleService;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class ElasticSearch_spring_test &#123; @Autowired private IArticleService articleService; @Autowired private ElasticsearchTemplate elasticsearchTemplate; // 创建索引 @Test public void test()&#123; elasticsearchTemplate.createIndex(Article.class); elasticsearchTemplate.putMapping(Article.class); &#125; // spring data elasticSearch crud操作 @Test public void test01() &#123; // 如果存在则执行修改操作，不存在执行保存操作 Article article = new Article(); article.setId(1001); article.setTitle(i + &quot;Elasticsearch相关介绍&quot;); article.setContent(i + &quot;Elasticsearch （ES）是一个基于 Lucene 的开源搜索引擎，它不但稳定、可靠、快速，而且也具有良好的水平扩展能力，是专门为分布式环境设计的。&quot;); articleService.save(article); // 删除 // Article article = new Article(); // article.setId(1001); // articleService.delete(article); &#125; // 查询 - 排序查询 @Test public void fun02() &#123; // 根据id查询 // Article article = articleService.findOne(1001); // System.out.println(article); // 查询所有 // Iterable&lt;Article&gt; list = articleService.findAll(); // for (Article article : list) &#123; // System.out.println(article); // &#125; // 排序查询 for (int i = 1; i &lt;= 100; i++) &#123; Article article = new Article(); article.setId(i); article.setTitle(i + &quot;Elasticsearch相关介绍&quot;); article.setContent(i + &quot;Elasticsearch （ES）是一个基于 Lucene 的开源搜索引擎，它不但稳定、可靠、快速，而且也具有良好的水平扩展能力，是专门为分布式环境设计的。&quot;); articleService.save(article); &#125; Iterable&lt;Article&gt; all = articleService.findAll(new Sort(new Sort.Order(Sort.Direction.DESC,&quot;id&quot;))); for (Article article : all) &#123; System.out.println(article); &#125; &#125; // 分页条件查询 @Test public void fun03()&#123; // 查询第二页，每页显示10调数据 Pageable pageable = new PageRequest(1, 10); Page&lt;Article&gt; pageData = articleService.findAll(pageable); for (Article article : pageData.getContent()) &#123; System.out.println(article); &#125; &#125;&#125;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch入门]]></title>
    <url>%2Fpost%2FElasticSearch%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[ElasticSearch和solr一样都是基于Lucene的搜索服务器，在Lucene提供一套全文检索的API。ElasticSearch用于解决数据量庞大时，关系型数据库查询效率低下的问题。并且它提供分布式多用户能力的开源搜索引擎。ElasticSearch为每个词条创建索引，这些文档中所有词条列表构成倒排索引。当搜索某个词条时，直接找到对应的索引，就像我们再查找字典时，先查找索引中的首字母或者偏旁一样。ElasticSearch采用Restful风格，所以都是采用json格式数据传输 一、下载及安装ElasticSearch是基于java的开发的，所以在安装jdk配置配置JAVA_HOME后，安装很简单，在官网下载完成后，直接解压，双击bin/elasticsearch.bat 启动服务，访问123456789101112131415161718192021 安装可视化化工具ES head： 在elasticsearch-x.x.x/bin/plugin.bat 目录下执行**install mobz/elasticsearch-head**命令，安装完成后，重启服务，访问```http://localhost:9200/_plugin/head/```完成安装ElasticSearch服务器默认的端口是9300，在浏览器中的端口是9200## 二、主要概念在ElasticSearch搜索服务器中存在着和传统的关系型数据库类似的概念。- 索引：相当于关系型数据库的表，存储数据的表结构，任何搜索数据存放在索引对象上- 文档：存储在数据库中的一行记录（数据，由词条搜索得出），存在索引对象上- 文档类型：一个索引对象可以存储多个不同类型数据，数据用文档类型标识- 映射：数据如何存放到索引对象上，需要有一个映射配置， 数据类型、是否存储、是否分词 …开发ElasticSearch程序顺序：建立索引对象 - 建立映射 - 存储数据 - 指定文档类型搜索数据 - 查询数据 * 注：创建文档时需要指定索引和文档类型，会自动创建索引和添加映射## 三、快速入门 引入jar包： org.elasticsearch elasticsearch 2.4.0123### 1、自动创建索引和文档对象文档对象格式和映射关系不可自定义，引入IK分词器支持后还需要在文档对象中引用IK分词器！！！ @Testpublic void test() throws Exception { // 创建连接搜索服务器对象 Client client = TransportClient.builder().build() .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(“127.0.0.1”), 9300)); // 可以采用练市编程创建集群搜索服务器 // .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(“127.0.0.1”), 9300)); // 使用XContentBuilder对象 构造json数据 // {id:1,title:””,content:””} XContentBuilder contentBuilder = XContentFactory.jsonBuilder() .startObject() .field(“id”, 1) .field(“title”, “ElasticSearch是一个基于Lucene的搜索服务器”) .field(“content”, “它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。”) .endObject(); // 创建文档对象 直接在ElasticSearch中建立文档，自动创建索引 client.prepareIndex(&quot;idx01&quot;, &quot;article&quot;, &quot;1&quot;).setSource(contentBuilder).get(); // 关闭连接 client.close(); } 123### 2、基于各种搜索对象搜索文档 @Testpublic void test01() throws Exception { // 创建连接所有服务器对象 Client client = TransportClient.builder().build().addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(“127.0.0.1”), 9300)); /** * 搜索数据: * matchAllQuery ：查询所有匹配条件的结果 * queryStringQuery : 基于分词查询 ，可以根据多个词条进行查询，并对其取交集或者并集 * fuzzyQuery : 相似度查询 * BoolQuery ： 组合多个查询条件 * wildcardQuery ： 模糊查询，在左右两侧加上 * 而不是 % ！！！ * termQuery() 和 wildcardQuery 类似基于词条查询 并且是基于默认词条查询 一个字一个字匹配 */ SearchResponse response = client.prepareSearch(&quot;idx01&quot;).setTypes(&quot;article&quot;).setQuery(QueryBuilders.matchAllQuery()).get(); // SearchResponse response = client.prepareSearch(&quot;idx01&quot;).setTypes(&quot;article&quot;).setQuery(QueryBuilders.queryStringQuery(&quot;搜索&quot;)).get(); // SearchResponse response = client.prepareSearch(&quot;idx01&quot;).setTypes(&quot;article&quot;).setQuery(QueryBuilders.wildcardQuery(&quot;content&quot;, &quot;*搜索*&quot;)).get(); // SearchResponse response = client.prepareSearch(&quot;idx01&quot;).setTypes(&quot;article&quot;).setQuery(QueryBuilders.termQuery(&quot;content&quot;, &quot;搜索&quot;)).get(); // 打印并输出 SearchHits hits = response.getHits(); System.out.println(&quot;总条数&quot; + hits.getTotalHits()); Iterator&lt;SearchHit&gt; iterator = hits.iterator(); while (iterator.hasNext()) { // 获取每个查询对象 SearchHit hit = iterator.next(); // 获取每个对象内容 System.out.println(hit.getSourceAsString()); // 获取具体的某个字段 System.out.println(&quot;title:&quot; + hit.getSource().get(&quot;title&quot;)); } }1234567891011121314以上测试类，只有matchAllQuery可以 返回所有数据，queryStringQuery也可以返回数据，wildcardQuery和termQuery均不能返回结果。按照定义，&quot;搜索&quot;这个词条应该存在ElasticSearch索引库中，为什么查不到呢？这是因为ElasticSearch对中文支持很差，基本上是按照一个字一个字分词，所以需要引入第三方分词器对中文进行分词。 ## 四、分词器介绍 ### 1、安装与配置在开发中我们常用的是ik分词器集成ElasticSearch来使用，ik分词器是一个开源的基于java开发的轻量级中文分词工具包。第一步：[戳这里下载](https://github.com/medcl/elasticsearch-analysis-ik/tree/2.x) 第二步：下载完成后，进入 target/release 目录，将除了 elasticsearch-analysis-ik-x.x.x 目录外所有文件；拷贝到 %es%/plugins/analysis-ik下第三步：进入 target/release/config 目录，将所有配置文件，复制 %es%/config 下；第四步：配置 config/elasticsearch.yml，在最后加上 【index.analysis.analyzer.ik.type: &quot;ik&quot;】### 2、ik分词器集成ElasticSearch @Testpublic void test02() throws Exception { Client client = TransportClient.builder().build() .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(“127.0.0.1”), 9300)); // 1、手动创建索引 client.admin().indices().prepareCreate(&quot;idx02&quot;).get(); // 删除索引 // client.admin().indices().prepareDelete(&quot;idx02&quot;).get(); // 2、添加映射 凭借json数据 {&quot;mappding&quot;:{&quot;article&quot;:{&quot;properties&quot;:{&quot;id&quot;:{&quot;type&quot;:&quot;&quot;,&quot;store&quot;,&quot;&quot;},&quot;title&quot;:{&quot;type&quot;:&quot;&quot;,&quot;store&quot;,&quot;&quot;},&quot;content&quot;:{&quot;type&quot;:&quot;&quot;,&quot;store&quot;,&quot;&quot;}}}}} XContentBuilder builder = XContentFactory.jsonBuilder() .startObject() .startObject(&quot;article&quot;) .startObject(&quot;properties&quot;) .startObject(&quot;id&quot;).field(&quot;type&quot;, &quot;integer&quot;).field(&quot;store&quot;, &quot;yes&quot;).endObject() .startObject(&quot;title&quot;).field(&quot;type&quot;, &quot;string&quot;).field(&quot;store&quot;, &quot;yes&quot;).field(&quot;analyzer&quot;, &quot;ik&quot;).endObject() .startObject(&quot;content&quot;).field(&quot;type&quot;, &quot;string&quot;).field(&quot;store&quot;, &quot;yes&quot;).field(&quot;analyzer&quot;, &quot;ik&quot;).endObject() .endObject() .endObject() .endObject(); PutMappingRequest mapping = Requests.putMappingRequest(&quot;idx01&quot;).type(&quot;article&quot;).source(builder); client.admin().indices().putMapping(mapping).get(); // 文档对象 client.close(); }12以上测试方法执行完成后，在http://localhost:9200/_plugin/head/ 可以看到，已经创建了一个idx02索引库 // 文档操作@Testpublic void test03() throws Exception { // 创建连接搜索服务器对象 Client client = TransportClient.builder().build() .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(“127.0.0.1”), 9300)); // 根据返回实体转换json封装索引 Article article = new Article(); article.setId(2); article.setTitle(&quot;Elasticsearch相关介绍&quot;); article.setContent(&quot;Elasticsearch （ES）是一个基于 Lucene 的开源搜索引擎，它不但稳定、可靠、快速，而且也具有良好的水平扩展能力，是专门为分布式环境设计的。&quot;); // jackson ObjectMapper mapper = new ObjectMapper(); // 创建文档 client.prepareIndex(&quot;idx02&quot;, &quot;article&quot;, article.getId().toString()).setSource(mapper.writeValueAsString(article)).get(); // 删除文档 //client.prepareDelete(&quot;idx02&quot;, &quot;article&quot;, article.getId().toString()).get(); //client.delete(new DeleteRequest(&quot;idx02&quot;, &quot;article&quot;, article.getId().toString())).get(); // 修改文档 //client.prepareUpdate(&quot;idx02&quot;, &quot;article&quot;, article.getId().toString()).setDoc(mapper.writeValueAsString(article)).get(); //client.update(new UpdateRequest(&quot;idx02&quot;, &quot;article&quot;, article.getId().toString())).get(); client.close(); } 12在idx02索引库中可以看到已经有一条数据已经插入 // 分页搜索@Testpublic void test04() throws Exception{ // 创建连接搜索服务器对象 Client client = TransportClient.builder().build() .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(“127.0.0.1”), 9300)); ObjectMapper mapper = new ObjectMapper(); // 批量查询记录 for (int i = 1; i &lt;= 100; i++) { // 描述json 数据 Article article = new Article(); article.setId(i); article.setTitle(i+&quot;Elasticsearch相关介绍&quot;); article.setContent(i+&quot;Elasticsearch （ES）是一个基于 Lucene 的开源搜索引擎，它不但稳定、可靠、快速，而且也具有良好的水平扩展能力，是专门为分布式环境设计的。&quot;); // 建立文档 client.prepareIndex(&quot;idx02&quot;, &quot;article&quot;, article.getId().toString()) .setSource(mapper.writeValueAsString(article)).get(); } // 根据title字段中 包含&quot;搜索&quot; 这个词条 的结果集进行分页查询 SearchRequestBuilder requestBuilder = client.prepareSearch(&quot;idx01&quot;).setTypes(&quot;article&quot;).setQuery(QueryBuilders.termQuery(&quot;title&quot;, &quot;搜索&quot;)); // 查询第二页 每页显示20条 不进行分页的情况下默认是返回10条 int pageNo = 1; int pageSize = 20; requestBuilder.setFrom((pageNo-1)*pageSize).setSize(pageSize); SearchResponse response = requestBuilder.get(); // 打印并输出 SearchHits hits = response.getHits(); System.out.println(&quot;总条数&quot; + hits.getTotalHits()); Iterator&lt;SearchHit&gt; iterator = hits.iterator(); while (iterator.hasNext()) { // 获取每个查询对象 SearchHit hit = iterator.next(); // 获取每个对象内容 System.out.println(hit.getSourceAsString()); // 获取具体的某个字段 System.out.println(&quot;title:&quot; + hit.getSource().get(&quot;title&quot;)); } client.close(); }1234在控制台中就返回了20条数据，因为没有排序，所以返回的id不是连续的在很多全文搜索服务中，会对关键字进行高亮显示，原理很简单，就是在搜索关键在的周围定义一个标签，并对标签定义样式 // 高亮显示处理@Testpublic void test05() throws Exception { // 创建连接搜索服务器对象 Client client = TransportClient.builder().build() .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(“127.0.0.1”), 9300)); ObjectMapper objectMapper = new ObjectMapper(); // 搜索数据 SearchRequestBuilder searchRequestBuilder = client.prepareSearch(&quot;idx01&quot;).setTypes(&quot;article&quot;) .setQuery(QueryBuilders.termQuery(&quot;content&quot;, &quot;搜索&quot;)); // 高亮定义 searchRequestBuilder.addHighlightedField(&quot;content&quot;); // 对title字段进行高亮 searchRequestBuilder.setHighlighterPreTags(&quot;&lt;em&gt;&quot;); // 前置元素 searchRequestBuilder.setHighlighterPostTags(&quot;&lt;/em&gt;&quot;);// 后置元素 SearchResponse searchResponse = searchRequestBuilder.get(); SearchHits hits = searchResponse.getHits(); // 获取命中次数，查询结果有多少对象 System.out.println(&quot;查询结果有：&quot; + hits.getTotalHits() + &quot;条&quot;); Iterator&lt;SearchHit&gt; iterator = hits.iterator(); while (iterator.hasNext()) { SearchHit searchHit = iterator.next(); // 每个查询对象 // 将高亮处理后内容，替换原有内容 （原有内容，可能会出现显示不全 ） Map&lt;String, HighlightField&gt; highlightFields = searchHit.getHighlightFields(); HighlightField titleField = highlightFields.get(&quot;content&quot;); // 获取到原有内容中 每个高亮显示 集中位置 fragment 就是高亮片段 Text[] fragments = titleField.fragments(); String title = &quot;&quot;; for (Text text : fragments) { // text将一条数据的该字段切分 title += text; } // 将查询结果转换为对象 Article article = objectMapper.readValue(searchHit.getSourceAsString(), Article.class); // 用高亮后内容，替换原有内容 article.setTitle(title); System.out.println(article); } // 关闭连接 client.close(); }`]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native之常用组件介绍]]></title>
    <url>%2Fpost%2FReact%20Native%E4%B9%8B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[移动端适配是很重点的问题，接下来会用几篇总结布局相关的组件及技巧方法等；上篇中环境搭建好了之后，分析代码就可以发现，render(){}内用到的所有标签，（RN中称之为组件）都不是我们熟知的，但因为之前有做过微信小程序的经验，布局的标签有相似的地方：比如，容器标签在小程序中是view标签，在RN中就是View容器；文本标签前者为text,后者为Text；图片标签前者为image,后者为Image…应该说小程序有借鉴RN的思想。 一、使用组件前，需要将组件在前面申明定义：123456789import &#123; AppRegistry, //注册程序，通常只需要在index.js引用 StyleSheet, //样式 Text, //文本组件 View, //容器组件 TextInput //输入框组件 ScrollView, //可滚动的容器 可放不同的组件和视图 TouchableHighlight, //可触摸组件&#125; from &apos;react-native&apos;; 二、常用内置组件说明：1、View是容器组件： 相当于div标签，是所有组件的父组件。在render(){return( {/ 此处写布局 /} )}布局元素内，最外层必须要有个大的标签包裹。 注意不能把文本的样式（比如color、font-size等）卸载View组件上。 2、Text是文本组件：文字只能放在该组件内，放在View内会报错。文本组件的属性也是多重继承的，但是只适用于 Text组件之间的嵌套，倘若一个View &gt; Text组件，将文本属性设置给View将会报错。其余属性和css中是一样的，特殊的属性有： numberOfLines → 设置Text文本的行数（值为数字类型），若显示的内容超过了行数，其他信息不显示。 textDecorationLine → 横线位置，相当于网页中的text-decoration (“none”, ‘underline’, ‘line-through’, ‘underline line-through’) textDecorationStyle → 线的风格，(“solid”, ‘double’, ‘dotted’, ‘dashed’) writingDirection → 文本方向(“auto”, ‘ltr’, ‘rtl’) 3、Image是图片组件i、该组件既可以是以单标签的形式结束，又可以以双标签的形式结束（可作为背景图片）。ii、该组件必须加上宽高方可显示，且有resizeMode这一属性，同微信小程序。 Image.resizeMode.cover：图片居中显示，没有被拉伸，超出部分被截断； Image.resizeMode.contain：容器完全容纳图片，图片等比例进拉伸； Image.resizeMode.stretch： 图片被拉伸适应容器大小，有可能会发生变形。 iii、图片组件加载图片的几种方法： 本地资源：（相对于当前的路径检索， ./ 不可少） 1&lt;Image source=&#123;require(&apos;./img/2.png&apos;)&#125; style=&#123;&#123;width: 50,height:50&#125;&#125;/&gt; 网络资源： 1&lt;Image source=&#123;uri(https://test.png)&#125; style=&#123;&#123;width: 50,height:50&#125;&#125;/&gt; APP中的资源（适用于已经用原生语言开发过的APP） 1&lt;Image source=&#123;require(&apos;image!icon_homepage_map&apos;)&#125; style=&#123;&#123;width: 50,height:50&#125;&#125;/&gt; 小demo（点击切换图片）12345678910111213141516171819202122232425262728293031class ToggleImage extends PureComponent &#123; //初始值 constructor(props:Object) &#123; super(props) this.state = &#123; isRefreshing: false, isNormal: true, img_change: require(&apos;./../../img/Mine/avatar.png&apos;) &#125; &#125; render()&#123; return( &lt;View style=&#123;styles.testBox&#125;&gt; &lt;TouchableOpacity activeOpacity=&#123;0.6&#125; //onPress 绑定在View上无效 onPress=&#123;() =&gt; this.changeImage()&#125; &gt; &lt;View style=&#123;styles.sonBox&#125;&gt; &lt;Image source=&#123;this.state.img_change&#125; style=&#123;styles.icon&#125; /&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125; changeImage() &#123; this.state.isNormal ? this.setState(&#123;img_change: require(&apos;./../../img/img_normal.png&apos;), isNormal: false&#125;) : this.setState(&#123;img_change: require(&apos;./../../img/img_active.png&apos;), isNormal: true&#125;) &#125;&#125; 4、TextInput5、ScrollView6、ListView7、TouchableHighlight8、自定义组件三、布局相关1、FlexBox布局在React Native中主要是用来Flex布局，关于flex布局可以参见 之前总结的文章 ,不同的是，在RN中主轴为column，交叉轴为row，和一般网页相反。使用属性flex-direction 2、react-native 单位换算：设计图采用的是PX，而 RN 默认采用的dp，书写样式的时候不需要带单位。设计稿原型：基于iphone6（1334 x 750 px）设置尺寸的时候，可以转换为设计稿标注图的一半，比如一个按钮尺寸为 150 80，设置为75 40]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>跨平台</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native之环境搭建]]></title>
    <url>%2Fpost%2FReact%20Native%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[移动端跨平台问题一直都是大家关注的焦点，是想一套代码，运行在多个平台，可以省下多少事。目前跨平台的前端框架有很多，React Native 是伟大的facebook公司15年发布，至今更新了很多个版本尽管一直没有发布1.0版本，仍然抵挡不住大家的热情。之后的一段时间，我也会在这方面总结一系列教程和方法。 第一篇来介绍下如何搭建React Native开发环境。搭建环境有相应的几种平台，在Windows下只能 run-android，在Mac OS X系统可一运行ios&amp;&amp;android双平台。由于博主有有windows系统电脑，下面主要介绍在windows下搭建React Native开发环境填的坑… 一、依次安装以下环境：1、安装Java： 假如电脑跑起来过项目的话，java环境肯定是有的，可以执行java -version命令来检测 2、安装SDK： SDK下载地址：http://tools.android-studio.org/index.php/sdk/ 设置系统环境变量菜单：控制面板\系统和安全\系统\高级系统设置\环境变量 （window10下） 设置环境变量ANDROID_HOME：Android SDK Manager的位置 例如：（ANDROID_HOME=&gt; E:\Android\sdk） 设置环境变量PATH 例如：（PATH=&gt; %ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools） 3、下载SDK相关：(重要，不要漏掉任何一项) 打开Android SDK Manager。 选中Android SDK Build-tools version 23.0.1 （其他版本可能会出错） Android 6.0 (API 23) （注意安装Genymotion时要注意模拟器版本不能太低） Android Support Repository Local Maven repository for Support Libraries下载以上SDK内容可能会很慢，耐心等待即可。 3、安装node：下载地址：https://nodejs.org/en/要求4.1版本以上，通过node -v的命令来测试NodeJS是否安装成功 4、安装git：下载地址：https://git-for-windows.github.io/ 二、安装React Native相关脚手架：（重要，要按步骤耐心等待下载）1、进入想要安装RN环境的目录2、右键选择git bash 输入git clone https://github.com/facebook/react-native.git，耐心等待下载3、再命令行中执行cd react-native/react-native-cli进入相应目录，执行npm install -g (目的：执行react-native命令)4、进入想要创建RN项目的目录，执行react-native init AwesomeProject（项目名）命令，耐心耐心等待5、项目初始化后可以看到android、ios、node_modules文件夹、index.android.js、index.ios.js文件等… 三、安装Genymotion模拟器：Genymotion官网地址：http://www.genymotion.net/可以自己在网上下，也可附上百度云下载地址：http://pan.baidu.com/s/1pKH8BnP注意： Genymotion对私人开发者免费开源，注册即可（登录需要填写用户名、密码）。对公账户需要收费。 双击安装Genymotion会连带安装Oracle VM VirtualBox，要将VirtualBox升级最新版本，（使用360即可），不然会报错，（unable to start the virtual device.VirtualBox cannot start the virtual device）错误稍后会以专题总结。 四、启动项目：1、进入项目目录，执行react-native start命令，耐心等待。访问http://localhost:8081/index.android.bundle?platform=android，如果可以访问表示服务器端跑起来了。2、启动Genymotion，或者用数据线连接安卓机真机调试，再另启命令行，输入react-native run-android，时间很长，耐心等待。3、第一次启动会报错，can&#39;t find variable:..... 解决方法：在模拟器调试状态下按下ctrl+M，（真机调试下摇一摇）调出弹窗，点击Dev Settings → Debug server host &amp; port for device(设置本机的ip和端口固定8081) → 再次ctrl+M(摇一摇),选择Reload JS（因为RN报错，很多错误无从找起，稍后会用另起一篇专门总结RN中常见错误）4、Welcome to React Native！ 当看到这样的字时，恭喜你环境搭建好了，可以下一步熟悉相关api了。5、之后启动项目直接运行react-native run-android 即可，start命令可以省略，倘若要安装第三方插件时，需要关掉再重启。 相关学习资源github上的地址：https://github.com/facebook/react-native江清清RN系列教程：http://www.lcode.org/react-native/React Native中文网：http://reactnative.cn/资源合集：https://github.com/reactnativecn/react-native-guide第三方组件合集：http://blog.csdn.net/chichengjunma/article/details/52920137]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>跨平台</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见，擎木科技]]></title>
    <url>%2Fpost%2F%E5%86%8D%E8%A7%81%EF%BC%8C%E6%93%8E%E6%9C%A8%E7%A7%91%E6%8A%80%2F</url>
    <content type="text"><![CDATA[今天是周一，也是我在擎木的最后一天。当你们看到这些文字时，我已离开了这个团队，开始享受一段短暂的假期。 自15年，到如今近两年的时光。这一路走来，自己成长了许多，无论是技术层面还是心理层面。公司一直以来给予宽松的时间你预研新鲜的技术，这一点自己一直以来心存感激。 擎木科技是一家光谷联合集团旗下的一家子公司，做互联网家装这块。很遗憾有这样强大的背景一直方向不太明朗。技术人最满足的莫过于用户愿意用你的产品，很可惜我们鲜有这样的成就感…… 在职期间得到很多同事的关照，大家相处的很愉快，也因工作而争吵过，人来人往，相忘江湖。 离别即是解脱，最是伤感。熟悉到陌生到熟悉，人生的每个阶段都会经历，而此时，最不舍的，便是那群帮助过的小伙伴们。 比如面试我的周公，每次遇到棘手的问题，在他哪里总能得到答案。入职第一天，他见我一个人便让林姐带我一起去食堂吃饭，看我下班好久了手头没什么事又不好意思走的样子，对我说先走。对于一个刚从熟悉到陌生环境过渡的人来说，这种温暖是让人印象很深刻的，以至之后来了新同事，我也会问人家要不要一起吃饭。他一直是我敬重的老大。 比如工作特别拼脾气很好的林姐，总是在我们最后一个下班。她对我也非常关照；比如直来直往很有生活气息的龙，她也教会我很多，即便是离开后也时常给我很多建议。感激。 最不舍的就是一起吃饭的童鞋们。可以坐在电脑前一天一句话不说的黑科技，以前一直觉得他酷酷的，跟他说十句话才回你一句话那种，其实很热心的人，遇到问题，就找黑科技。哈哈~ 还有老是被我说有狂暴症和多动症的陈同学、不管说啥笑呵呵闷骚的李锦和白哥、追求设计稿与产品0px差距，谦逊有礼的梦茜、还有操碎心最有责任感的段老板、还有粤语歌唱的超好超好听的程同学，他和肖大（太）师（婆）都是我的老乡，有缘。还有余同学、王同学、郑同学，感恩。（ps：程序猿真的很靠谱啊，从在同一家毫无特色的馆子里可以吃了三四个月只是因为麻烦不想换别家就可以看出来了==） 职场上总是人来人往，以上提及的很多都已经离职了。若以这样方式来记述在这里的光景，倒也显得不是无趣。 离开，每个选择都有它的理由。只能说，缘分已尽。是时候了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序相关总结（三）]]></title>
    <url>%2Fpost%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接上篇。此篇是最后一篇了，小程序网上相关资料很多，新的东西在开发过程中肯定会不停的填坑。一些常见的方法就不一一总结了，该系列只总结此次项目中频繁遇到的一些问题。下个项目，负责人提出用React Native 来重构我们的原生APP。没有接触过的东西，还是很心动的。又是一趟填坑之旅…废话不多说，最后一篇上 星星打分wxml结构：1234567891011&lt;view class=&quot;all-comment&quot;&gt; &lt;text&gt;整体评价:&lt;/text&gt; &lt;text&gt;&#123;&#123;commentAllInfo&#125;&#125;&lt;/text&gt; &lt;view class=&quot;star-box&quot;&gt; &lt;block wx:for=&quot;&#123;&#123;stars&#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;image class=&quot;star-image&quot; src=&quot;&#123;&#123;allKey &gt; item ? selectedSrc : normalSrc&#125;&#125;&quot;&gt; &lt;view class=&quot;star-item&quot; data-key=&quot;&#123;&#123;item+1&#125;&#125;&quot; data-type=&quot;all&quot; bindtap=&quot;select&quot;&gt;&lt;/view&gt; &lt;/image&gt; &lt;/block&gt; &lt;/view&gt;&lt;/view&gt; js123456789101112131415161718192021222324252627282930313233Page(&#123; data: &#123; stars: [0, 1, 2, 3, 4], commentInfoList: [&apos;非常不满意&apos;, &apos;不满意&apos;, &apos;一般&apos;, &apos;满意&apos;, &apos;非常满意&apos;], normalSrc: &apos;../../../images/star_normal.png&apos;, selectedSrc: &apos;../../../images/star_active.png&apos;, allKey: 0, commentAllInfo: &apos;&apos;, &#125;, onLoad: function (options) &#123; this.requestData(); &#125;, // 打分 select: function (e) &#123; var key = e.currentTarget.dataset.key; var index = this.data.stars.indexOf(key - 1); var _type = e.currentTarget.dataset.type; if (this.data.key == 1 &amp;&amp; e.currentTarget.dataset.key == 1) &#123; key = 0; &#125; this.setData(&#123; allKey: key, commentAllInfo: this.data.commentInfoList[index], &#125;) this.setData(&#123; gzKey: key, commentGZInfo: this.data.commentInfoList[index] &#125;); &#125;&#125;) 获取验证码源码：戳这里分析： 页面间传参在实际项目中用到很多，最常见的是列表页，点击对应项链接详情页，显示全部内容。跳转链接，在小程序中三种使用的方法，前面已介绍。此处直接使用navigate标签列表页：12345&lt;navigator url=&quot;../../pages/projectAcceptance/checkInfo/checkInfo?id=&#123;&#123;info.id&#125;&#125;&amp;name=&#123;&#123;array[index].name&#125;&#125;&quot; hover-class=&quot;navigator-hover&quot;&gt; &lt;view class=&quot;check_no_pass_info&quot;&gt; 查看详情 &lt;/view&gt;&lt;/navigator&gt; 详情页中：在onload方法里有个options的参数，可以接受上个页面传递过来的参数：12345678910onLoad: function (options) &#123; // 页面初始化 options为页面跳转所带来的参数 console.log(options); id = options.id; wx.setNavigationBarTitle(&#123; title: options.name, &#125;) this.requestProjectDetail();&#125;, 源码戳这里]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序相关总结（二）]]></title>
    <url>%2Fpost%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接上篇。此篇主要讲后台接口返回的数据处理，以及小程序的缓存机制。这些问题在实际开发过程中经常会触及，倘若没有想到某些点，可能会走了弯路。想通了后其实很简单。 一、巧用wx:if1.1、基本概念小程序中使用wx:if表示条件渲染，更多渲染视图的方法戳这里wx:if后面通常接一个由双花括号包裹的布尔类型，可以为一个变量或者表达式，总之花括号内最后值一定为Boolean，当为true时，被绑定元素或代码块才显示。 1.2、使用场景某元素，在某状态下才显示：比如，此次项目中，我的工地模块，当工地状态显示为待评价时，链接到评价页面的按钮才出现。1234//工地的信息有很多条，从接口中拿 baseData为自定义的一个对象，当请求成功后，将数据赋值给baseData&lt;navigator wx:if=&quot;&#123;&#123;baseData.status == &apos;待评价&apos;&#125;&#125;&quot; url=&quot;../../pages/mySite/comment/comment?id=&#123;&#123;userid&#125;&#125;&amp;&amp;name=&#123;&#123;name&#125;&#125;&quot;&gt; &lt;button class=&quot;comment&quot;&gt;给出您的评价&lt;/button&gt; &lt;/navigator&gt; 后台返回数据，前台做出的处理：比如，在支付模块中卡的类型上，后台返回的是000，001，002分别对应储蓄卡、信用卡、借记卡。 法一：可以继续法一的思想，在js中请求数据成功后，进行数据转换：注意：setData的对象，不要是具体的字段，而是整个列表渲染中整个对象。倘若是具体字段思路：在js里使用for循环，遍历列表拿到卡类型对应的字段再判断，再push到数组内，最后使用this.setData({})。this.data.testArr.push()小程序中没有这种写法。还需要在page方法最外面再定义一个数组，传递一下。然而最后位置还错位了，并没有对应上。 1234567891011121314for (var i = 0; i &lt; that.data.countList.length; i++) &#123; if(that.data.countList[i].tradingWay == &apos;000&apos;)&#123; that.data.countList[i].tradingWay = &apos;储蓄卡&apos;; &#125;else if(that.data.countList[i].tradingWay == &apos;001&apos;)&#123; that.data.countList[i].tradingWay = &apos;信用卡&apos;; &#125;else&#123; that.data.countList[i].tradingWay = &apos;借记卡&apos;; &#125; &#125;that.setData(&#123; countList: that.data.countList, &#125;) 法二：简单粗暴的使用wx:if：123&lt;text wx:if=&quot;&#123;&#123;countItem.tradingWay==&apos;0000&apos;&#125;&#125;&quot;&gt;储蓄卡&lt;/text&gt;&lt;text wx:if=&quot;&#123;&#123;countItem.tradingWay==&apos;0001&apos;&#125;&#125;&quot;&gt;信用卡&lt;/text&gt;&lt;text wx:if=&quot;&#123;&#123;countItem.tradingWay==&apos;0002&apos;&#125;&#125;&quot;&gt;借记卡&lt;/text&gt; 数据处理：无法确定后台返回的是什么，且需要处理时，还是需要数据请求成功后在js中来处理，比如在金额后面保留小数点两位、时间只需要年月日，无需时分秒时： 123456789for (var i = 0; i &lt; that.data.countList.length; i++) &#123; // 2017-05-09 that.data.countList[i].orderDate = that.data.countList[i].orderDate.subString(0,10); that.data.countList[i].totalMoney = that.data.countList[i].totalMoney.toFixed(2); &#125;that.setData(&#123; countList: that.data.countList, &#125;) 缺省页时使用：12345678&lt;view wx:if=&quot;&#123;&#123;countList.length &gt; 0&#125;&#125;&quot;&gt;&lt;view wx:for=&quot;&#123;&#123;countList&#125;&#125;&quot; wx:for-item=&quot;countItem&quot; wx:for-index=&quot;idx&quot;&gt; //渲染列表&lt;/view&gt;&lt;/view&gt; &lt;view wx:else&gt;此处是缺省时!&lt;/view&gt; 三、小程序缓存机制小程序目录结构中，通用方法都写在了utils.js里，可以在里面定义一些各个模块都需要的数据或信息，比如项目中四个模块都需要加载更多工地。使用wx.getStorageSync()方法缓存数据：123456789101112//缓存数据 function setData(mKey, mValue) &#123; wx.setStorage(&#123; key: mKey, data: mValue, &#125;)&#125;//取数据function getData(mKey) &#123; return wx.getStorageSync(mKey)&#125; 项目中，需要首先进入登录页，获取到手机号后缓存，再根据手机号查询显示各个模块的数据，在登录页面成功取到手机号后，缓存号码12util.setData(&quot;phoneNumber&quot;, res.data.data[0].mobile);//手机号util.setData(&quot;customerName&quot;, res.data.data[0].customerName); //用户名 再在各模块，onload函数内取到数据mobile = util.getData(&quot;phoneNumber&quot;);，作为参数传递到请求方法中，即可显示对应人的工地相关内容。 四、动态设置navigationBarTitleText在验收模块，需要将工地名显示在最上，每个工地名称都不一样，所以不能再.json文件里写死。1234//使用wx.setNavigationBarTitle(&#123;&#125;)方法wx.setNavigationBarTitle(&#123; title: options.name,&#125;)]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序相关总结（一）]]></title>
    <url>%2Fpost%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[微信小程序业主端的项目上周已完成，官方文档已经介绍的很清楚了，下面主要总结项目中频繁遇到的问题。 一、UI相关1.1、组件除了官方提供的组件及API外，官方demo戳这里推荐使用第三方的WeUI组件库在线预览戳这里。 1.2、弹框此次项目中使用的弹框中涉及比较复杂的操作和UI，在官方组件中的dialog可更改编辑的只是一段文本。相关资料有用modal遮罩层的方法，亲测实用，这样我们就可以在里面自定义各种结构。123&lt;modal title=&quot;弹框标题&quot; hidden=&quot;&#123;&#123;modalHidden&#125;&#125;&quot; confirm-text=&quot;确定&quot; cancel-text=&quot;取消&quot; bindconfirm=&quot;modalBindaconfirm&quot; bindcancel=&quot;modalBindcancel&quot;&gt; &lt;!-- 此处自定相关复杂结构 --&gt;&lt;/modal&gt; 官方文档没有找到相关的参数说明，再次详细介绍：| 参数 | 类型 | 是否必填 | 说明 |默认值|| :——: | :—–: | :—-: |:—-: |:—-:|| title | String | 是 |提示的标题| || content | String | 是 |提示的内容| || showCancel | Boolean | 否 |是否取消按钮|true|| cancelText | String | 否 |取消按钮的文字|”取消”|| cancelColor | HexColor | 否 |取消按钮的文字颜色|”#000”|| confirmText | String | 否 |确定按钮的文字|”确定”|| confirmColor | HexColor | 否 |确定按钮的文字颜色|”#3cc51f”|| success | Function | 否 |调用接口成功的回调||| fail | Function | 否 |失败的回调|| 1.3、图片 微信小程序不能设置本地背景图片资源，如果是网络图片链接，才可以显示。 小程序中要给图片定宽高，默认image的高宽是300*225。必须样式定义去覆盖这个默认高宽，auto在这里不生效。 小程序的image是按照background-image来实现的，官方文档中为image提供了四种显示模式和九种裁剪模式，通过mode来设置 按照设计稿为750*1334的尺寸标注上的数值设置即可。单位用rpx，小程序中rpx是一个自适应显示的单位。这就意味着我们无需为适配而苦恼。 二、this关键字微信小程序中的this指代的是page对象。在小程序js文件中，page({})相当于一个入口函数。在一个函数调用另一个函数时，写成this.myFun()；在调用data:{}内的全局变量时，写成this.data.变量名。 2.1、this.setData初始化数据中，data会以JSON的形式由逻辑层传至渲染层。在官方文档中描述的很清楚。 当需要取到初始化data内的数据时，使用this.data.变量名的方法 当需要在某种状态下改变data时，使用this.setData({变量名:改变值,变量名:改变值})的方法 2.2、请求数据时如果用wx.request请求数据成功后，使用this.setData({});来替换数据时，会报this.setData is not a function的错误。这是因为微信小程序在处理网络返回数据时，不能直接使用this。 要事先定义一个this的代理。如：var that = this;并且要在函数外面声明，在success内声明无效。 为了避免this和this代理混淆，建议统一在函数内声明this代理，两者很容易写混，题主就因为写混了一次，花了十几分钟来找bug。因为小程序尚且处于生长阶段，编辑器报错做的不是很完善，在编写过程中，遇到很多坑。 三、跳转页面方法 使用navigator页面链接，相当于a标签，默认值是navigate，倘若需要在新页面打开，无法返回使用redirectTo。仅支持五级页面跳转。 使用wx.navigateTo({})保留当前页面，跳转到应用内的某个页面。相当于a标签的target=”self”，使用wx.navigateBack可以返回到原页面。 使用redirectTo({})关闭当前页面，跳转到应用内的某个页面。相当于a标签的target=”_blank”，无法返回到上一个页面。 3.1、区别 第一种方法使用的标签的方式，后两种是采用函数的方式。 第一种的属性值open-type可以指定后两者的而功能，比如使用open-type=&quot;navigate&quot;设置可以返回到上一页面。其他的值详见官方文档 3.2、实际选择1、在需要向url中动态传参的情况下，可选择第一种navigate的方式： 比如项目中有以下情景：点击列表会链接到详情页中去。 分析： 列表是通过wx:for=&quot;&quot;动态渲染的 对应的列表项点击进去对应的详情，两者通过某特定唯一的参数关联 解决方法：使用&lt;navigator url=&quot;detail.wxml?id=&quot; hover-class=&quot;navigator-hover&quot;&gt;&lt;/navigator&gt;跳转到详情页中，在详情页中onLoad函数中接收id这一参数。 2、在固定的几个列表项中，为了简化结构，可以不使用navigator标签：比如项目中首页的九宫格方式：点击后跳转到对应的模块中:wxml文件中：1234&lt;view bindtap=&quot;linkpage&quot; data-ad=&quot;mySite&quot;&gt;&lt;/view&gt;&lt;view bindtap=&quot;linkpage&quot; data-ad=&quot;projectAcceptance&quot;&gt;&lt;/view&gt;&lt;view bindtap=&quot;linkpage&quot; data-ad=&quot;siteDiary&quot;&gt;&lt;/view&gt;&lt;view bindtap=&quot;linkpage&quot; data-ad=&quot;projectPay&quot;&gt;&lt;/view&gt; js文件中：123456linkpage: function (event) &#123; var sUrl = event.currentTarget.dataset.adwx.navigateTo(&#123; url: &quot;../&quot; + sUrl + &quot;/&quot; + sUrl&#125;)&#125;, 注意：data-ad后的变量最好为各模块的文件名，省掉在js文件中判断。dataset 是HTML5中的新属性。可以在html标签中定义属性data-*，js中在dataset内可找到。主要用来存放数据。关于dataset的相关简介，戳这里]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2Fpost%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[相关资料http://www.techug.com/post/flex-examples.html Flex布局自2009年提出，就一直受到关注。它可以简单、完整、响应式的实现各种页面布局，它的提出意味着打破了标准流中盒子的排列顺序。然后一直以来因为兼容性问题，IE对此兼容极不友好，因此对于flex布局，题主很少使用在项目中。然而此次学习的小程序，对flex布局的兼容性还是很好的。借以总结相关姿势： 采用Flex布局的元素，称为 flex container（父元素）。它的所有子元素自动成为容器成员，称为 flex item。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 一、Flex container 的相关属性： flex-direction: row | row-reverse | column | column-reverse; 决定主轴是水平方向还是垂直方向 flex-wrap: nowrap （不换行）| wrap（换行） | wrap-reverse（反向换行）; 定义如果一条轴线排不下，如何换行。默认为不换行 justify-content: flex-start | flex-end | center | space-between（两端对齐） | space-around（四周都有间距）;定义了项目在主轴上的对齐方式，不改变主轴的指定下，默认是水平方向 align-items: flex-start（交叉轴的起点对齐） | flex-end | center | baseline （项目的第一行文字的基线对齐。）| stretch（默认值：如果项目未设置高度或设为auto，将占满整个容器的高度。）;定义了项目在交叉轴上的对齐方式，不改变主轴的指定下，默认是垂直方向 二、Flex item 的相关属性： order的值为一个整数定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow的值为Number类型，定义项目占据剩余空间的放大比例，默认为0，如一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex属性是flex-grow, flex-shrink（项目的缩小比例）和 flex-basis的简写，默认值为0 1 auto。后两个属性可选 align-self可定义不同的对齐方式，比如斜项对齐。 三、布局容器包含一个项目时，子元素可以位于父元素的九个点的任意一点（参照骰子的布局）。若希望项目在容器主轴的中间，交叉轴的结束点，则给容器设置一下属性：12345.box&#123; display:flex; justify-content:center; align-items:flex-end;&#125; 容器包含多个项目的布局方式参照http://www.techug.com/post/flex-examples.html]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[d3.js学习笔记（五） — 布局]]></title>
    <url>%2Fpost%2Fd3.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接上篇。 打包图d3.layout.pack()打包图用于表示包含与被包含的关系，也可表示各对象的权重，通常用一圆套一圆来表示前者，用圆的大小来表示后者。 数据格式与集群图一样为一个json对象。 demo及分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var width = 500,height = 500; var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;).attr(&#123;&quot;width&quot;:width,&quot;height&quot;:height&#125;).append(&quot;g&quot;).attr(&quot;transform&quot;,&quot;translate(0,0)&quot;); //数据及数据转换 //打包图布局，限定范围，最小圆的半径 var pack = d3.layout.pack() .size([width,height]) .radius(30); d3.json(&quot;city.json&quot;,function(error,data)&#123; var nodes = pack.nodes(data); var links = pack.links(nodes); console.log(nodes); console.log(links); svg.selectAll(&quot;circle&quot;) .data(nodes) .enter() .append(&quot;circle&quot;) .attr(&#123;&quot;fill&quot;:&quot;blue&quot;,&quot;fill-opacity&quot;:&quot;0.4&quot;&#125;) //设定每个元素所在圆的圆心坐标、半径 .attr(&quot;cx&quot;,function(d)&#123; return d.x; &#125;) .attr(&quot;cy&quot;,function(d)&#123; return d.y; &#125;) .attr(&quot;r&quot;,function(d)&#123; return d.r; &#125;) //鼠标hover事件 .on(&quot;mouseover&quot;,function(d,i)&#123; d3.select(this) .attr(&quot;fill&quot;,&quot;yellow&quot;); &#125;) .on(&quot;mouseout&quot;,function(d,i)&#123; d3.select(this) .attr(&quot;fill&quot;,&quot;rgb(31, 119, 180)&quot;); &#125;); //文字 x、y、dx、dy – 文本 x，y 坐标、x 、y轴方向的文本平移量 svg.selectAll(&quot;text&quot;) .data(nodes) .enter() .append(&quot;text&quot;) .attr(&quot;font-size&quot;,&quot;10px&quot;) .attr(&quot;fill&quot;,&quot;white&quot;) .attr(&quot;fill-opacity&quot;,function(d)&#123; if(d.depth == 2) return &quot;0.9&quot;; else return &quot;0&quot;; &#125;) .attr(&quot;x&quot;,function(d)&#123; return d.x; &#125;) .attr(&quot;y&quot;,function(d)&#123; return d.y; &#125;) .attr(&quot;dx&quot;,-12) .attr(&quot;dy&quot;,1) .text(function(d)&#123; return d.name; &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 以上很多方法在集群图已做详细分析，不再赘述。 地图的制作 数据格式将 JSON 的格式应用于地理上的文件，叫做 GeoJSON 文件。GeoJSON 文件中的地图数据，都是经度和纬度的信息。它们都是三维的。制作GeoJSON文件很复杂。网上有传送门，将一些常用的地图数据整理好。 世界地图和主要国家 中国省市级 中国县级demo及分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;中国地图&lt;/title&gt; &lt;/head&gt;&lt;style&gt;&lt;/style&gt;&lt;body&gt;&lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //创建画布 var width = 1000,height = 1000; var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;).attr(&#123;&quot;width&quot;:width,&quot;height&quot;:height&#125;).append(&quot;g&quot;).attr(&quot;transform&quot;,&quot;translate(0,0)&quot;); //由于GeoJSON文件返回的经纬度是三维，网页是二维的。 //所以要使用 d3.geo.mercator() 的投影方式，设定一个投影函数来转换经度纬度。 var projection = d3.geo.mercator() //center() 设定地图的中心位置，[104,29] 指的是经度和纬度。 //中国的经纬度范围大约为：经度73.66~135.05，纬度3.86~53.55 .center([104, 29]) //scale() 设定放大的比例。自己调整合适比例 .scale(600) //translate() 设定平移 居中显示 .translate([width/2, height/2]); //地理路径生成器d3.geo.path() var path = d3.geo.path() //projection() 是设定生成器的投影函数 .projection(projection); var color = d3.scale.category20(); d3.json(&quot;china.geojson&quot;, function(error, data) &#123; if (error) return console.error(error); console.log(data.features); svg.selectAll(&quot;path&quot;) .data( data.features ) .enter() .append(&quot;path&quot;) .attr(&quot;stroke&quot;,&quot;#000&quot;) .attr(&quot;stroke-width&quot;,1) .attr(&quot;fill&quot;, function(d,i)&#123; return color(i); &#125;) .attr(&quot;d&quot;, path ) .on(&quot;mouseover&quot;,function(d,i)&#123; d3.select(this) .attr(&quot;fill&quot;,&quot;yellow&quot;); &#125;) .on(&quot;mouseout&quot;,function(d,i)&#123; d3.select(this) .attr(&quot;fill&quot;,color(i)); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; d3.js 系列学习笔记完。 全部demo上传至GitHub地址 今后在工作中踩坑后再开篇总结。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>D3</tag>
        <tag>JS</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[d3.js学习笔记（四） — 布局]]></title>
    <url>%2Fpost%2Fd3.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接上篇d3布局。上次提到了比较常用的饼状图和力导向图。今天得空记录下集群图、树状图。 集群图d3.layout.cluster()集群图主要用来表示种用于表示包含与被包含关系的图表；类似于列举大纲。上篇布局曾说过所有d3布局都可以有三步走，数据以及d3特殊的数据转化 → 图形生成器生成图形 → 向图形界面添加图形元素。 今天介绍的几种图形绘制也不例外。 数据格式123456789101112131415161718192021222324252627&#123;&quot;name&quot;:&quot;第一级&quot;,&quot;children&quot;:[ &#123; &quot;name&quot;:&quot;第二级&quot; , &quot;children&quot;: [ &#123;&quot;name&quot;:&quot;第三级&quot; &#125;, &#123;&quot;name&quot;:&quot;第三级&quot; &#125;, &#123;&quot;name&quot;:&quot;第三级&quot; &#125;, &#123;&quot;name&quot;:&quot;第三级&quot; &#125; ] &#125;, &#123; &quot;name&quot;:&quot;第二级&quot; , &quot;children&quot;: [ &#123;&quot;name&quot;:&quot;第三级&quot; &#125;, &#123;&quot;name&quot;:&quot;第三级&quot; &#125;, &#123;&quot;name&quot;:&quot;第三级&quot; &#125;, &#123;&quot;name&quot;:&quot;第三级&quot; &#125; ] &#125;]&#125; demo及分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;集群图&lt;/title&gt; &lt;style&gt; .node circle &#123; fill: #fff; stroke: steelblue; stroke-width: 1.5px; &#125; .node &#123; font: 12px sans-serif; &#125; .link &#123; fill: none; stroke: #ccc; stroke-width: 1.5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1------定义画布 var width = 500,height = 500; var svg = d3.select(&quot;body&quot;).append(&apos;svg&apos;).attr(&#123;&quot;width&quot;:width,&quot;height&quot;:height&#125;) //若第一级节点没有超出画布外，则没有必要； .append(&quot;g&quot;).attr(&quot;transform&quot;, &quot;translate(40,0)&quot;); //3-----定义图形生成器 //d3.svg.diagonal()是一个对角线生成器，只需要输入两个顶点坐标，即可生成一条贝塞尔曲线。 //projection() 是一个点变换器 var diagonal = d3.svg.diagonal().projection(function(d) &#123; return [d.y, d.x]; &#125;); //2-----数据及数据转换 //布局保存在变量 cluster 中，变量 cluster 可用于转换数据 //size() 设定范围 var cluster = d3.layout.cluster().size([width-100,height - 100]); //转换数据 d3.json(&quot;city.json&quot;,function(error,data)&#123; var nodes = cluster.nodes(data); var links = cluster.links(nodes); //本地文件只有Firefox能读取，用其打开才有效果 //与其他图形相似，集群图有节点以及连线；连线又分为起点，连接点 console.log(nodes); //顶点（节点） 所有数据个数 console.log(links); //连线 = source + target 线的条数 //3-----生成图形 //连线 var link = svg.selectAll(&quot;.link&quot;) .data(links) .enter() .append(&quot;path&quot;) .attr(&quot;class&quot;, &quot;link&quot;) .attr(&quot;d&quot;, diagonal); //节点画圆 var node = svg.selectAll(&quot;.node&quot;) .data(nodes) .enter() .append(&quot;g&quot;) .attr(&quot;class&quot;, &quot;node&quot;) .attr(&quot;transform&quot;, function(d) &#123; return &quot;translate(&quot; + d.y + &quot;,&quot; + d.x + &quot;)&quot;; &#125;) node.append(&quot;circle&quot;).attr(&quot;r&quot;, 4.5); //填文字 node.append(&quot;text&quot;) .attr(&quot;dx&quot;, function(d) &#123; return d.children ? -8 : 8; &#125;) .attr(&quot;dy&quot;, 3) .style(&quot;text-anchor&quot;, function(d) &#123; return d.children ? &quot;end&quot; : &quot;start&quot;; &#125;) .text(function(d) &#123; return d.name; &#125;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; city.json内容city.json文件在之后的几种图形中都会调用到，复制以下内容即可。注意放在本地的数据只有Firefox可以打开，其他浏览器会报错。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; &quot;name&quot;:&quot;中国&quot;, &quot;children&quot;: [ &#123; &quot;name&quot;:&quot;浙江&quot; , &quot;children&quot;: [ &#123;&quot;name&quot;:&quot;杭州&quot; &#125;, &#123;&quot;name&quot;:&quot;宁波&quot; &#125;, &#123;&quot;name&quot;:&quot;温州&quot; &#125;, &#123;&quot;name&quot;:&quot;绍兴&quot; &#125; ] &#125;, &#123; &quot;name&quot;:&quot;广西&quot; , &quot;children&quot;: [ &#123;&quot;name&quot;:&quot;桂林&quot;&#125;, &#123;&quot;name&quot;:&quot;南宁&quot;&#125;, &#123;&quot;name&quot;:&quot;柳州&quot;&#125;, &#123;&quot;name&quot;:&quot;防城港&quot;&#125; ] &#125;, &#123; &quot;name&quot;:&quot;黑龙江&quot;, &quot;children&quot;: [ &#123;&quot;name&quot;:&quot;哈尔滨&quot;&#125;, &#123;&quot;name&quot;:&quot;齐齐哈尔&quot;&#125;, &#123;&quot;name&quot;:&quot;牡丹江&quot;&#125;, &#123;&quot;name&quot;:&quot;大庆&quot;&#125; ] &#125;, &#123; &quot;name&quot;:&quot;新疆&quot; , &quot;children&quot;: [ &#123;&quot;name&quot;:&quot;乌鲁木齐&quot;&#125;, &#123;&quot;name&quot;:&quot;克拉玛依&quot;&#125;, &#123;&quot;name&quot;:&quot;吐鲁番&quot;&#125;, &#123;&quot;name&quot;:&quot;哈密&quot;&#125; ] &#125; ]&#125; 总结 d3布局都可以有三步走，数据以及d3特殊的数据转化 → 图形生成器生成图形 → 向图形界面添加图形元素 d3.svg.diagonal()是一个对角线生成器，只需要输入两个顶点坐标，即可生成一条贝塞尔曲线。 d3.layout.cluster()集群图生成器、用于数据转换绘制图形等。 所有用于表示两者数据关联【包含、联系等】的图表都会有节点nodes、连线links；连线有理所当然的包含起点source、被连接点target. 树状图d3.layout.tree()所有方法和集群图都一致。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>D3</tag>
        <tag>JS</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[d3.js学习笔记（三） — 布局]]></title>
    <url>%2Fpost%2Fd3.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[从第三部分起将学习到d3的核心部分——layout，D3总共提供了12种布局方式：饼状图（Pie）、力导向图（Force）、弦图（Chord）、集群图（Cluster）、树状图（Tree）、打包图（Pack）、捆图（Bundle）、堆栈图（Stack）、矩阵树图（Treemap）、直方图（Histogram）、分区图（Partition）、层级图（Hierarchy）。 所有的布局图形基本上都是三步走：数据及数据转化、图形生成、添加图形元素。 饼状图d3.layout.pie() 数据格式数组： var dataset = [55,33,44,46,57,25]; demo及分析1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;饼图&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;//1------创建画布var width = 555,height = 555;var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;).attr(&#123;&quot;width&quot;:width,&quot;height&quot;:height&#125;);//2------数据及数据转化var dataset = [55,33,44,46,57,25];//定义pie，得到piedatavar pie = d3.layout.pie();var piedata = pie(dataset);//5 个整数被转换成了 5 个对象（Object） ，每个对象都有变量起始角度（startAngle）和终止角度（endAngle），还有原数据（属性名称为 data）console.log(piedata);//3------图形生成器var outerRadius = 150;var innerRadius = 0;//color 是一个颜色比例尺，它能根据传入的索引号获取相应的颜色值；也可以自定义一个数组添加自己想要的颜色var color = d3.scale.category10();var arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);//4------添加图形元素var arcs = svg.selectAll(&quot;g&quot;).data(piedata).enter().append(&quot;g&quot;).attr(&quot;transform&quot;,&quot;translate(&quot;+ (width/2) +&quot;,&quot;+ (width/2) +&quot;)&quot;);arcs.append(&quot;path&quot;).attr(&quot;fill&quot;,function(d,i)&#123;return color(i)&#125;).attr(&quot;d&quot;,function(d)&#123;return arc(d)&#125;).on(&quot;mouseover&quot;,function(d)&#123;console.log(d.data)&#125;);//调用弧生成器，得到路径值//添加文字//arc.centroid(d) 能算出弧线的中心 ，text() 里返回的是 d.data ，而不是 d 。因为被绑定的数据是对象，里面有 d.startAngle、d.endAngle、d.data 等，其中 d.data 才是转换前的整数的值arcs.append(&quot;text&quot;).attr(&quot;transform&quot;,function(d)&#123;return &quot;translate(&quot; + arc.centroid(d) + &quot;)&quot;;&#125;).attr(&quot;text-anchor&quot;,&quot;middle&quot;).text(function(d)&#123;return d.data;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结 d3布局都可以有三步走，数据以及d3特殊的数据转化 → 图形生成器生成图形 → 向图形界面添加图形元素 d3.layout.pie() 饼图生成器、用于数据转换绘制图形等。 d3.scale.category10() 是一个颜色比例尺，它能根据传入的索引号获取相应的颜色值；也可以自定义一个数组添加自己想要的颜色 arc.centroid(d) 能算出弧线的中心 力导向图d3.layout.force() 数据格式两个数组，一个存放节点，另一个申明节点之间的关系；小球和线之间连接关系是靠以下数组关联。source为连接体，target为被连接的对象 数字为在nodes下的索引值var nodes = [ { name: “桂林” }, { name: “广州” }, { name: “厦门” }, { name: “杭州” }, { name: “上海” }, { name: “青岛” }, { name: “天津” } ]; var edges = [ { source : 0 , target: 1 } , { source : 0 , target: 2 } , { source : 0 , target: 3 } , { source : 1 , target: 4 } , { source : 1 , target: 5 } , { source : 1 , target: 6 } ]; demo及分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;力导向图&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;//1------创建画布var width = 555,height = 555;var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;).attr(&#123;&quot;width&quot;:width,&quot;height&quot;:height&#125;);//颜色var color = d3.scale.category20();//2------数据及转换数据var nodes = [ &#123; name: &quot;桂林&quot; &#125;, &#123; name: &quot;广州&quot; &#125;, &#123; name: &quot;厦门&quot; &#125;, &#123; name: &quot;杭州&quot; &#125;, &#123; name: &quot;上海&quot; &#125;, &#123; name: &quot;青岛&quot; &#125;, &#123; name: &quot;天津&quot; &#125; ];var links = [ &#123; source : 0 , target: 1 &#125; , &#123; source : 0 , target: 2 &#125; , &#123; source : 0 , target: 3 &#125; , &#123; source : 1 , target: 4 &#125; , &#123; source : 1 , target: 5 &#125; , &#123; source : 1 , target: 6 &#125; ];//转换数据var force = d3.layout.force() .nodes(nodes) //节点数组 .links(links) //连线 .size([width,height]) //作用域范围 .linkDistance(150) //连线长度 .charge([-400]); //相互之间的作用力//3------图形生成force.start(); //开始作用console.log(nodes);console.log(links);//4------添加图形元素//添加连线var svg_links = svg.selectAll(&quot;line&quot;).data(links).enter().append(&quot;line&quot;).style(&quot;stroke&quot;,&quot;#ccc&quot;).style(&quot;stroke-width&quot;,1);//添加小圆var svg_nodes = svg.selectAll(&quot;circle&quot;).data(nodes).enter().append(&quot;circle&quot;).attr(&quot;r&quot;,20).style(&quot;fill&quot;,function(d,i)&#123;return color(i)&#125;).call(force.drag);//文字var svg_texts = svg.selectAll(&quot;text&quot;).data(nodes).enter().append(&quot;text&quot;).style(&quot;fill&quot;,&quot;black&quot;).attr(&quot;dx&quot;, 20).attr(&quot;dy&quot;, 8).text(function(d)&#123;return d.name&#125;);//不断更新节点和连线的位置force.on(&quot;tick&quot;, function()&#123; //对于每一个时间间隔 //更新连线坐标 svg_links.attr(&quot;x1&quot;,function(d)&#123; return d.source.x; &#125;) .attr(&quot;y1&quot;,function(d)&#123; return d.source.y; &#125;) .attr(&quot;x2&quot;,function(d)&#123; return d.target.x; &#125;) .attr(&quot;y2&quot;,function(d)&#123; return d.target.y; &#125;); //更新节点坐标 svg_nodes.attr(&quot;cx&quot;,function(d)&#123; return d.x; &#125;) .attr(&quot;cy&quot;,function(d)&#123; return d.y; &#125;); //更新文字坐标 svg_texts.attr(&quot;x&quot;, function(d)&#123; return d.x; &#125;) .attr(&quot;y&quot;, function(d)&#123; return d.y; &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结 d3布局都可以有三步走，数据以及d3特殊的数据转化 → 图形生成器生成图形 → 向图形界面添加图形元素 d3.layout.force() 力导向图生成器、用于数据转换绘制图形等。 d3.scale.category20() 是一个颜色比例尺，它能根据传入的索引号获取相应的颜色值；也可以自定义一个数组添加自己想要的颜色 所有用于表示两者数据关联【包含、联系等】的图表都会有节点nodes、连线links；连线有理所当然的包含起点source、被连接点target.]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>D3</tag>
        <tag>JS</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[d3.js学习笔记（二） — 交互效果]]></title>
    <url>%2Fpost%2Fd3.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接上篇静态展示数据是无法体现d3的强大之处的，今天学习了d3的一些动画和事件交互方面，很强大、 d3的动画效果d3动画和CSS3动画类似，d3提供一下四种方法，将图形从一种状态变为另一种状态。 transition() 启动过渡 duration() 过渡持续时间，ms为单位 ease() 过渡方式 inear：普通的线性变化 circle：慢慢地到达变换的最终状态 elastic：带有弹跳的到达最终状态 bounce：在最终状态处弹跳几次 delay() 延迟动画，ms为单位123//起始状态 圆心在[50px,50px].半径为50的红色小圆 var circle = svg.append(&quot;circle&quot;).attr(&quot;cx&quot;,50).attr(&quot;cy&quot;,400).attr(&quot;r&quot;,50).attr(&quot;fill&quot;,&quot;red&quot;); circle.transition().duration(3000).delay(50).ease(&quot;bounce&quot;).attr(&quot;cx&quot;,400).attr(&quot;r&quot;,100).attr(&quot;fill&quot;,&quot;yellow&quot;); 以上cx、cy、r等是svg圆形形状的属性，更多svg形状属性戳这里 d3事件绑定和在jQuery中相同，d3为选择集绑定事件用到on()函数，常见事件有click、dblclick、mouseover、mouseout、mousemove、mousedown、mouseup、keydown、keyup、keypress、touchstart、touchend、touchmove12//为上述例子中圆形绑定事件circle.on(&quot;click&quot;,function()&#123;&#125;); update()、enter()和exit()区别简单来说，三种方法用于数组和选择集对应关系。 update() 绑定数据数量个数 = 选择集刚好对应的部分 更新属性值 enter() 绑定数据数量个数 &gt; 选择集刚好对应的部分 通常后面接append()添加元素后，赋予属性值 exit() 绑定数据数量个数 &lt; 选择集刚好对应的部分 remove()删除元素后，赋予属性值]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>D3</tag>
        <tag>JS</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[d3.js学习笔记（一） — 选择集及数据操作]]></title>
    <url>%2Fpost%2Fd3.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面h5中新增了canvas，很强大。d3可canvas以及ECharts有点类似，都需要使用js描绘统计数据。老大说需要用到这个，之后将会记录一系列学习笔记和有用资源，供自己查阅。 分割线、言归正传 D3.js是被数据驱动文档的js库，能将数据使用HTML和CSS，SVG。D3强调Web标准支持现代浏览器的全部功能，无需自己绑到一个专有的框架，结合功能强大的可视化组件和DOM操作一个数据驱动的方法。以上摘自d3.js官网，D3即Data-Driven Documents数据驱动文档，主要表现为图形化界面，可视化界面。 D3全部API以上图片来源网络 推荐学习网站：数据可视化专题站里面有很多干货。 操作元素PS:D3和jQuery一样，直接用script标签引入d3.js库就可以开始操作了。D3采用的是链式写法，为了代码的可读性，可以分行写。 选中元素：select()/selectAll()D3在选择dom节点时和jQuery类似，根据相同类名选中同类元素，根据id选中特殊元素，根据元素属性(“[color=red]”)选中…123456789101112131415&lt;p&gt;the first paragraphs!&lt;/p&gt;&lt;p class=&quot;test&quot;&gt;the second paragraphs!&lt;/p&gt;&lt;p class=&quot;test&quot;&gt;&lt;/p&gt;//改动所有p元素的内容d3.select(&quot;body&quot;) .selectAll(&quot;p&quot;) .text(&quot;we are both the paragraph element~&quot;);//改动class为test的p元素的内容和样式 select(&quot;body&quot;)也可省略var p = d3.selectAll(&quot;.test&quot;) .text(&quot;we have the attribute &apos;test&apos;~&quot;); .style(&quot;color&quot;,&quot;red&quot;) .style(&quot;font-size&quot;,&quot;30px&quot;);//或者 .style(&#123;&quot;color&quot;:&quot;red&quot;,&quot;font-size&quot;:&quot;30px&quot;&#125;) 总结： d3.select()：是选择所有指定元素的第一个 d3.selectAll()：是选择指定元素的全部以上两个函数返回的结果称为选择集 d3.text();改变元素内容 d3.style();元素内联样式 插入元素：insert()/append()append() 在选择集末尾结束标签追加；insert() 在选择集前面追加。123456789101112131415&lt;div&gt; &lt;p class=&quot;add&quot;&gt;111&lt;/p&gt; &lt;p class=&quot;add&quot; id=&quot;test&quot;&gt;222&lt;/p&gt; &lt;p id=&quot;del&quot;&gt;333&lt;/p&gt;&lt;/div&gt;//insert 在 div【被插入元素的直属父类，不能是body】 中 id 为 test 的元素前添加一个段落元素var box = d3.select(&quot;div&quot;).insert(&quot;p&quot;,&quot;#test&quot;) .text(&quot;insert p element&quot;); → 输出：111、insert p element、222、333//append 在选中元素结束标签最后添加var box1 = d3.select(&quot;div&quot;).append(&quot;p&quot;) .text(&quot;apend element&quot;); → 输出：111、insert p element、222、333、apend element以上box，box1是选中的被插入的元素，很容易被认为选中的是div而讲所有操作全都写成链式，【易错】。 删除元素：remove()123//直接选中被删除的元素，再执行remove()方法var del = d3.select(&quot;#del&quot;);del.remove(); → 输出：111、insert p element、222、apend element 绑定数据:D3通过以下两个函数来绑定数据： datum()：绑定一个数据到选择集上 data()：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定【常用】12345678910111213141516&lt;p&gt;111&lt;/p&gt;&lt;p&gt;222&lt;/p&gt;&lt;p&gt;333&lt;/p&gt;//绑定数据的过程为：定义/获取数据 → 选中元素 → 将数据绑定到元素。var arr = [&quot;blue&quot;,&quot;yellow&quot;,&quot;red&quot;];var oDiv = d3.selectAll(&quot;p&quot;);oDiv.data(arr);/* text()可以返回一个无名函数 function(d, i)&#123;&#125; d 代表数据，也就是与某元素绑定的数据。 i 代表索引，代表数据的索引号，从 0 开始。*/oDiv.text(function(d,i)&#123; return d&#125;) 关于svg要是用d3实现图形化数据必然要使用到画布，HTML5中提供了svg和canvas两种画布，关于两者的区别。后面HTML5相关文章总结。D3 提供许多生成器中只支持 SVG ，因此，选择 SVG 画布。SVG 画布的预定义元素里，有六种基本图形：rect、circle、ellipse（椭圆）、line、polyline（折线）、polygon（多边形）+ 一种特殊且最强元素 path（路径）。画布中的所有图形，都是由以上七种元素组成。 123456//创建svg画布：定义宽高 → 添加svg元素 → 将宽高赋值给svgvar width = 300,height = 300;var svg = d3.select(&quot;body&quot;) .append(&quot;svg&quot;) .attr(&quot;width&quot;, width) .attr(&quot;height&quot;, height); 比例尺实际数据中可能和画布大小相比特别大或者特别小，若将真是的数据绑定给对应的元素，可能最小的数据无法显示，最大的数据也无法看不见。引入比例尺可以是数据在画布大小内等比例分布显示，大小关系不变。 线性比例尺（linear）线性比例尺可以理解成为一元二次函数：y = kx + b. x为定义域domain，y为值域range。d3.scale.linear() 返回一个线性比例尺且有返回值可以调用，domain() 和 range() 分别设定比例尺的定义域和值域。d3.max()，d3.min() 返回最大最小值 12345678910111213//将 dataset 中最小的值，映射成 0；将最大的值，映射成 300。var dataset = [1.2, 2.3, 0.9, 1.5, 3.3];var min = d3.min(dataset);var max = d3.max(dataset);var linear = d3.scale.linear() .domain([min, max]) .range([0, 300]);linear(0.9); //返回 0linear(3.3); //返回 300//可求得函数式为 y=125x-112.5;故：linear(2.3); //返回 175 序数比例尺（ordinal）d3.scale.ordinal() 返回一个序数比例尺且有返回值可以调用可以理解为没有函数式可以将定义域和值域关联起来的比例尺，如下：123456789var index = [0, 1, 2, 3, 4];var color = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;black&quot;];var ordinal = d3.scale.ordinal() .domain(index) .range(color);ordinal(0); //返回 redordinal(2); //返回 greenordinal(4); //返回 black 区别： 线性比例尺的domain和range可以用一个函数式将其关联起来，序数比例尺没有 线性比例尺的domain和range必须传入两个值，是一个范围。 坐标轴坐标轴如果让我们一点一点去画的话，它是由一根坐标轴线、n个刻度线和n个数字组成，若刻度很多的情况下，很复杂。d3中未坐标轴定义了一个组件d3.svg.axis()显示坐标轴。坐标轴和比例尺通常一起使用。 定义1var axis = d3.svg.axis().scale(&quot;linear&quot;).orient(&quot;bottom&quot;).ticks(data.length + 2); 一个坐标轴要指定scale(“linear/ordinal”)比例尺、orient(“bottom/left/top/right”)、ticks(data.length + 2)刻度个数，通常为数据个数+2. 使用 分组元素 ，是 SVG 画布中的元素，意思是 group。此元素是将其他元素进行组合的容器，在这里是用于将坐标轴的其他元素分组存放。 在 D3 中，call() 的参数是一个函数。可以讲函数名作为参数，再调用该函数的返回值。首先要添加一个g元素，在用call()调用axis组件： 12svg.append(&quot;g&quot;).call(axis);相当于 axis(svg.append(&quot;g&quot;)) 推荐使用第一种 为坐标轴添加样式 12345678910111213141516&lt;!-- 在样式里定义 --&gt;&lt;style&gt; .axis path, .axis line&#123; fill: none; stroke: red; shape-rendering: crispEdges; &#125; .axis text &#123; font-family: sans-serif; font-size: 11px; &#125;&lt;/style&gt;//将class类名加给axis并设置具体起点坐标，用translate()表示svg.append(&quot;g&quot;).attr(&quot;class&quot;,&quot;axis&quot;).attr(&quot;transform&quot;,&quot;translate(0,200)&quot;).call(axis); 综合小例子 - 画一个柱状图在 SVG 中，原点在左上角柱形图均为矩形构成，雇佣rect元素。矩形元素有四个：左上角x,y轴坐标（原点坐标）、矩形宽高123456789101112131415161718192021//创建svg画布var width = 555,height = 555;var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;).attr(&quot;width&quot;,width).attr(&quot;height&quot;,height);//设置比例尺var dataset = [ 2.5 , 2.1 , 1.7 , 1.3 , 0.9 ];var linear = d3.scale.linear().domain([0,d3.max(dataset)]).range([0,width]);//创建矩形var rectHeight = 40;//此处是选中所有rect元素，selectAll();svg.selectAll(&quot;rect&quot;).data(dataset).enter().append(&quot;rect&quot;) //设置矩形原点，由于是横向柱状图，故x均为0，y为 每个矩形的索引值 * rectHeight .attr(&quot;x&quot;,0).attr(&quot;y&quot;,function(d,i)&#123;return rectHeight*i&#125;) //宽度为定义的数据集 在此处使用线性比例尺的返回值；高度减去一个常数为矩形之间的间距 .attr(&quot;width&quot;,function(d)&#123;return linear(d)&#125;).attr(&quot;height&quot;,rectHeight - 5).attr(&quot;fill&quot;,&quot;pink&quot;);//创建坐标轴var axis = d3.svg.axis().scale(linear).orient(&quot;bottom&quot;).ticks(dataset.length + 2);//此处是append(&quot;g&quot;);svg.append(&quot;g&quot;).attr(&quot;class&quot;,&quot;axis&quot;).attr(&quot;transform&quot;,&quot;translate(0,220)&quot;).call(axis); 注意：以上例子中，添加与 dataset 数组的长度相同数量的矩形时使用一下语句：【牢记】1234svg.selectAll(&quot;rect&quot;) //选择svg内所有的矩形 .data(dataset) //绑定数组 .enter() //指定选择集的enter部分 .append(&quot;rect&quot;) //添加足够数量的矩形元素]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>D3</tag>
        <tag>JS</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传和Excel解析]]></title>
    <url>%2Fpost%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8CExcel%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[文件上传的技术有很多，最近在做一键上传Excel省市级功能发现OCUpload很好用，借以此篇总结。 一、一键上传1.1、原理分析：一键上传在页面中会有一个隐藏的form表单和iframe，和一个页面可见按钮，当点击该按钮是触发表单提交，表单提交本来是异步的，需要跳转页面，但将表单提交到隐藏iframe中后，相当于本页面没有刷新1234567891011121314151617181920&lt;button type=&quot;button&quot; id=&quot;btn&quot;&gt;一键上传&lt;/button&gt;&lt;form action=&quot;xxx.action&quot; type=&quot;post&quot; enctype=&quot;multipart/form-data&quot; target=&quot;myframe&quot; id=&quot;testForm&quot; style=&quot;display: none&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; id=&quot;submitBtn&quot; onclick=&quot;submitFrom()&quot;/&gt;&lt;/form&gt;&lt;%--表单提交到iframe中--%&gt;&lt;iframe name=&quot;myframe&quot; frameborder=&quot;0&quot; style=&quot;display: none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; function submitFrom()&#123; // 异步提交本来要跳转连接，但是因为提交到了隐藏的iframe中，页面看着感觉没有发生跳转 $(&quot;#testForm&quot;).submit(); &#125; $(function () &#123; // 点击页面可见的按钮 触发表单提交 $(&quot;#btn&quot;).click(function () &#123; $(&quot;#submitBtn&quot;).trigger(&apos;click&apos;); &#125;) &#125;)&lt;/script&gt; 1.2、Jquery OCUploadocupload插件已经将一切封装好了，我们只需要引入jquery.ocupload-x.x.x.js，对页面中的一个按钮绑定事件，配置下列属性，即可实现一键上传操作： 12345678910111213141516171819202122232425262728293031$(function () &#123; $(&quot;#uploadfile&quot;).upload(&#123; action: &apos;要提交的controller路径&apos;, name: &apos;file&apos;, //文件上传input属性的默认值 enctype:&quot;multipart/form-data&quot;, params: &#123; &#125;, // 需要提交到controller的其他参数 // 选择文件后触发的事件 // 如果想实现控制文件的类型: 需要关闭自动提交，判断文件类型、再手动提交 onSelect: function (self, element) &#123; this.autoSubmit = false; var filename = this.filename(); //声明正则 .*名字任意 \. 转义 var reg = /^.*\.(xls|xlsx)$/; if(reg.test(filename))&#123; this.submit(); &#125;else&#123; alert(&apos;请上传以xls或xlsx结尾文件！&apos;); &#125; &#125;, // 触发文件提交事件 onSubmit: function (self, element) &#123; &#125;, // 文件上传完成后 onComplete: function (data, self, element) &#123; &#125; &#125;); &#125;); 1.3、Struts提供的文件上传功能二、POI解析Excle表格Apache POI是Apache组织的开源的函式库，提供API给Java程序对 Office格式档案读和写的功能。由于Excel在07年之前的后缀名为.xls，07年之后后缀名为.xlsx，所以解析两者的对象也不同，分别为HSSF和XSSF 2.1、入门1、导入POI maven坐标 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; 2、POI EXCEL文档结构类： HSSFWorkbook 文档工作簿 HSSFSheet 文档的每个Sheet HSSFCell 每个单元格 HSSFHeader sheet HSSFFooter sheet… 3、解析思路：先获取WorkBook工作簿对象 - 获取Sheet对象，并遍历每个Sheet - 获取每个Sheet下的行数(排除行首) - 获取每个单元格 4、工具类：网上相关工具类有很多，下面这个两种格式的都可以上传 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.leahshi.utils;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import org.apache.log4j.Logger;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import org.springframework.web.multipart.MultipartFile;public class POIUtils &#123; private static Logger logger = Logger.getLogger(POIUtils.class); private final static String xls = &quot;xls&quot;; private final static String xlsx = &quot;xlsx&quot;; /** * 读入excel文件，解析后返回 * * @param file * @throws IOException */ public static List&lt;String[]&gt; readExcel(MultipartFile file) throws IOException &#123; // 检查文件 checkFile(file); // 获得Workbook工作薄对象 Workbook workbook = getWorkBook(file); // 创建返回对象，把每行中的值作为一个数组，所有行作为一个集合返回 List&lt;String[]&gt; list = new ArrayList&lt;String[]&gt;(); if (workbook != null) &#123; for (int sheetNum = 0; sheetNum &lt; workbook.getNumberOfSheets(); sheetNum++) &#123; // 获得当前sheet工作表 Sheet sheet = workbook.getSheetAt(sheetNum); if (sheet == null) &#123; continue; &#125; // 获得当前sheet的开始行 int firstRowNum = sheet.getFirstRowNum(); // 获得当前sheet的结束行 int lastRowNum = sheet.getLastRowNum(); // 循环除了第一行的所有行 for (int rowNum = firstRowNum + 1; rowNum &lt;= lastRowNum; rowNum++) &#123; // 获得当前行 Row row = sheet.getRow(rowNum); if (row == null) &#123; continue; &#125; // 获得当前行的开始列 int firstCellNum = row.getFirstCellNum(); // 获得当前行的列数 int lastCellNum = row.getPhysicalNumberOfCells(); String[] cells = new String[row.getPhysicalNumberOfCells()]; // 循环当前行 for (int cellNum = firstCellNum; cellNum &lt; lastCellNum; cellNum++) &#123; Cell cell = row.getCell(cellNum); cells[cellNum] = getCellValue(cell); &#125; list.add(cells); &#125; &#125; // workbook.close(); &#125; return list; &#125; public static void checkFile(MultipartFile file) throws IOException &#123; // 判断文件是否存在 if (null == file) &#123; logger.error(&quot;文件不存在！&quot;); throw new FileNotFoundException(&quot;文件不存在！&quot;); &#125; // 获得文件名 String fileName = file.getOriginalFilename(); // 判断文件是否是excel文件 if (!fileName.endsWith(xls) &amp;&amp; !fileName.endsWith(xlsx)) &#123; logger.error(fileName + &quot;不是excel文件&quot;); throw new IOException(fileName + &quot;不是excel文件&quot;); &#125; &#125; public static Workbook getWorkBook(MultipartFile file) &#123; // 获得文件名 String fileName = file.getOriginalFilename(); // 创建Workbook工作薄对象，表示整个excel Workbook workbook = null; try &#123; // 获取excel文件的io流 InputStream is = file.getInputStream(); // 根据文件后缀名不同(xls和xlsx)获得不同的Workbook实现类对象 if (fileName.endsWith(xls)) &#123; // 2003 workbook = new HSSFWorkbook(is); &#125; else if (fileName.endsWith(xlsx)) &#123; // 2007 及2007以上 workbook = new XSSFWorkbook(is); &#125; &#125; catch (IOException e) &#123; logger.info(e.getMessage()); &#125; return workbook; &#125; public static String getCellValue(Cell cell) &#123; String cellValue = &quot;&quot;; if (cell == null) &#123; return cellValue; &#125; // 把数字当成String来读，避免出现1读成1.0的情况 if (cell.getCellType() == Cell.CELL_TYPE_NUMERIC) &#123; cell.setCellType(Cell.CELL_TYPE_STRING); &#125; // 判断数据的类型 switch (cell.getCellType()) &#123; case Cell.CELL_TYPE_NUMERIC: // 数字 cellValue = String.valueOf(cell.getNumericCellValue()); break; case Cell.CELL_TYPE_STRING: // 字符串 cellValue = String.valueOf(cell.getStringCellValue()); break; case Cell.CELL_TYPE_BOOLEAN: // Boolean cellValue = String.valueOf(cell.getBooleanCellValue()); break; case Cell.CELL_TYPE_FORMULA: // 公式 cellValue = String.valueOf(cell.getCellFormula()); break; case Cell.CELL_TYPE_BLANK: // 空值 cellValue = &quot;&quot;; break; case Cell.CELL_TYPE_ERROR: // 故障 cellValue = &quot;非法字符&quot;; break; default: cellValue = &quot;未知类型&quot;; break; &#125; return cellValue; &#125;&#125; 三、使用PinYin4J生成城市简码因为导入省市级数据后，需要生成城市简码，比如省市区首字母，城市拼音等，需要使用到PinYin4J这个工具。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311package com.leahshi.utils;import java.util.Arrays;import net.sourceforge.pinyin4j.PinyinHelper;import net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;import net.sourceforge.pinyin4j.format.HanyuPinyinToneType;import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;public class PinYin4jUtils &#123; /** * 将字符串转换成拼音数组 * * @param src * @return */ public static String[] stringToPinyin(String src) &#123; return stringToPinyin(src, false, null); &#125; /** * 将字符串转换成拼音数组 * * @param src * @return */ public static String[] stringToPinyin(String src, String separator) &#123; return stringToPinyin(src, true, separator); &#125; /** * 将字符串转换成拼音数组 * * @param src * @param isPolyphone * 是否查出多音字的所有拼音 * @param separator * 多音字拼音之间的分隔符 * @return */ public static String[] stringToPinyin(String src, boolean isPolyphone, String separator) &#123; // 判断字符串是否为空 if (&quot;&quot;.equals(src) || null == src) &#123; return null; &#125; char[] srcChar = src.toCharArray(); int srcCount = srcChar.length; String[] srcStr = new String[srcCount]; for (int i = 0; i &lt; srcCount; i++) &#123; srcStr[i] = charToPinyin(srcChar[i], isPolyphone, separator); &#125; return srcStr; &#125; /** * 将单个字符转换成拼音 * * @param src * @return */ public static String charToPinyin(char src, boolean isPolyphone, String separator) &#123; // 创建汉语拼音处理类 HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat(); // 输出设置，大小写，音标方式 defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE); defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE); StringBuffer tempPinying = new StringBuffer(); // 如果是中文 if (src &gt; 128) &#123; try &#123; // 转换得出结果 String[] strs = PinyinHelper.toHanyuPinyinStringArray(src, defaultFormat); // 是否查出多音字，默认是查出多音字的第一个字符 if (isPolyphone &amp;&amp; null != separator) &#123; for (int i = 0; i &lt; strs.length; i++) &#123; tempPinying.append(strs[i]); if (strs.length != (i + 1)) &#123; // 多音字之间用特殊符号间隔起来 tempPinying.append(separator); &#125; &#125; &#125; else &#123; tempPinying.append(strs[0]); &#125; &#125; catch (BadHanyuPinyinOutputFormatCombination e) &#123; e.printStackTrace(); &#125; &#125; else &#123; tempPinying.append(src); &#125; return tempPinying.toString(); &#125; public static String hanziToPinyin(String hanzi) &#123; return hanziToPinyin(hanzi, &quot; &quot;); &#125; /** * 将汉字转换成拼音 * * @param hanzi * @param separator * @return */ public static String hanziToPinyin(String hanzi, String separator) &#123; // 创建汉语拼音处理类 HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat(); // 输出设置，大小写，音标方式 defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE); defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE); String pinyingStr = &quot;&quot;; try &#123; pinyingStr = PinyinHelper.toHanyuPinyinString(hanzi, defaultFormat, separator); &#125; catch (BadHanyuPinyinOutputFormatCombination e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return pinyingStr; &#125; /** * 将字符串数组转换成字符串 * * @param str * @param separator * 各个字符串之间的分隔符 * @return */ public static String stringArrayToString(String[] str, String separator) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; str.length; i++) &#123; sb.append(str[i]); if (str.length != (i + 1)) &#123; sb.append(separator); &#125; &#125; return sb.toString(); &#125; /** * 简单的将各个字符数组之间连接起来 * * @param str * @return */ public static String stringArrayToString(String[] str) &#123; return stringArrayToString(str, &quot;&quot;); &#125; /** * 将字符数组转换成字符串 * * @param str * @param separator * 各个字符串之间的分隔符 * @return */ public static String charArrayToString(char[] ch, String separator) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; ch.length; i++) &#123; sb.append(ch[i]); if (ch.length != (i + 1)) &#123; sb.append(separator); &#125; &#125; return sb.toString(); &#125; /** * 将字符数组转换成字符串 * * @param str * @return */ public static String charArrayToString(char[] ch) &#123; return charArrayToString(ch, &quot; &quot;); &#125; /** * 取汉字的首字母 * * @param src * @param isCapital * 是否是大写 * @return */ public static char[] getHeadByChar(char src, boolean isCapital) &#123; // 如果不是汉字直接返回 if (src &lt;= 128) &#123; return new char[] &#123; src &#125;; &#125; // 获取所有的拼音 String[] pinyingStr = PinyinHelper.toHanyuPinyinStringArray(src); // 创建返回对象 int polyphoneSize = pinyingStr.length; char[] headChars = new char[polyphoneSize]; int i = 0; // 截取首字符 for (String s : pinyingStr) &#123; char headChar = s.charAt(0); // 首字母是否大写，默认是小写 if (isCapital) &#123; headChars[i] = Character.toUpperCase(headChar); &#125; else &#123; headChars[i] = headChar; &#125; i++; &#125; return headChars; &#125; /** * 取汉字的首字母(默认是大写) * * @param src * @return */ public static char[] getHeadByChar(char src) &#123; return getHeadByChar(src, true); &#125; /** * 查找字符串首字母 * * @param src * @return */ public static String[] getHeadByString(String src) &#123; return getHeadByString(src, true); &#125; /** * 查找字符串首字母 * * @param src * @param isCapital * 是否大写 * @return */ public static String[] getHeadByString(String src, boolean isCapital) &#123; return getHeadByString(src, isCapital, null); &#125; /** * 查找字符串首字母 * * @param src * @param isCapital * 是否大写 * @param separator * 分隔符 * @return */ public static String[] getHeadByString(String src, boolean isCapital, String separator) &#123; char[] chars = src.toCharArray(); String[] headString = new String[chars.length]; int i = 0; for (char ch : chars) &#123; char[] chs = getHeadByChar(ch, isCapital); StringBuffer sb = new StringBuffer(); if (null != separator) &#123; int j = 1; for (char ch1 : chs) &#123; sb.append(ch1); if (j != chs.length) &#123; sb.append(separator); &#125; j++; &#125; &#125; else &#123; sb.append(chs[0]); &#125; headString[i] = sb.toString(); i++; &#125; return headString; &#125; public static void main(String[] args) &#123; // pin4j 简码 和 城市编码 String s1 = &quot;中华人民共和国&quot;; String[] headArray = getHeadByString(s1); // 获得每个汉字拼音首字母 System.out.println(Arrays.toString(headArray)); // [Z, H, R, M, G, H, G] String s2 =&quot;长城&quot; ; System.out.println(Arrays.toString(stringToPinyin(s2,true,&quot;,&quot;))); // [zhang,chang, cheng] String s3 =&quot;长&quot;; System.out.println(Arrays.toString(stringToPinyin(s3,true,&quot;,&quot;))); // [zhang,chang] &#125;&#125; 关于解决多音字问题，在找了很多资料，看到http://blog.csdn.net/lkx94/article/details/53860253 这篇博文写的不错~]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring data jpa相关总结]]></title>
    <url>%2Fpost%2Fspring%20data%20jpa%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JPA最早是由sum公司提出的一套java持久化规范，sum公司最早的野心是统一持久层框架，可惜最终被收购，而且只统一了关系型框架（hibernate等）。spring公司再次基础上又提出spring data规范，不仅是关系型框架，非关系型redis数据库，也被统一规范。此处总结的spring data jpa就是spring data接口规范实现之一。 用过spring data jpa后，个人体验的确是大大提高了对持久层操作的开发效率，并且简化了很多数据访问操作。特别是它的命名查询，只需要按照规范取方法名称，继承jpa接口，就可以做到无需实现类，无需sql语句！！话不多说，开始总结~ 一、基本介绍1.1、继承体系Repository（空接口） ———— CrudRepository（接口） ———— PagingAndSortingRepository（接口） ———— JpaRepository（接口） — SimpleJpaRepository（实现类）JpaSpecificationExecutor（接口） — SimpleRepository（实现类） 1.2、主要对象详解 Repository：空接口，仅仅是一个标识，表明任何继承它的均为仓库接口类 CrudRepository：定义了简单的增删改查的方法 PagingAndSortingRepository：定义了分页和排序的方法 JpaRepository：继承了以上两者，并且定义了批量删除的方法，开发中最常用。 JpaSpecificationExecutor：传入一个Specification构造条件对象，进行条件、分页、排序查询 SimpleRepository：这个实现类很强大，它实现了以上接口所有定义的方法，我们没有直接的使用到它，但有简洁使用到。 1.3、spring data jpa不需要实现类的原因：使用spring data jpa 时，根据对数据操作的需求，dao接口继承对应的接口时，可以不需要添加该接口的实现类就可以直接在service注入该接口，原因是因为： 若我们定义的接口继承了Repository，则该接口会被IOC容器识别为一个Repository Bean，纳入到IOC容器中，进而可以在该接口中定义满足一定规范的方法。在spring配置文件中配置了base-package指定了Repository Bean所在的位置，在这个包下的所有的继承了Repository的接口都会被IOC容器识别并纳入到容器中，如果没有继承Repository则IOC容器无法识别。当我们在service中可以直接注入定义的接口（没有实现类），是因为IOC容器中实际存放了继承了Repository的接口的实现类，而这个实现类由spring aop 返回代理对象完成。没有编写实现类时，返回的实现类和SimpleRepository实现同一个接口，相当于jdk动态代理，有接口的情况下，返回的是该接口的子类，没有接口，使用的是cglib,返回的是该接口的实现类，即SimpleJpaRepository的子类 1.4、如果在特殊情况需要使用到repository的实现类：以UserRepository为例： 在UserRepository接口同一个包下创建其实现类UserRepositoryImpl（实现类命名规则为： 接口名称+Impl） 在UserRepository接口中定义实现类UserRepositoryImpl中需要实现的login方法，无需实现对应的接口（否则接口中的所有方法都要实现） 注入是依然是注入的UserRepository接口 由于Spring data jpa的命名查询很强大，可以解决一些简单的查询，可以无需使用到sql语句，所以基本上无需使用到实现类，所以就不需要担心在同一个包既有接口，又有实现类的问题 二、简单使用方式2.1、配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt; &lt;!-- 扫描 @Server @Controller @Repository --&gt; &lt;context:component-scan base-package=&quot;spring 注解扫描包&quot; /&gt; &lt;!-- 加载properties文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:config.properties&quot; /&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 整合JPA配置 --&gt; &lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;实体扫描包&quot; /&gt; &lt;property name=&quot;persistenceProvider&quot;&gt; &lt;bean class=&quot;org.hibernate.ejb.HibernatePersistence&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;jpaVendorAdapter&quot;&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt; &lt;!-- 自动生成表结构、数据库方言 --&gt; &lt;property name=&quot;generateDdl&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;database&quot; value=&quot;ORACLE&quot; /&gt; &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.Oracle10gDialect&quot; /&gt; &lt;property name=&quot;showSql&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- jpa方言设置 --&gt; &lt;property name=&quot;jpaDialect&quot;&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;jpaPropertyMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;hibernate.query.substitutions&quot; value=&quot;true 1, false 0&quot; /&gt; &lt;entry key=&quot;hibernate.default_batch_fetch_size&quot; value=&quot;16&quot; /&gt; &lt;entry key=&quot;hibernate.max_fetch_depth&quot; value=&quot;2&quot; /&gt; &lt;entry key=&quot;hibernate.generate_statistics&quot; value=&quot;true&quot; /&gt; &lt;entry key=&quot;hibernate.bytecode.use_reflection_optimizer&quot; value=&quot;true&quot; /&gt; &lt;entry key=&quot;hibernate.cache.use_second_level_cache&quot; value=&quot;false&quot; /&gt; &lt;entry key=&quot;hibernate.cache.use_query_cache&quot; value=&quot;false&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt; &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;!-- 整合spring data jpa --&gt; &lt;jpa:repositories base-package=&quot;持久化层包扫描&quot;&gt;&lt;/jpa:repositories&gt;&lt;/beans&gt; 2.2、简单总结1、持久化层操作时，都会有一个对象帮助我们操作数据库，从最原始的jdbc的statement对象，c3p0连接池的QueryRunner对象，hibernate中的session，spring data jpa中称为entityManagerFactory，mybatis中的sqlSession对象…2、通过 &lt;jpa:repositories base-package=”持久化层包扫描”&gt;&lt;/jpa:repositories&gt; 扫描 Repository所在的包全名，就可以找到对应的接口，无需使用注解！3、配置事务管理器，根据不同的数据持久层操作对象，事务管理器对象也不同：Hibernate中是HibernateTransactionManager，spring data jpa中是JpaTransactionManager 三、命名查询和自定义sql上文提及spring data jpa非常强大，可以无需实现类无需sql语句，只要方法的命名符合规范，就可以实现相应的功能。比如，用户登录时，校验用户名密码，只需要在UserRepository中定义以下方法即可：User findByUsernameAndPassword(对应参数);以上username 和password是User这个实体的一个字段。通过findByXxx即可根据字段xxx查询。 3.1、其他规则： findByUsernameOrPassword findByStartDateBetween findByAgeLessThan(Equal) 查询年纪小于(等于) findByAgeGreaterThan(Equal) 查询年纪大于(等于) findByAgeIs(Not)Null 非空/为空判断 findByUsername(Not)Like 模糊查询 findByUsernameOrderByAgeDesc 根据年龄的降序查询用户名 findByAge(Not)In(Collection ages) 年龄在/不再某个范围… 注意：1、以上命名查询只针对单表查询，如果涉及多表查询，需要使用下文提到的JpaSpecificationExecutor接口进行条件查询！2、如果使用findByXxx，而xxx并不是实体类中的字段，并且没有自定义sql语句，会报PropertyReferenceException: No property xx for type..的错误 3.2、自定义sql当执行其他增删改或复杂查询方法时，spring data jpa也提供了自定义sql操作数据库的能力，比如：123@Query(value=&quot;update TakeTime set status=?2 where id=?1&quot;,nativeQuery=false)@Modifyingpublic void batchUpdateDel(Integer id,Integer status); 使用@Query注解在对应的方法上面，value属性后面值为响应的SQL/HQL语句，spring data jpa默认采用的和hibernate一样HQL语句，当参数列表的顺序和HQL中所需参数顺序不同时，可以在？后面加入数字来对应相应的参数！nativeQuery 属性值为一个布尔类型，默认值为false,当为true是，value后面的值应该为SQL语句当对表进行修改操作时，需要多加一个@Modifying注解 四、多表查询，分页条件查询，排序查询使用Spring data jpa使得分页条件查询（多表）变的很容易，（采用的是Criteria语句查询）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Action(value = &quot;findAllOrderByPage&quot;, results = &#123; @Result(name = &quot;success&quot;, type = &quot;json&quot;) &#125;)public String findAllOrderByPage() &#123; // 构造Pageable分页对象 // 参数列表：传入当前页，每页显示条数，根据某个字段升降序排序 Pageable pageable = new PageRequest(page - 1, rows,new Sort(new Sort.Order(Sort.Direaction.DESC,&quot;age&quot;))); // 分页条件查询 使用Specification 接口 Specification&lt;Order&gt; specification = new Specification&lt;Order&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Order&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; // 定义List集合容纳条件对象 List&lt;Predicate&gt; list = new ArrayList&lt;Predicate&gt;(); // 1、Order表中 单表操作 以下是比较字段的值而不是名称！！ // 判断工号是否非空 模糊查询 if (StringUtils.isNotBlank(model.getOrderNum())) &#123; Predicate p1 = cb.like(root.get(&quot;orderNum&quot;).as(String.class), &quot;%&quot; + model.getOrderNum() + &quot;%&quot;); list.add(p1); &#125; // 判断商品名称 模糊查询，%号不能漏掉 if (StringUtils.isNotBlank(model.getName())) &#123; Predicate p2 = cb.like(root.get(&quot;name&quot;).as(String.class), &quot;%&quot; + model.getName() + &quot;%&quot;); list.add(p2); &#125; // 判断类型 等值查询 if (StringUtils.isNotBlank(model.getType())) &#123; Predicate p3 = cb.equal(root.get(&quot;type&quot;).as(String.class), model.getType()); list.add(p3); &#125; // 2、Order和Standard多表操作 此处的standard必须为Order表中字段名称 // 返回的是Standard表中的root，不写连接方式默认是内连接！！ Join&lt;Object, Object&gt; standardRoot = root.join(&quot;standard&quot;, JoinType.INNER); if (model.getStandard() != null &amp;&amp; StringUtils.isNotBlank(model.getStandard().getName())) &#123; Predicate p4 = cb.equal(standardRoot.get(&quot;name&quot;).as(String.class), model.getStandard().getName()); list.add(p4); &#125; // 四个条件去并集 接受的是array数组，需要将集合转化为数组 return cb.and(list.toArray(new Predicate[0])); &#125; &#125;; // 在service中直接调用 OrderRepository中findAll(specification, pageable); 方法即可 Page&lt;Courier&gt; pageData = orderService.findAllOrderByPage(specification, pageable); // 压入值栈 Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put(&quot;total&quot;, pageData.getTotalElements()); result.put(&quot;rows&quot;, pageData.getContent()); ActionContext.getContext().getValueStack().push(result); return SUCCESS;&#125; 以上主要有Specification和Predicate两个对象 五、常见问题：5.1、spring data jpa延迟加载问题：1Caused by: org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: com.leahshi.domain.XXX, could not initialize proxy - no Session 解决方案：1、在实体类上对应字段的get方法上面加上@JSON(serialize = false)注解，返回数据时不返回该字段2、在web.xml中配置OpenSessionInViewFilter将session关闭放在web层，并且在service层要加上事务控制@ 5.2、分页查询中返回实体对象不是标准POJO类查看源码可以看到Page接口里只有getter方法，没有setter方法，不是一个标准的POJO类，在使用webservice传输数据时，直接回报错。。需要手动封装PageBean对象，提供getter/setter方法。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据持久层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[year-end summary --2016]]></title>
    <url>%2Fpost%2Fyear-end-summary-2016%2F</url>
    <content type="text"><![CDATA[年终了，一直都想写点什么，又不知道该说什么。年末意味着一年的终结，另一年的开端。每逢新旧交替，都会让人焦虑与期待。 2016年，遇到的各种事情还挺多。不论是工作上还是生活中，但沉默太久了后，就不知道从何说起。也一下子找不到合适的角度来记录这一整年，以表达自己内心深处的感觉。就像多年不言语的人，想发声是却怎么也说不出来的感觉……2016年，是开始的一年，也是成长的一年。以这样嚼烂的的开头来总结这一年，或许显得颇无诚意。 这一年，生活节奏有意识慢了下来，相对安逸的状态，不慌不忙，自然而坦荡。 生活不易，但没人叫嚷过。因为没有任何意义。每个人都把生活的不如意放在别人看不到的地方。当我知道一个外表光鲜年轻且有活力的同事，是一位身患疑难杂病的两岁小朋友的单身母亲时，给我的震撼太大。时常在公司看到她时，脑子里出现的是两年来她带着孩子四处奔波求医的样子……我心疼那个可爱的孩子，也敬佩这位坚强的母亲。但是我的这些心疼同情，之于她们没有意义，因为她们如此坚强的生活着而不是活着。生活的那些苦难对于她们生活态度上我没有看到任何影响痕迹…我也曾疑惑隔壁那哥们月薪都上万，为什么每天早晨还啃面包，中午从不舍得跟我们下馆子吃饭。后来才知他老婆怀孕辞职了，房贷、生活费、房租、养活一个孩子……生活的重担压的这个新任奶爸踹不过起来…我想过不了两年，我也将变为房奴，瞧，一个个被生活压迫的人们~ 时常会感到圈子对于我们来说太重要。时常又会觉得自己的圈子是被断层的。可能工作年限不太长的人都会有这样的尴尬境况吧，身边大多数同事又大自己一大截。所以大多时候，我独处。一个人呆久了是会上瘾的，当一些人涌入你的生活时，会感到很大的不适感，而当你习惯了它们的存在后它们的离去又花一段时间适应。毕业这么久了，对于身边的来来往往，我仍然会难受好半天。最初我到这家公司来很照顾我的周工、LW、林姐、还有几个同事都相继离职。但想想每个人有自己的选择。也就释然了。 这一年，java技术发展依然很快，前端的发展迭代的也很快。尽管自己保持在学习的状态，也是经常会感到学无止境。实践证明，在工作中学习、在项目中成长是最有效率的。自己私底下钻研的一些技术，倘若没有用到项目中，很多问题也没法暴露出来，印象也不会太深刻。今年学的东西很杂，很多都总结成了文章，还有很多还没来得及写。最大的收获是自己眼界和思想。工程化、组件化开发、前端各种单页面框架，后台处理高并发，高可用等方案，以及Spring家族等新鲜技术在十月初在我们ERP项目中都有涉及。兴奋的同时，也明确了下一步的方向。 路漫漫其修远兮，吾将上下而求索。17年的目标就不贴出来了。事实证明，在目标没完成前就说出来，也就很可能完成不了了… 写于 2016-12-28 晚。]]></content>
      <categories>
        <category>year-end summary</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ehcache]]></title>
    <url>%2Fpost%2Fehcache%2F</url>
    <content type="text"><![CDATA[接上篇使用完shiro完成动态菜单的制作后发现每次访问一个需要被权限控制资源时，调用 Realm 的授权方法，根据当前用户查询角色（role）和权限（permission）信息，每次调用 都会查询一次数据库从数据库查找菜单的信息，这样会增加数据库的压力，为了提高查询速率，查询数据后，我们可以将数据保存在内存中，提高查询数据性能，对同一批数据进行多次查询时， 第一次查询走数据库，之后的查询可以直接从内存获取数据，而不需要和数据库进行交互。 所以在在权限控制后还需要根据当前登录用对应的权限进行缓存。 缓存服务器有很多，因为shiro内置对ehcache的支持，所以通常情况下使用ehcache缓存相关授权数据。 一、授权数据的缓存：1、导入jar包12345&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.6.11&lt;/version&gt;&lt;/dependency&gt; 3、创建ehcache.xml配置文件缓存区可以配置多个，可以根据具体的业务配置不同的缓冲区，该配置文件可以在ehcache-core.jar包中找到1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!-- 内存中缓存数据 过多，写入硬盘，diskStore 用来定义硬盘保存缓存数据位置 --&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; &lt;!-- 默认缓存配置策略： maxElementsInMemory 内存中允许存放对象最大数量 eternal 缓存数据是否是永久的 maxElementsOnDisk 硬盘中缓存最大对象数量 --&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; maxElementsOnDisk=&quot;10000000&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;persistence strategy=&quot;localTempSwap&quot;/&gt; &lt;/defaultCache&gt; &lt;!-- 权限菜单配置缓存区--&gt; &lt;cache name=&quot;menu&quot; maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; maxElementsOnDisk=&quot;10000000&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;persistence strategy=&quot;localTempSwap&quot;/&gt; &lt;/cache&gt; &lt;!-- 可以根据不同的业务模块配置不同的缓存区 --&gt; &lt;cache name=&quot;standard&quot; maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; maxElementsOnDisk=&quot;10000000&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;persistence strategy=&quot;localTempSwap&quot;/&gt; &lt;/cache&gt;&lt;/ehcache&gt; 3、spring配置文件将application.xml抽取出application-cache.xml配置文件，并且配置cache名称空间 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd&quot;&gt; &lt;!-- 1、spring管理缓存管理器 并加载缓存配置文件 --&gt; &lt;bean id=&quot;ehCacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:ehcache.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2、shiro封装缓存管理器 --&gt; &lt;bean id=&quot;shiroCacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;ehCacheManager&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3、spring封装缓存管理器 --&gt; &lt;bean id=&quot;springCacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;ehCacheManager&quot; /&gt; &lt;/bean&gt; &lt;!-- 激活Spring注解扫描 --&gt; &lt;cache:annotation-driven cache-manager=&quot;springCacheManager&quot; /&gt;&lt;/beans&gt; 4、修改application-shiro.xml配置文件 将 shiro 的缓存管理器，注入到安全管理器中，并且向real中注入123456789101112&lt;!-- 配置安全管理器 --&gt;&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;bosRealm&quot; /&gt; &lt;!-- 将 shiro 的缓存管理器，注入到安全管理器中 --&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroCacheManager&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置realm --&gt;&lt;bean id=&quot;uhoemRealm&quot; class=&quot;com.leahshi.realm.UhoemRealm&quot;&gt; &lt;!-- 此处配置ehcache配置文件中的name &quot;authorizationCacheName&quot; 权限认证 而不是 身份认证 --&gt; &lt;property name=&quot;authorizationCacheName&quot; value=&quot;menu&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 5、常见问题：被缓存到内存中的实体，需要实现 Serializable序列化接口，否则在传输过程中会报错 三、业务数据的缓存：有些业务数据在操作过程中经常在查询，但是改动不是很大的情况下，我们也可以考虑对业务数据进行缓存。spring提供了一些缓存数据的注解： @Cacheable(value=””)：负责将方法的返回值加入到缓存中，通常加载查询方法上 @CacheEvict(value=””)：负责清除缓存，通常加载增删改的方法上 注意：1、注解的value值，应该填写ehcache.xml文件中定义的缓冲区定义的name值。2、当查询方法中传入参数时，需要在@Cacheable注解中加上key属性，key的值使用spring框架的SpEl表达式，传入方法参数标志每次缓存的数据都不一样。比如，在分页列表查询中，需要传入每页显示条数和当前页码进行标识 1234567// 对于有参数的查询@Override@Cacheable(value = &quot;standard&quot;, key = &quot;#pageable.pageNumber+&apos;_&apos;+#pageable.pageSize&quot;)public Page&lt;Standard&gt; findAllStandardByPage(Pageable pageable) &#123; Page&lt;Standard&gt; findAll = standardRepository.findAll(pageable); return findAll;&#125;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Shiro]]></title>
    <url>%2Fpost%2FApache%20Shiro%2F</url>
    <content type="text"><![CDATA[权限控制和用户认证在管理系统中是很常见也很重要的一块，根据系统中使用到的Apache Shiro安全框架加以总结。Apache Shiro是一款强大、灵活的开源安全管理框架，以十分优雅的方式处理authentication（身份验证）、authorization（授权）、Session Management（会话管理）、Cryptography（安全数据加密）、 Web Integration web 系统集成等… 一、概述任何的权限控制，大致分为粗粒度的URL级别和细粒度方法级别，在shiro中也不例外。在shiro中，URL级别的权限控制其实现方式是有一个shiroFilter过滤器来实现；而细粒度的权限控制具体是由一个@RequiresPermissions(value = {“”,””})注解实现，其本质还是aop面向切面的思想，返回代理对象，但是在shiro中必须要使用cglib的动态代理原因是因为jdk动态代理，代理对象和原对象实现同一个接口，相当于兄弟关系，所以注解会失效；而采用cglib方式，代理对象和原对象是有继承关系的。 二、使用shiro实现用户身份验证2.1、需求：用户未登录状态无法访问其他页面，只能跳转登录页 2.2、实现：1、导入jar包题主使用的maven坐标，直接引入shiro-all，在官网中详细介绍了其他jar包的作用，基本上所有jar包都有涉及，所以直接引入一个总的jar包12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;&lt;/dependency&gt; 2、配置web.xml上面提到shiro的粗粒度URL权限控制是基于Filter的，所以需要在web.xml文件里配置一个shiroFilter的过滤器（注意名称必须为这个，如果项目中引入了struts的过滤器，需要将shiroFilter放在其上，struts才不会拦截这个资源）123456789&lt;!-- shiro 权限控制 --&gt;&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3、配置spring配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt; &lt;!-- 配置核心过滤器: 注意：此处的id和web.xml中的过滤器名称要保持一致 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;!-- 安全管理器 --&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;!-- 未认证 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.html&quot; /&gt; &lt;!-- 已登录 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/index.html&quot; /&gt; &lt;!-- 认证后无权限 --&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.html&quot; /&gt; &lt;!-- 权限控制：角色 用户 权限 URL控制过滤器规则: anon: 未登录状态也可以访问的资源 authc:已登录状态访问的资源 roles：特定角色才能访问 perms：特定权限才能访问 user：特定用户才能访问 port 需要特定端口才能访问 reset 根据指定 HTTP 请求访问才能访问 --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &lt;!-- &quot;**&quot; 表示所有层级目录 --&gt; /css/** = anon /js/** = anon /images/** = anon /login.html* = anon /services/** = anon /validatecode.jsp* = anon /userLogin = anon &lt;!-- 只有在权限表中关键字中为 courier:list 的角色才有权限查看该页面 --&gt; /pages/base/courier.html* = perms[courier:list] &lt;!-- 只有在角色表中关键字为base的角色才有权限查看该页面 --&gt; /pages/base/area.html* = roles[base] /** = authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;uhoemRealm&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置realm --&gt; &lt;bean id=&quot;uhoemRealm&quot; class=&quot;com.leahshi.realm.uhoemRealm&quot;&gt;&lt;/bean&gt; &lt;!-- 生命周期后处理器 --&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;&gt;&lt;/bean&gt; &lt;/beans&gt;``` 以上配置文件中，需要配置shiroFilter，该名称和web.xml中名称一致。这个对象注入了安全管理器这个核心对象，并且配置了定义了权限控制的一些规则，未登录状态下跳转页面，登录成功后的跳转页面，权限不足的页面，以及配置了一些特定用户可以访问的资源以及权限信息【重点，见注释】4、表现层UserAction，创建登录方法 @Action(value = “userLogin”, results = { @Result(name = “success”, type = “redirect”, location = “index.html”), @Result(name = “login”, type = “redirect”, location = “login.html”) })public String userLogin() { // 获取subject对象，相当于User Subject subject = SecurityUtils.getSubject(); // 创建token AuthenticationToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword()); try { subject.login(token); return SUCCESS; } catch (AuthenticationException e) { e.printStackTrace(); return LOGIN; } }1234以上调用subject的login方法后，shiro底层会操作核心对象SecurityManager安全管理器，在spring配置文件中为SecurityManager注意了一个Realm对象，所以会紧接着调用自动一的Realm对象5、创建Reaml对象 package com.leahshi.bos.realm; import java.util.List; import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.Subject;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service; import com.leahshi.bos.domain.system.Permission;import com.leahshi.bos.domain.system.Role;import com.leahshi.bos.domain.system.User;import com.leahshi.bos.service.system.IRoleService;import com.leahshi.bos.service.system.IUserService; public class BosRealm extends AuthorizingRealm { @Autowired private IUserService userService; @Autowired private IRoleService roleService; /** * 认证信息 */ @Override public AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { // 将token强转为所需的子类token UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token; User user = userService.findByUsername(usernamePasswordToken.getUsername()); try { if (user == null) { // 未查到该用户 System.out.println(&quot;该用户不存在&quot;); return null; } else { /** * 参数分别为：登录后保存到subject中的信息，用户的密码，realm 名称 */ return new SimpleAuthenticationInfo(user, user.getPassword(), getName()); } } catch (IncorrectCredentialsException e) { e.printStackTrace(); System.out.println(&quot;密码错误失败！&quot;); return null; } catch (UnknownAccountException e) { e.printStackTrace(); System.out.println(&quot;该账户不存在！&quot;); return null; } } } 123456789101112131415161718192021222324252627282930因为此次登录时按照用户名和密码登录的，所以首先需要将token强转一下；shiro和通常的做法不同，只需要根据对应的用户名查找出用户，如果账户存在 realm自动根据用户输入的密码 匹配 查询出来的密码 另外，在用户名不存在是会报一个UnknownAccountException的异常，密码错误报IncorrectCredentialsException异常，需要留意。最后千万别忘记，将自动一的Realm放入到spring容器中，并将Realm注入到SecurityManager中！！！6、业务层和数据访问层，只有一个查询的方法，略### 2.3、总结：在这个认证（登录）案例中，并没有体现出shiro权限控制框架的强大之处，可能我们自定义一个filter也可以实现这些功能，拦截某些页面。初学者可能还会觉得很麻烦，在表现层调用业务层之前还要在依次操作Subject - SecurityManager - Realm，最后还需要调用业务层和dao，但是接下来的授权管理会真正体现它的强大之处！我们可以根据用户认证完成后，存储到subject中的信息，传入到授权的方法中，根据当前登录的用户在数据库中查询其对应的所有角色信息，根据角色信息可以查询到所有的权限信息，有了权限信息可以实现动态菜单的功能，不同用户登录系统，根据权限显示不同的菜单选项 ## 三、使用shiro实现权限控制提及权限控制，就要涉及到四个实体：用户、角色、权限、菜单 表关系如下：![](/images/auth.png)添加角色信息会关联菜单项，添加用户会关联角色，从而达到不同用户登录系统生成动态菜单项。### 3.1、基于粗粒的URL级别权限控制： 在上面提供的spring配置文件中，shiroFilter这个过滤器注入了filterChainDefinitions这个属性，根据上面介绍的就可以达到特定权限和角色可以查看页面的需求。其原理是由过滤器实现### 3.2、基于细粒度方法级别权限控制：1、在spring配置文件中配置开启权限注解设置，并且要指定动态代理的模式为cglib 122、在自定义realm类中的doGetAuthorizationInfo 添加权限信息的关键字： /** 权限信息*/@Overridepublic AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection pc) { // 查询当前用户对应的权限 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); Subject subject = SecurityUtils.getSubject(); User user = (User) subject.getPrincipal(); // 查询当前用户对应的角色信息 List roles = roleService.findByUserId(user.getId()); for (Role role : roles) { // 为用户添加角色权限 在配置文件中有定义能查看的页面权限限制 authorizationInfo.addRole(role.getKeyword()); // 为用户添加权限信息 for (Permission permission : role.getPermissions()) { authorizationInfo.addStringPermission(permission.getKeyword()); } } return authorizationInfo;}` 3、在具体需要权限控制的类上添加注解：常用的注解有： 需要特定的角色：@RequiresRoles(value={}) 需要特定的权限：@RequiresPermissions(value = { “keyword1”,”keyword2” }) 验证是否登录：@RequiresAuthentication 验证用户是否被记忆，一种是成功登录的，另外一种是被记忆的：@ RequiresUser]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>权限控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webservice跨系统间数据传输]]></title>
    <url>%2Fpost%2Fwebservice%E8%B7%A8%E7%B3%BB%E7%BB%9F%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[WebService是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。简单来说，Webservice主要应用于多个系统进行分布式开发时，跨系统间的数据通信。在前台可以通过ajax jsonp实现跨域，但是使用ajax跨域会存在代码侵入和不安全性，所以往往就需要服务器端来处理了。 两种方式Webservice CXF主要有两种数据传输方式：一种是基于SOAP协议，使用XML传输的JAX-WS，另一种是基于HTTP协议，使用Restful风格的JAX-RS，RS既可以使用XML数据格式进行传输，也可以使用JSON格式传输。通常我们会使用RS方式，因为restful风格会简化我们的开发。 区别：SOAP偏向于面向活动，有严格的规范和标准，包括安全，事务等各个方面的内容，同时SOAP强调操作方法和操作对象的分离，有WSDL文件规范和XSD文件分别对其定义。而REST强调面向资源，只要我们要操作的对象可以抽象为资源即可以使用REST架构风格。 Restful风格：一种软件架构风格，提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制，同时基于HTTP协议，支持多种消息格式，比如XML、JSON。在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。 Spring整合Webservice开发基于JAX-WS方式1、导入jar包12345678910111213141516171819202122232425262728293031&lt;!-- CXF WS开发 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring框架需要jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 2、接口和实现类12345678@WebServicepublic interface IUserService &#123; @WebMethod public String sayHello(String name); @WebMethod public List&lt;Car&gt; findCarsByUser(User user);&#125; 注意：接口上需要加上@WebService注解，方法上需要加入@WebMethod注解实现类上需要加上@WebService(endpointInterface = “${接口的全限定名}”, serviceName = “${对外发布的服务名称}”) 3、配置文件A、Web.xml:12345678910111213141516171819&lt;!-- spring配置文件位置 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- spring核心监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt; &lt;servlet-name&gt;CXFService&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFService&lt;/servlet-name&gt; &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; B、spring配置文件服务器端：123456789101112131415&lt;!-- Spring配置文件中需要加上名称空间 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd&quot;&gt; &lt;jaxws:server id=&quot;userService&quot; address=&quot;/userService&quot; serviceClass=&quot;$&#123;接口全限定名&#125;&quot;&gt; &lt;jaxws:serviceBean&gt; &lt;bean class=&quot;$&#123;接口实现类全限定名称&#125;&quot; /&gt; &lt;/jaxws:serviceBean&gt; &lt;/jaxws:server&gt; &lt;/beans&gt; 客户端：123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd&quot;&gt; &lt;jaxws:client id=&quot;userServiceClient&quot; serviceClass=&quot;$&#123;接口全限定名&#125;&quot; address=&quot;$&#123;发布地址&#125;/services/userService&quot; &gt; &lt;!-- 日志信息，会打印一些连接时的信息--&gt; &lt;jaxws:inInterceptors&gt; &lt;bean class=&quot;org.apache.cxf.interceptor.LoggingInInterceptor&quot;/&gt; &lt;/jaxws:inInterceptors&gt; &lt;jaxws:outInterceptors&gt; &lt;bean class=&quot;org.apache.cxf.interceptor.LoggingOutInterceptor&quot; /&gt; &lt;/jaxws:outInterceptors&gt; &lt;/jaxws:client&gt;&lt;/beans&gt; 4、客户端测试类1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:applicationContext-test.xml&quot;)public class JAXWS_Spring_Test &#123; @Autowired private IUserService userService; @Test public void fun()&#123; System.out.println(userService.sayHello(&quot;世界&quot;)); &#125;&#125; 5、测试与总结启动服务器，访问地址+web.xml下配置的映射路径+服务端spring配置文件中的address值+”?wsdl” ,就可已在浏览器中查看到一个xml形式的WSDL文件再运行客户端测试方法，即可在控制台中打印出信息 以上代码可以看到，使用JAX-WS方式进行数据传输，服务器端和客户端都必须要有相同的接口，使用起来比较不方便，所以更倾向于JAX-RS方式 基于JAX-RS方式1、导入jar包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!-- cxf 进行rs开发 必须导入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxrs&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日志引入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-rs-client&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 扩展json提供者 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-rs-extension-providers&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 转换json工具包，被extension providers 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jettison&lt;/groupId&gt; &lt;artifactId&gt;jettison&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 核心 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring web集成 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 整合junit --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- junit 开发包 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 2、接口和实现类123456789101112131415161718192021222324252627282930//@Path(&quot;/userService&quot;)@Produces(&quot;*/*&quot;)public interface IUserService &#123; @POST @Path(&quot;/saveUser&quot;) @Consumes(&#123; &quot;application/xml&quot;, &quot;application/json&quot; &#125;) public void saveUser(User user); @PUT @Path(&quot;/updateUser&quot;) @Consumes(&#123; &quot;application/xml&quot;, &quot;application/json&quot; &#125;) public void updateUser(User user); @GET @Path(&quot;/user&quot;) @Produces(&#123; &quot;application/xml&quot;, &quot;application/json&quot; &#125;) public List&lt;User&gt; findAllUsers(); @GET @Path(&quot;/findUser/&#123;id&#125;&quot;) @Consumes(&quot;application/xml&quot;) @Produces(&#123; &quot;application/xml&quot;, &quot;application/json&quot; &#125;) public User finUserById(@PathParam(&quot;id&quot;) Integer id); @DELETE @Path(&quot;/deleteUser/&#123;id&#125;&quot;) @Consumes(&quot;application/xml&quot;) public void deleteUser(@PathParam(&quot;id&quot;) Integer id);&#125; 接口中使用到注解说明： @Path：连接路径依次为：${发布的路径}/${web.xml中的配置}/${spring配置文件中的配置}/${接口上面的@Path中的值}/${方法上面的@Path中的值} @POST/@GET/@DELETE/@PUT/ :restful风格中将请求方式的不同，对应着增（@POST）删（@DELETE）改（@PUT）查（@GET）操作，通常@POST和@GET使用的较多，因为只是一种风格而不是规范。 @Consumes/@Produces ： 前者指定客户端请求数据的解析方式，后者指定响应到客户端的数据解析方式，通常会与复杂类型解析，简单类型无需指定 @PathParam/@QueryParam ： 前者接受的参数直接使用 /user/{参数} 显示在URL上，后者是以 /user?${@QueryParam注解中的值}=传入参数 键值对方式显示在URL上 实现类略，直接实现接口，写业务逻辑即可 注意：传输过程中，参数如果使用到了实体，需要在对应的实体类上加上@XmlRootElement(name = “xxx”) 注解 3、配置文件 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd&quot;&gt; &lt;!-- 需要引入jaxrs名称空间 address 发布服务地址 servicesBeans 服务实现类 --&gt; &lt;jaxrs:server id=&quot;userService&quot; address=&quot;/userService&quot; &gt; &lt;jaxrs:serviceBeans&gt; &lt;bean class=&quot;$&#123;实现类的全限定名称&#125;&quot; /&gt; &lt;/jaxrs:serviceBeans&gt; &lt;jaxrs:inInterceptors&gt; &lt;bean class=&quot;org.apache.cxf.interceptor.LoggingInInterceptor&quot; /&gt; &lt;/jaxrs:inInterceptors&gt; &lt;jaxrs:outInterceptors&gt; &lt;bean class=&quot;org.apache.cxf.interceptor.LoggingOutInterceptor&quot; /&gt; &lt;/jaxrs:outInterceptors&gt; &lt;/jaxrs:server&gt;&lt;/beans&gt; 4、客户端测试客户端直接使用WebCLient/HttpClient工具调用服务即可，此处使用的Webclient：12345678910111213// @GET请求@Testpublic void fun() &#123; // 如果返回的是集合，调用getCollection() User user = WebClient.create(&quot;$&#123;发布的地址&#125;&quot;).accept(MediaType.APPLICATION_JSON).get(User.class); System.out.println(user);&#125;// @POST请求@Testpublic void fun2() &#123; WebClient.create(&quot;$&#123;发布的地址&#125;&quot;).type(MediaType.APPLICATION_JSON).post(user);&#125; 5、测试与总结启动服务器，运行客户端测试方法，即可。 在不同系统间数据传输过程中，会有很多问题，通常需要双方联调，此处安利一个软件soap ui 来检查、调用、实现Web Service的功能/负载/符合性测试输入服务端发布的地址和所需要的参数，如果服务端没有问题的情况下，就可以测通]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>webservice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ消息中间件]]></title>
    <url>%2Fpost%2FActiveMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[ActiveMQ是一种消息中间件技术，它也是Apache组织开源的消息总线，同时也支持JMS规范。试想当实现注册功能时，通常需要用户接受手机验证码，防止恶意攻击，当用户量很大的情况下，执行注册操作都需要程序去向邮箱服务器发送邮件，这个过程很容易产生高并发，所以需要引入消息中间件，当需要发送邮件是，业务程序只需要向消息中间件产生一条消息，主要程序无需在等待调用邮件服务器发送邮件这个过程，这时候可以去处理其他请求了。而在ActiveMQ消息队列平台获取短信信息，调用SMS短信服务平台向用户发送邮件。从而解决了服务间的耦合性，增加系统并发处理量。 下载与安装在官网中下载完成后，双击activemq.bat，即可启动。和ElasticSearch一样需要配置jdk，并配置环境变量JAVA_HOME。ActiveMQ默认的浏览器访问端口号是8161，服务器端口是61616，访问http://localhost:8161，使用admin/admin登录即可。 在http://localhost:8161/admin/queues.jsp页面中可以看到一个表格显示消息信息： Name : 消息队列名称 Number Of Pending Messages : 待消费信息（未出队列的数量） Number Of Consumers ： 消费者个数 Messages Enqueued ：进入队列总消息数 Messages Dequeued ：消费掉的数量 两种数据结构ActiveMQ中存在两种模型，生产者和消费者；也有两种数据结构，queue队列和topic话题，俗称点对点和发布订阅。 queue和topic区别queue队列一条消息只能由一个消费者消费，但同一个队列可以关联多个消息生产者和消息消费者。如果多个消息消费者正在监听队列上的消息，JMS消息服务器将根据“先来者优先”的原则确定由哪个消息消费者接收下一条消息。如果没有消息消费者在监听队列，消息将保留在队列中，直至消息消费者连接到队列为止。 topic消息订阅一条消息可以有多个消费者消费，并且默认存在失效时间，必须在指定时间生效（可以手动设置）。同时topic模式分为持久化消息订阅和非持久化消息订阅，经过题主测试，在不配置持久化时，默认是非持久化的，即当接受者不处于receive等待状态，就再也接受不到该topic消息了 Spring整合ActiveMQ开发queue点对点模式1、导入jar包1234567891011121314151617181920212223242526272829&lt;!-- activemq所需jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.14.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring框架所需jar包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 2、生产者配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot; xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.8.0.xsd &quot;&gt; &lt;!-- 扫描包 --&gt; &lt;context:component-scan base-package=&quot;$&#123;扫描的包路径&#125;&quot; /&gt; &lt;!-- ActiveMQ 连接工厂 --&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;!-- 如果连接网络：tcp://ip:61616；未连接网络：tcp://localhost:61616 以及用户名，密码 --&gt; &lt;!-- &lt;amq:connectionFactory id=&quot;amqConnectionFactory&quot; brokerURL=&quot;tcp://localhost:61616&quot; userName=&quot;admin&quot; password=&quot;admin&quot; /&gt; --&gt; &lt;bean id=&quot;amqConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt; &lt;property name=&quot;userName&quot; value=&quot;admin&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt; &lt;/bean&gt; &lt;!-- Spring Caching连接工厂 --&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;amqConnectionFactory&quot;&gt;&lt;/property&gt; &lt;!-- Session缓存数量 --&gt; &lt;property name=&quot;sessionCacheSize&quot; value=&quot;100&quot; /&gt; &lt;/bean&gt; &lt;!-- Spring JmsTemplate 的消息生产者 --&gt; &lt;!-- Queue类型 --&gt; &lt;bean id=&quot;jmsQueueTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;constructor-arg ref=&quot;connectionFactory&quot; /&gt; &lt;!-- 非pub/sub模型（发布/订阅），即队列模式 --&gt; &lt;property name=&quot;pubSubDomain&quot; value=&quot;false&quot; /&gt; &lt;!-- 不持久1 持久化 2 --&gt; &lt;property name=&quot;deliveryMode&quot; value=&quot;2&quot;/&gt; &lt;!-- 存活时间 --&gt; &lt;!-- &lt;property name=&quot;timeToLive&quot; value=&quot;6000000&quot;/&gt; --&gt; &lt;!-- 开启服务质量的开关 开启之后上面的配置才会生效 --&gt; &lt;property name=&quot;explicitQosEnabled&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- Topic类型 --&gt; &lt;bean id=&quot;jmsTopicTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;constructor-arg ref=&quot;connectionFactory&quot; /&gt; &lt;!-- &lt;property name=&quot;defaultDestination&quot; ref=&quot;&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- pub/sub模型（发布/订阅） --&gt; &lt;property name=&quot;pubSubDomain&quot; value=&quot;true&quot; /&gt; &lt;!-- 持久化 --&gt; &lt;property name=&quot;deliveryMode&quot; value=&quot;2&quot;/&gt; &lt;!-- 存活时间 --&gt; &lt;!-- &lt;property name=&quot;timeToLive&quot; value=&quot;6000000&quot;/&gt; --&gt; &lt;!-- 开启服务质量的开关 开启之后上面的配置才会生效 --&gt; &lt;property name=&quot;explicitQosEnabled&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 3、消费者配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot; xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.8.0.xsd &quot;&gt; &lt;!-- 扫描包 在项目中可能已经配过就无需在配置--&gt; &lt;context:component-scan base-package=&quot;$&#123;消费者所在包&#125;&quot; /&gt; &lt;!-- ActiveMQ 连接工厂 --&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;!-- 如果连接网络：tcp://ip:61616；未连接网络：tcp://localhost:61616 以及用户名，密码 --&gt; &lt;!-- &lt;amq:connectionFactory id=&quot;amqConnectionFactory&quot; brokerURL=&quot;tcp://localhost:61616&quot; userName=&quot;admin&quot; password=&quot;admin&quot; /&gt; --&gt; &lt;bean id=&quot;amqConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt; &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot; /&gt; &lt;property name=&quot;userName&quot; value=&quot;admin&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;admin&quot; /&gt; &lt;/bean&gt; &lt;!-- Spring Caching连接工厂 --&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;amqConnectionFactory&quot;&gt;&lt;/property&gt; &lt;!-- 必须要配置这个 topic 消息订阅持久化才能生效 --&gt; &lt;property name=&quot;clientId&quot; value=&quot;leahshi&quot; /&gt; &lt;!-- Session缓存数量 --&gt; &lt;property name=&quot;sessionCacheSize&quot; value=&quot;100&quot; /&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;jmsTransactionManager&quot; class=&quot;org.springframework.jms.connection.JmsTransactionManager&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;amqConnectionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 消息消费者 start --&gt; &lt;!-- 定义Queue监听器 --&gt; &lt;jms:listener-container destination-type=&quot;queue&quot; container-type=&quot;default&quot; connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;auto&quot;&gt; &lt;!-- 默认注册bean名称，应该是类名首字母小写 --&gt; &lt;jms:listener destination=&quot;spring_queue&quot; ref=&quot;queueConsumer1&quot; /&gt; &lt;jms:listener destination=&quot;spring_queue&quot; ref=&quot;queueConsumer2&quot; /&gt; &lt;/jms:listener-container&gt; &lt;!-- 定义Topic监听器 --&gt; &lt;!-- &lt;jms:listener-container destination-type=&quot;topic&quot; container-type=&quot;default&quot; connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;auto&quot;&gt; &lt;jms:listener destination=&quot;spring_topic&quot; ref=&quot;topicConsumer1&quot; /&gt; &lt;jms:listener destination=&quot;spring_topic&quot; ref=&quot;topicConsumer2&quot; /&gt; &lt;/jms:listener-container&gt; --&gt; &lt;jms:listener-container destination-type=&quot;durableTopic&quot; container-type=&quot;default&quot; connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;auto&quot;&gt; &lt;jms:listener destination=&quot;spring_topic&quot; ref=&quot;topicConsumer1&quot; subscription=&quot;test.customer&quot;/&gt; &lt;jms:listener destination=&quot;spring_topic&quot; ref=&quot;topicConsumer2&quot; subscription=&quot;test.customer2&quot; /&gt; &lt;/jms:listener-container&gt; &lt;!-- 消息消费者 end --&gt;&lt;/beans&gt; 4、定义消费者（可以多定义几个） 1234567891011@Componentpublic class QueueConsumer1 implements MessageListener&#123; public void onMessage(Message message) &#123; try &#123; TextMessage textMessage = (TextMessage) message; System.out.println(textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5、定义生产者 12345678910111213141516171819202122232425262728293031323334package com.activemq.producer;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import javax.jms.TextMessage;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import org.springframework.stereotype.Component;/** * 生产队列 */@Componentpublic class ProducerTest &#123; @Autowired // 如果是topic队列 注入jmsTopicTemplate @Qualifier(&quot;jmsQueueTemplate&quot;) private JmsTemplate jmsTemplate; public void send(String queueName,final String message)&#123; jmsTemplate.send(queueName,new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage(message); return textMessage; &#125; &#125;); &#125;&#125; 6、测试与总结1234567891011121314151617181920212223package com.activemq.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.activemq.producer.ProducerTest1;import com.activemq.producer.ProducerTest2;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext-mq-produce.xml&quot;)public class ActivemqProducerTest &#123; @Autowired private ProducerTest queueProducer; @Test public void fun()&#123; queueProducer.send(&quot;spring_queue&quot;, &quot;hello,2017_queue&quot;); &#125;&#125; 运行完生产者方法后，在http://localhost:8161/admin/queues.jsp 列表上看到‘spring_queue’队列已产生一条信息，消费者测试，只需要写个死循环（保证线程开启状态，在项目中SMS系统会一致保持启动状态），并注入消费者配置文件，即可在控制台中输入‘hello,2017_queue’ 以上queue队列只发送了一条消息，尽管jms模板中配置了两个消费者，但只打印一条，证明了queue队列中一条消息只能有一个消费者消费 topic消息订阅模式topic消息订阅模式，jar包、配置文件、消费者代码同上，生产者，只需要注入生产者配置文件中的jmsTopicTemplate即可。需要注意的是前面提及，如果没有配置消息订阅持久化，测试时候，需要先将消费者启动，在启动生产者，否则将接受不到消息。但是在spring配置文件生产者中配置如下后就可以实现消息持久化：在配置JmsTemplate是开启持久化12&lt;!--开启持久化，topic模式发送的消息，会保存在broker中，是topic持久化的前提 默认是1 不持久化--&gt;&lt;property name=&quot;deliveryMode&quot; value=&quot;2&quot;/&gt; 测试结果打印出两条信息，虽然topic只发送一条信息，但是JmsTemplate中配置了两个消费者，所以打印两条信息，也证明了topic中，一条信息可以有多个人消费 应用场景分析topic适用于群发、消息订阅，信息都是一致的，queue队列使用与发送验证码等唯一性的信息。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从前端的角度考虑性能优化]]></title>
    <url>%2Fpost%2F%E4%BB%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E8%A7%92%E5%BA%A6%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[性能优化一直以来都是很热门的话题,不论在面试中还是实际工作的项目迭代中,都会考虑到.借以此篇总结平时用到的一些方法以及网上学习到的tips 由于前端方面设计的资源很多也很杂,包括html,css,images,js等等,优化相对较散也比较复杂. 以上(来源网络)概括的很全面,有很多方法博主也没用过,以下总结从实际项目中常见的概述. 一、页面角度1.1、减少HTTP请求数每一次的请求都要经历一次:DNS寻址 → 连接数据库服务器 → 发送或接受数据 → 等待响应 → 发送或接受成功.每次请求一旦那一步出现了问题,用户就需要花较长的时间,可能因此会流失一部分用户量 从以下常用的场景减少请求量: 设计可能的话尽量简化 合理缓存一些很少变动的数据资源 资源合并压缩 图片处理:使用精灵图(css sprites)、 通过编码的字符串将图片内嵌到网页文本中(data: URL scheme)(不常用) Lazy Load使用懒加载 避免重复的资源引入、 可以尝试使用CDN 1.2、引入文件 外部js库置底，因为在加载的时候回阻塞其他资源 Lazy Load Javascript 将 CSS放在 HEAD中，否则页面由无CSS状态跳转到 CSS状态，用户体验比较糟糕 避免重复的资源请求（比如页面的多个模块都引入了jQuery文件） 二、代码角度 js优化（方式很多） css选择器（浏览器对选择符的解析是从右往左进行的） html image压缩]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS - 数据绑定]]></title>
    <url>%2Fpost%2FAngularJS%20-%20%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[操作DOM是实际项目中大量使用的，如果没有接触到Angular，或许觉得JQuery用起来还算顺手。对Angular稍微了解的，就会知道数据绑定在Angular有多简便。 双向绑定Angular的数据双向绑定指的是 model和view之间的双向绑定。在用户点击元素、填写表单等view上的行为中用的最多。 基础用法(ng-module)12&lt;input type=&quot;text&quot; ng-model=&quot;iptValue&quot;/&gt;&lt;p&gt;你输入的是：&#123;&#123;iptValue&#125;&#125;&lt;/p&gt; 以上花括号称为插值表达式。在控制器中也可以获取到用户输入的内容console.log($scope.iptValue)一旦用户输入改变了会改变传输到后台或者后台返回的内容改变了绑定到界面中，故称之为双向。 绑定表达式，二次计算常见的例子，用以界面中带出用户性别，在数据库中存储可能为0和1，这时我们就需要对数据加以处理转换（格式化format）123456789&lt;div&gt;&#123;&#123;formatGender(a.gender)&#125;&#125;&lt;/div&gt;$scope.formatGender = function(gender) &#123; if (gender == 0) return &quot;女&quot;; if (gender == 1) return &quot;男&quot;; &#125;&#125;; 在绑定表达式时，只能使用自定义函数，不能使用原生函数。若需要用到原生函数是，可以用一个自定义函数作包装，在自定义函数里面可以随意使用各种原生对象1234&lt;div&gt;&#123;&#123;abs(-1)&#125;&#125;&lt;/div&gt;$scope.abs = function(number) &#123; return Math.abs(number); &#125;; 绑定数组对象常用语列表遍历循环 ng-repeat ；在指令篇详细介绍。 Angular双向数据绑定的功能强大的远不止以上列举的三种，还有很多场景：比如操作样式高亮（ng-class）、状态控制（ng-show、ng-if）等。在指令篇详细说明。 作用域（$scope）上面数据绑定中有个参数$scope经常出现，在其内可以声明一个作用域。Angular 作用域是一个指向应用模型的对象，它是表达式的执行环境、能监控表达式和传递事件。一旦一个 ng-app、ng-controller、ng-repeat 等指令被定义，那么一个作用域就产生了。 作用域基本功能 提供观察者以监视数据模型的变化； 可以将数据模型的变化通知给整个应用，甚至是系统外的组件； 可以进行嵌套，隔离业务功能和数据； 给表达式提供运算时所需的执行环境。 $rootScope由 ng-app 所生成的作用域是一个根作用域（$rootScope），它是其他所有$scope 的最顶层。在js中变量不声明就会被绑定到window上，在Angular中不声明就会绑定到$rootScope上。 $scope 的继承在Angular中，如果两个控制器所对应的视图存在上下级关系，它们的作用域就自动产生继承关系。如果里面控制器继承的变量发生改变了，外面的控制器却不会同步变化123456789101112131415&lt;div ng-controller=&quot;OuterCtrl&quot; ng-app=&quot;myApp&quot;&gt; &lt;span&gt;&#123;&#123;a&#125;&#125;&lt;/span&gt; &lt;div ng-controller=&quot;InnerCtrl&quot;&gt; &lt;span&gt;&#123;&#123;a&#125;&#125;&lt;/span&gt; &lt;button ng-click=&quot;a=a*2&quot;&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; var app = angular.module(&apos;myApp&apos;,[]);app.controller(&quot;OuterCtrl&quot;,function($scope)&#123; $scope.a = 1;&#125;) app.controller(&quot;InnerCtrl&quot;,function($scope)&#123; &#125;) 以上 界面显示两个1；如果InnerCtrl不声明会把表达式的内容打印出来。 $scope 的生命周期创建 → 链接 → 更新 → 销毁]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS - 模块]]></title>
    <url>%2Fpost%2FAngularJS%20-%20%E6%A8%A1%E5%9D%97%EF%BC%88app.module%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Module介绍每一个Angular应用都应该声明一个或多个module，通常一个应用视为一个Module即可。SPA应用的首页中引入所有的资源，DOM结构中放置一个div，给其绑定ng-app。在通过路由，实现页面嵌套。在HTML中用ng-app绑定某个模块的父节点上。 使用语法1angular.module(name, [requires]); 【name】为一个字符串，值为页面中ng-app=&quot;myApp&quot; 中的值（myApp） 【requires】为一个数组，在module声明的时候，后面带一个数组，这个数组里面可以指定它所依赖的module，以供该模块使用。如果没有要依赖的模块可以为空angular.module(name, []); angular.module(‘name’, [])和angular.module(‘name’) 虽然看起来很相似，但是含义却是不同的。前者是创建一个新的module，[]表示它没有依赖任何其他模块，如果已经有了一个同名模块，则会覆盖现有的（参照项目根目录中app.module.js文件）；而后者是查找一个现有module，如果这个module不存在，则返回空值（参照项目各个模块的controller、state、service、js文件）。如果把前者误用为后者，那么在它的返回值上调用controller等函数会出现空指针错误；如果把后者误用为前者，则会导致那些依赖注入的module丢掉。 angular.module(&#39;myModule&#39;,[]).后面常用的方法一下方法每一个都可以作为一个专题来记述，此篇不祥述。只做简单陈述和列举 constant(name, object);一个应用中的常量设置文件，比如可以设置版本号、DEBUG_INFO_ENABLED（是否启用调试信息）等。通常一个项目中只有一个app.constant.js文件，放在根目录，用以对整个项目的常量设置。 run(initializationFn)可以使用此方法注册当注入模块全部加载后执行的初始化函数。 controllercontroller(name, constructor);Angular MVC框架中的C，每个页面都有对应的控制器。 configconfig(configFn);使用此方法来注册需要在模块加载上执行的工作，比如$stateProvider路由。关于Angular路由是Angular的核心之一，之后在记述。 services(为和下面方法做区分加-s) factory(name, function); 创建services中最简单的方法； 需要一个方法和数据的集合且不需要处理复杂的逻辑的时候使用factory()； 需要使用.config()来配置service的时候不能使用factory()方法； service(name, constructor); provider(name, providerType); 以上三种都是Angular注册服务构造函数，services 可以用来永久保存应用的数据，只有在应用生命周期结束的时候（关闭浏览器）才会被清除。而controllers在不需要的时候就会被销毁了。并且这些数据可以在不同的 controller 之间使用。通常用于页面中的数据请求、通用的方法、页面之间的通信，因为同一个services可以注入到不同的控制器中调用，而控制器只能绑定在一个代码块或一个页面。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS - 简介]]></title>
    <url>%2Fpost%2FAngularJS%20-%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[写在前面先来个来个小故事^_^传说中挺牛逼的产品经理总算是入职了，第二天开早会，就提出对公司ERP进行改版。一个月后，迭代新版本上线了…老板挺开心的，PM来了就一个月居然就有这么大的变化，值了。可不是么，一大片扎眼的blue… 这次迭代之后也带来很多不好维护的问题，于是各种开会讨论后，归结于框架没选好…PM:我们要换框架，前后台都换。现在前台用的React，虽然很流行，但是毕竟是新东西各个猿们在底下OS：第一版本用的.Net，结果换个PM了后，说后台语言没选好，第二版本改成Java…这次又换框架，明年又是要重复今年的节奏啊… 以上为博一笑而已，请勿当真。手动分割线 O(∩_∩)O哈哈~ 在项目之前虽然有接触过一些Angular的基础API，但也只是平常练手，在项目中的经验还是和欠缺的。改变是更多的是机遇，心里还是挺开心的。之后会根据项目中学到的姿势和自我体验先后记述系列学习笔记。欢迎拍砖… 框架选型后台框架选用的是比较新型的J潮客；在首页，映入人眼的是这样一句话：JHipster is a Yeoman generator, used to create a Spring Boot + Angular project. 即 JHipster ≈ Yeoman + Spring Boot + Angular。 所以前台框架自然就从React换成了Angular。原来一片绿，真的很扎眼，所以也在网上搜集了很多有关Angular的UI库，看到Angulr，眼前一亮，一直都很偏爱黑白简单的风格。 Angular简单介绍AngularJS 是由 Google 发起的一款开源的前端 MVC（Model-View-Controller） 脚本框架，主要用来构建单页面应用程序，即SPA（simple page application）。 在之后的笔记中，会围绕下面模块简单记述。 路由（route） 数据绑定 表达式 —— 花括号赋值 作用域（$scope） 数据请求通信 事件类型 指令（directives） 模块（module） 依赖注入 控制器（controller） 依赖注入 服务（ service、factory） 依赖注入 过滤器（filter） 国际化（translate）]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取url参数]]></title>
    <url>%2Fpost%2F%E8%8E%B7%E5%8F%96url%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前几天，营销部在做一个活动时，需要一个H5的活动页，需要用到WebApp以及内嵌原生app中，此时遇到这样的一个场景：在WebApp中需要头部，但是在原生app中只需要除头部的内容即可。如果放在后台，获取地址栏上的参数很容易，可是这是静态页面耶，当然最容易解决的方法固然是做成完全一样的两个页面，只是有无头部的区别，这样做对于一个追求代码简洁的人(^_^)来说， absolutely no way。后来网上找资料找到了解决方案，介意总结 需求同一个页面，通过向url传递一个参数，js获取参数来控制页面。WebApp的页面地址假设为activity.html，显示完整页面而App的地址则也activity.html?isApp=1，不需要显示头部 方法一：正则表达式一下代码采用正则表达式方法，将url的参数拆分开。也可以在后面传递多个参数 activity.html?isApp=1&amp;id=001调用时直接是用函数名console.log(getQueryString(参数名))即可 1234567891011function getQueryString(name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125;if(getQueryString(&quot;isApp&quot;)==1)&#123; var header=document.getElementsByTagName(&apos;header&apos;)[0]; head.style.display=&quot;none&quot;;&#125; 逐步分析 首先需要获取到地址栏中的url值 再根据js方法将url和参数分离开 url?参数1&amp;参数2 将多个参数逐个切分至一个数组中 将各个参数的参数名和参数值切分 调用函数12345678910111213141516171819202122232425262728function getQueryString() &#123; var name,value; //1、获取到url的值 var str=location.href; //2、分割url内的多个参数 //indexOf() 方法可以返回括号内字符串值在字符串中首次出现的位置 var num=str.indexOf(&quot;?&quot;) //substr() 方法语法stringObject.substr(start,length) //可在字符串中抽取从 start 下标开始的指定数目的字符 str=str.substr(num+1); //3、各个参数放到数组里 var arr=str.split(&quot;&amp;&quot;); for(var i=0;i &lt; arr.length;i++)&#123; num=arr[i].indexOf(&quot;=&quot;); if(num&gt;0)&#123; name=arr[i].substring(0,num); value=arr[i].substr(num+1); this[name]=value; &#125; &#125; &#125; var Request=new getQueryString(); //实例化 if(Request.isApp==1)&#123; var header=document.getElementsByTagName(&apos;header&apos;)[0]; head.style.display=&quot;none&quot;;&#125; 方法二：js中提供了location对象，并且提供了location.search方法，比如在浏览器中访问 http://ip:port/demo.html?id=123调用location.search方法就可以返回 “?id=123” ，可以说很强大了]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮生偷闲]]></title>
    <url>%2Fpost%2F%E6%B5%AE%E7%94%9F%E5%81%B7%E9%97%B2%2F</url>
    <content type="text"><![CDATA[最近真的有好多想法，好多时候都是一闪而过，各种事情缠身，也没精力来更新文章。今天总算得空了，偷得浮生半日闲。 很多时候都想把自己的业余时间填的满满的，因为时刻告诉自己选择走的是一条和身边很多人不一样的路。 有段时间手头上工作很宽松时，就会有种莫名其妙的焦虑围绕着我； 项目下来被告知周末要加班时，又常常会抱怨不喋； 人总是这样，处于一种状态一直走不出来时，常常会厌倦甚至暴躁。 特别对我来说，一层不变的东西，即便是再完美，总会心生烦躁。往坏了说，这兴许是喜新厌旧吧。 但如果没有在其中积累一段时间，又不能衍生“经验”、“熟练”、“砖家”之类厚重的东西（看来我注定不能成为砖家=，=） 所谓的一万个小时定律，大概就是这个意思吧。 所以最好的感受就是，在一种状态久处走出来换到另种状态那小段时间，就是最欢愉的时刻。 也正是此刻、躺在床上、灯已熄。一看时间，21：44。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商品放大镜]]></title>
    <url>%2Fpost%2F%E5%95%86%E5%93%81%E6%94%BE%E5%A4%A7%E9%95%9C%2F</url>
    <content type="text"><![CDATA[网上有很多这样的插件可以实现放大镜的效果，但是如果对插件内部实现的逻辑不清楚，实际项目中布局不一样，浏览器窗口缩放时等情况都会让测试提出一个BUG…因此要分析源码，了解插件作者的逻辑思路。解决该问题，最主要是根据布局分析边界临界值。 以下对项目代码中各个参数进行分析： 项目中完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;放大镜效果&lt;/title&gt; &lt;style&gt; /*放大镜*/ *&#123;margin:0;padding:0;box-sizing: border-box;&#125; ul,ol,li&#123;list-style: none;&#125; body&#123;background-color:#f5f5f5;&#125; .displayImg&#123;padding:0;height:572px;margin-bottom:37px;border:none;padding-top:30px;box-sizing: border-box;overflow: visible&#125; .banner&#123;width:1200px;margin:50px auto;padding:100px;height:auto;background-color:#fff;&#125; /*图片放大镜样式*/ .jqzoom&#123;float:left;border:none;position:relative;padding:0px;cursor:pointer;margin:0px;display:block;border:1px solid #ddd;&#125; .zoomdiv&#123;z-index:100;position:absolute;top:0px;left:0px;background:#fff;border:1px solid #CCCCCC;display:none;text-align:center;overflow:hidden;&#125; .jqZoomPup&#123;z-index:10;visibility:hidden;position:absolute;top:0px;left:0px;width:20px;height:20px;border:1px solid #000;cursor:move; background:#ffffff;opacity: 0.5;-moz-opacity: 0.5;-khtml-opacity: 0.5;filter: alpha(Opacity=50);&#125; /*图片小图预览列表*/ .banner-in&#123;width:512px;float:left;height:auto;&#125; .left&#123;width:70px;margin-left:30px;height:500px;display:inline-block;background:yellow;&#125; .spec-preview&#123;width:510px;height:510px;display:inline-block;&#125; .spec-scroll&#123;width:1000px;margin-right:67px;&#125; .spec-scroll .items&#123;float:left;position:relative; width:1000px; height:430px;overflow:hidden;margin-bottom:-14px;&#125; .spec-scroll .items ul&#123;position:absolute;height:100%;&#125; .spec-scroll .items ul li&#123;width:74px;height:74px;text-align:center;margin-bottom:14px;cursor:pointer;display: inline-block;&#125; .spec-scroll .items ul li img&#123;width:100%;height:100%;box-sizing: border-box;border:1px solid #ddd;&#125; .spec-scroll .items ul li img:hover&#123;border:2px solid #333;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;banner&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div id=&quot;preview&quot; class=&quot;spec-preview&quot;&gt; &lt;span class=&quot;jqzoom&quot;&gt;&lt;img jqimg=&quot;b1.jpg&quot; src=&quot;s1.jpg&quot; height=&quot;400&quot; width=&quot;400&quot;/&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;spec-scroll&quot;&gt; &lt;div class=&quot;items&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img bimg=&quot;b1.jpg&quot; src=&quot;s1.jpg&quot; onmousemove=&quot;preview(this);&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img bimg=&quot;b2.jpg&quot; src=&quot;s2.jpg&quot; onmousemove=&quot;preview(this);&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img bimg=&quot;b3.jpg&quot; src=&quot;s3.jpg&quot; onmousemove=&quot;preview(this);&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; (function($)&#123; $.fn.jqueryzoom = function(options)&#123; //下面为放大镜默认设置中的一些参数，也可以在调用的时候再次设置 var settings = &#123; xzoom: 100, //宽高 yzoom: 100, offset:20, //离大图的间距 position: &quot;right&quot;, //位置在右边 lens:1, preload: 1 &#125;; //$.extend();将默认设置和最后调用时设置的参数进行合并 if(options) &#123; $.extend(settings, options); &#125; var noalt=&apos;&apos;; $(this).hover(function()&#123; noalt= $(this).children(&quot;img&quot;).attr(&quot;alt&quot;); var bigimage = $(this).children(&quot;img&quot;).attr(&quot;jqimg&quot;); $(this).children(&quot;img&quot;).attr(&quot;alt&quot;,&apos;&apos;); //debugger var imageLeft1 = $(this).closest(&apos;.banner&apos;).get(0).offsetLeft; //整个放大镜模块距离窗口左边的距离 var imageLeft2 = $(this).parent(&apos;#preview&apos;).get(0).offsetLeft; //大图距离整个模块的内左边距 var imageLeft = imageLeft1+imageLeft2; //盒子距离窗口的左边距 var imageRight =$(this).closest(&apos;.banner&apos;).get(0).offsetRight; //整个放大镜模块距离窗口右边的距离 var imageTop =this.offsetTop; //放大镜模块的padding-top值 var imageWidth = $(this).children(&apos;img&apos;).get(0).offsetWidth; //图片宽高 var imageHeight = $(this).children(&apos;img&apos;).get(0).offsetHeight; var leftpos; //添加放大镜和盒子 if($(&quot;div.zoomdiv&quot;).get().length == 0)&#123; //在其外部后添加放大后的盒子 $(this).after(&quot;&lt;div class=&apos;zoomdiv&apos;&gt;&lt;img class=&apos;bigimg&apos; src=&apos;&quot;+bigimage+&quot;&apos;/&gt;&lt;/div&gt;&quot;); //在其内部后面添加放大镜 $(this).append(&quot;&lt;div class=&apos;jqZoomPup&apos;&gt;&amp;nbsp;&lt;/div&gt;&quot;); &#125; //设置放大盒子的top和left值 // 如果默认在右边 if(settings.position == &quot;right&quot;)&#123; if(imageLeft + imageWidth + settings.offset + settings.xzoom &gt; screen.width)&#123; leftpos = imageLeft2 - settings.offset - settings.xzoom; &#125;else&#123; leftpos = imageLeft2 + imageWidth + settings.offset; &#125; &#125;else&#123; leftpos = imageLeft - settings.xzoom - settings.offset; if(leftpos &lt; 0)&#123; leftpos = imageLeft2 + imageWidth + settings.offset; &#125; &#125; $(&quot;div.zoomdiv&quot;).css(&#123; top: imageTop,left: leftpos,width:settings.xzoom,height:settings.yzoom,display:&quot;block&quot;&#125;); if(!settings.lens)&#123; $(this).css(&apos;cursor&apos;,&apos;crosshair&apos;); &#125; //捕捉鼠标移动事件 $(document.body).mousemove(function(e)&#123; mouse = new MouseEvent(e); //大图宽高 var bigwidth = $(&quot;.bigimg&quot;).get(0).offsetWidth; var bigheight = $(&quot;.bigimg&quot;).get(0).offsetHeight; //放大倍数 var scaley =&apos;x&apos;; var scalex= &apos;y&apos;; //如果放大的倍数不是数字 if(isNaN(scalex)|isNaN(scaley))&#123; //放大倍数=大图/小图 var scalex = (bigwidth/imageWidth); var scaley = (bigheight/imageHeight); //设置大图上面移动透明遮罩的宽高 = 放大后图片容器的宽高除以比例; $(&quot;div.jqZoomPup&quot;).width((settings.xzoom)/scalex ); $(&quot;div.jqZoomPup&quot;).height((settings.yzoom)/scaley); //透明遮罩出现 if(settings.lens)&#123; $(&quot;div.jqZoomPup&quot;).css(&apos;visibility&apos;,&apos;visible&apos;); &#125; &#125; xpos = mouse.x - $(&quot;div.jqZoomPup&quot;).width()/2 - imageLeft; //透明遮罩距离大图左边的距离 ypos = mouse.y - $(&quot;div.jqZoomPup&quot;).height()/2 - 210 ; //210为盒子距离窗口的上边距 if(settings.lens)&#123; xpos = (mouse.x - $(&quot;div.jqZoomPup&quot;).width()/2 - imageLeft &lt; 0 ) ? 0 : (mouse.x + $(&quot;div.jqZoomPup&quot;).width()/2 &gt; imageWidth + imageLeft ) ? (imageWidth -$(&quot;div.jqZoomPup&quot;).width() -2) : xpos; //210为盒子距离窗口的上边距 ypos = (mouse.y - $(&quot;div.jqZoomPup&quot;).height()/2 -210 &lt; 0) ? 0 : (mouse.y + $(&quot;div.jqZoomPup&quot;).height()/2 &gt; imageHeight+210) ? (imageHeight - $(&quot;div.jqZoomPup&quot;).height() -2 ) : ypos; &#125; if(settings.lens)&#123; $(&quot;div.jqZoomPup&quot;).css(&#123; top: ypos,left: xpos &#125;); &#125; scrolly = ypos; $(&quot;div.zoomdiv&quot;).get(0).scrollTop = scrolly * scaley; scrollx = xpos; $(&quot;div.zoomdiv&quot;).get(0).scrollLeft = (scrollx) * scalex ; &#125;); &#125;,function()&#123; $(this).children(&quot;img&quot;).attr(&quot;alt&quot;,noalt); $(document.body).unbind(&quot;mousemove&quot;); if(settings.lens)&#123; $(&quot;div.jqZoomPup&quot;).remove(); &#125; $(&quot;div.zoomdiv&quot;).remove(); &#125;); count = 0; if(settings.preload)&#123; $(&apos;body&apos;).append(&quot;&lt;div style=&apos;display:none;&apos; class=&apos;jqPreload&quot;+count+&quot;&apos;&gt;sdsdssdsd&lt;/div&gt;&quot;); $(this).each(function()&#123; var imagetopreload= $(this).children(&quot;img&quot;).attr(&quot;jqimg&quot;); var content = jQuery(&apos;div.jqPreload&apos;+count+&apos;&apos;).html(); jQuery(&apos;div.jqPreload&apos;+count+&apos;&apos;).html(content+&apos;&lt;img src=\&quot;&apos;+imagetopreload+&apos;\&quot;&gt;&apos;); &#125;); &#125; &#125; &#125;)(jQuery); //鼠标移动记录坐标 function MouseEvent(e) &#123; this.x= e.pageX; this.y= e.pageY; &#125; //鼠标经过预览图片函数 function preview(img)&#123; $(&quot;#preview .jqzoom img&quot;).attr(&quot;src&quot;,$(img).attr(&quot;src&quot;)); $(&quot;#preview .jqzoom img&quot;).attr(&quot;jqimg&quot;,$(img).attr(&quot;bimg&quot;)); &#125; //调用函数 $(function()&#123; $(&quot;.jqzoom&quot;).jqueryzoom(&#123;xzoom:380,yzoom:410&#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 思路事件：整个demo中只有鼠标移动事件，最难的也是临界点分析。 鼠标移上时： 鼠标移下时：遮罩层消失，放大镜消失，鼠标移动事件取消… 临界点： 确定整个模块距离窗口的上左右间距来确定放大后局部细节的位置。根据布局不同，边距也根据实际来判断，当小图在大图的下面是则不需要imageLeft2的值，我们UI设计的小图在大图左边… 确定小图上面透明遮罩的宽高；大图上面移动透明遮罩的宽高 = 放大后图片容器的宽高除以大小图比例。 确定小图上面透明遮罩要跟随鼠标移动，由于遮罩层是绝对定位，即要确定遮罩层距离下面图片的左间距和上间距，且这两个距离是随鼠标移动动态的改变的，画图即可得到计算关系。 确定放大后图片在容器中的滚动坐标；要与透明遮罩的移动的区域对应。及遮罩层的top、left值乘大小图比例。 扩展临界点麻烦是因为放大镜模块内部有padding值占据距离，和其他模块的间距也占据距离。在以后的项目中，布局可能会再次改变。以上demo，需要改变的是imageLeft、imageRight、imageTop、xpos、ypos]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditPlus初次使用设置]]></title>
    <url>%2Fpost%2FEditPlus%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、创建一个java文件的时候，会发现花括号的格式和C++格式一样，所以要设置一下 菜单栏 → 工具 → 参数设置 → 文件 → 模板 选择java模板，点击载入，template.java文件就处于被编辑状态了，将其编辑成以下格式：12345class ^! &#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 二、在编辑器中敲下关键字再敲下回车自动补充双括号： 菜单栏 → 工具 → 参数设置 → 文件 → 设置 &amp; 语法 选择java类型，点击加载java.acp文件，改文件处于编辑状态，将以下内容替换源文件内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#TITLE=Java/C#; EditPlus Auto-completion file v1.0 written by ES-Computing.; This file is provided as a default auto-completion file for Java and C#.#CASE=y#T=ifif (^!) &#123;&#125;#T=whilewhile (^!) &#123;&#125;#T=forfor (^!; ; ) &#123;&#125;#T=switchswitch (^!) &#123;case :&#125;#T=dodo &#123;&#125;while (^!);#T=classclass ^! &#123;&#125;#T=trytry &#123; ^!&#125;catch () &#123;&#125;#T=interfaceinterface ^! &#123;&#125;#T=namespacenamespace ^! &#123;&#125;#; C# only#T=foreachforeach (^!) &#123;&#125;#T=getget &#123; ^!&#125;#T=setset &#123; ^!&#125;#T=locklock (^!) &#123;&#125;#T=structstruct ^! &#123;&#125;# 以上两个设置，倘若将EditPlus安装在C盘，会出现无法保存的情况。将其拖到桌面编辑保存完成后，覆盖C盘文件。 三、使用快捷键编译java文件： 菜单栏 → 工具 → 参数设置 → 工具 → 用户工具 设置编译命令： 点击组名，修改组名为javac; 菜单文字：javac 命令：选择安装jdk的项目目录下的bin选中javac.exe 参数：选择文件名 初始目录：选择文件目录 动作：选择捕捉输出 点击应用，点击确定 设置输出命令： 点击组名，修改组名为java; 菜单文字：java 命令：选择安装jdk的项目目录下的bin选中java.exe 参数：选择文件名（不含扩展名） 初始目录：选择文件目录 动作：无 点击应用，点击确定 以上设置完毕后，可以在菜单中工具栏中看到javac和java命令的快捷键 四、使用EditPlus创建的java文件自动生成备份文件： 菜单栏 → 工具 → 参数设置 → 文件 将“保存时创建备份文件”取消掉。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>EditPlus</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误页面3s后跳转首页]]></title>
    <url>%2Fpost%2F%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A23s%E5%90%8E%E8%B7%B3%E8%BD%AC%E9%A6%96%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[在Web应用中，经常会因为各种各样的原因导致页面丢失，或者直接报错满篇错误代码。这样的用户体验是非常不好的。下面总结下3s跳转首页的方法。 代码12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;错误页面&lt;/h1&gt;&lt;span id=&quot;totalSecond&quot;&gt;3&lt;/span&gt;秒后自动返回&lt;/body&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; var second = document.getElementById(&apos;totalSecond&apos;).innerText; setInterval(&quot;redirect()&quot;, 1000); //每1秒钟调用redirect()方法一次 function redirect()&#123; if (second &lt; 0)&#123; location.href = &apos;http://www.uhoem.com&apos;; &#125; else&#123; document.getElementById(&apos;totalSecond&apos;).innerText = second--; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 剩下的就是后台捕获错误，再跳转页面了。 setInterval();与setTimeOut();区别： setTimeout(表达式,延时时间)在执行时,是在载入后延迟指定时间后,去执行一次表达式,记住,次数是一次 setInterval(表达式,交互时间)则不一样,它从载入后,每隔指定的时间就执行一次表达式 所以,完全是不一样的]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>用户体验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5总结]]></title>
    <url>%2Fpost%2FHTML5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTML5被定义为新一代开发Web富客户端应用程序【具有很强交互性和体验的客户端程序】整体解决方案，并非HTML4的下一版本，其前身为Web Application，在HTML、CSS、JavaScript API方面都有拓展。主要被应用于：网页应用程序（PC端、WebAPP端、WeChat端等）、混合式本地应用、游戏等… 下面主要介绍H5增加部分： HTML方面：新增标签在H5中新增了几种标签增强了其语义化，能够便于开发者阅读和写出更优雅的代码，代码如诗；让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容，更好的搜索引擎。常用的：header、nav、section、aside、article、footer等应用程序标签：DataList(数据列表)、Progress(进度条)、Meter(数值显示器)、Menu(右键菜单)、Details(明细) 【不太常用，很多浏览器支持这些属性】 新增网页多媒体：1、音频：123&lt;audio&gt; &lt;source src=&quot;img/music.mp3&quot; type=&quot;audio/mpeg&quot;/&gt; &lt;/audio&gt; controls 属性可以去掉；去掉之后音频播放器的默认外观消失可自定义；可通过按钮触发开始和暂停 play()和pause()2、视频：1234567&lt;video controls=&quot;controls&quot;&gt; &lt;!-- 不同浏览器支持格式不一样 (版权问题)--&gt; &lt;source src=&quot;fun.ogg&quot; type=&quot;video/ogg&quot; /&gt; &lt;source src=&quot;fun.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;!-- 当浏览器不兼容video标签，就会将他以div方式解析 --&gt; sorry 你的浏览器不支持！&lt;/video&gt; 对于不支持radio和audio标签的浏览器解决方法：还可以为视频添加弹幕3、Canvas：(后做专题)、2D/3D (WebGL)4、svg:svg即：Scalable Vector Graphics 可缩放矢量图形；体积小，质量高，效果好，可控程度高，使用方法如下：12345678910111213141516171819//a.使用 &quot;iframe&quot;标签【推荐使用】 svg单独作为一个页面 &lt;iframe src=&quot;1.svg&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;//b.使用&quot;object&quot;标签&lt;object data=&quot;data.svg&quot; type=&quot;&quot;&gt;&lt;/object&gt;//c.使用&quot;embed&quot;标签&lt;embed src=&quot;demo.svg&quot;&gt;//d.Ajax方式加载(自定义样式) 【最推荐使用】&lt;svg data-src=&quot;demo.svg&quot;&gt;&lt;/svg&gt;&lt;script&gt; window.addEventListener(&apos;load&apos;,function()&#123; var svgs=document.getElementByTagName(&apos;svg&apos;); for(var i=0;i&lt;svgs.length;i++)&#123; //向服务器发送请求 得到svg &#125; &#125;) &lt;/script&gt; 新增属性：1、自定义属性:（data-x）【重要】通过DOM存储与DOM对象强相关的数据。 2、智能表单：【手机端可以使用、pc端有很多兼容性问题】新表单类型（number、email、date、range、search、tel、color等）；在webapp中应用较多；原生的应用，在浏览器中会有很多兼容性问题。 3、链接关系描述：（用来描述指定链接与当前文档的关系，便于机器理解文档结构）常见链接关系表： stylesheet 文档的外部样式表；（常见） nofollow 用于指定 Google 搜索引擎不要跟踪链接（君子协议） copyright 包含版权信息的文档 contents、index、chapter、section、subsection 文档的 目录、索引、节、字段； alternate 文档的可选版本（例如打印页、翻译页或镜像）； start、next、prev（集合中的第一个文档\下一个\上一个）； glossary 文档中所用字词的术语表或解释； appendix 文档附录 help 帮助文档 licence 一般用于文献，表示许可证的含义 tag 标签集合 friend 友情链接 4、结构数据标记:(很高级的东西，只有Google支持)12345678&lt;div itemscope itemtype=&quot;http://example.com/hello&quot;&gt; &lt;p&gt;我叫&lt;span itemprop=&quot;老板&quot;&gt;aaa&lt;/span&gt;。&lt;/p&gt; &lt;p&gt; 我y有个员工叫 &lt;span itemprop=&quot;员工&quot;&gt;bbb&lt;/span&gt; 性别&lt;span itemprop=&quot;性别&quot;&gt;男&lt;/span&gt;。 &lt;/p&gt;&lt;/div&gt; 5、ARIA属性：Accessible Rich Internet Application (无障碍富互联网应用程序);主要针对于屏幕阅读设备(e.g. NVDA)，更快更好地理解网页，更多语义化。 CSS3【后作专题】JavaScriptAPI基础API提升1.新选择器JS多了一个原始支持，类似jqueryDOM选择器,可以通过CSS选择器的语法找到DOM元素： document.querySelector(selector) //返回第一个 document.querySelectorAll(“.item”) //返回所有.item元素，数组 2.元素的classList属性classList返回一个数组，Internet Explorer 9 及更早 IE 版本浏览器不支持 classList 属性selector.classList.add(className);add 添加一个新的类名、remove 删除一个的类名、contains 判断是否包含、toggle 切换一个class element.toggle(‘class-name’,[add_or_remove])toggle函数的第二个参数true为添加 false删除,第二个参数一般为函数 访问历史 API界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态在HTML5中可以通过window.history操作访问历史状态，让一个页面可以有多个历史状态： window.history.forward(); // 前进 window.history.back(); // 后退 window.history.go(); // 刷新 通过JS可以加入一个访问状态：history.pushState(放入历史中的状态数据, 设置title(现在浏览器不支持)， 改变历史状态) 全屏 APIJavaScript中可以通过调用requestFullScreen()方式实现指定元素的全屏显示：1document.querySelector(&quot;&quot;).requestFullScreen(); 其他API 网页存储：Web Storage、Web SQL、IndexedDB、Application Cache、localStorage、sessionStorage 文件系统：File API、FileReader 网络访问：XMLHttpRequest、fetch、WebSocket 拖放操作：网页内拖放、文件拖入、拖出 多线程：桌面通知 设备信息访问 网络状态 硬件访问 设备方向 地址围栏]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程真机调试 - weinre]]></title>
    <url>%2Fpost%2Fweinre%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[移动端前端开发过程中在各种机型会遇到各种奇怪的问题，这时就用到真机调试，针对性的解决了。真机调试的方式有很多，后续会相继做出总结，今天总结的是上个WebApp项目中用到的weinre真机调试。 Weinre介绍Weinre(Web Inspector Remote)是一款基于Web Inspector(Webkit)的远程调试工具， 它使用JS编写， 可以让我们在电脑上直接调试运行在手机上的远程页面。Weinre的使用场景调试的页面在手机上， 调试工具在PC的chrome， 二者通过网络连接通信。 安装环境weinre是基于nodejs实现的， 使用它必须先安装node运行环境。1[sudo] npm -g install weinre （是Mac/Linux用户， 还需要在前面加入&quot;sudo&quot;:） 安装成功，会得到下面的输出： 运行1、启动weinre的监控服务来进行远程调试：12weinre --boundHost -all-若命令行中输出`weinre:starting server at http://localhost:8080`则成功运行 2、以上命令默认端口号为8080，若与本地项目端口冲突要改端口：1weinre --httpPort 8082 --boundHost -all- 3、启动后，就可用用本地电脑的ip和端口号访问weinre服务页面 调试weinre服务页面中有两个地址值得我们注意：第一部分是Access Points，如下图：红框中的地址是Debug Client(Weinre调试工具)的用户访问接口，可以通过这个地址进入Debug Client。第二个部分是Target Script，如下图：这个地址是系统根据我们启动Weinre服务时的参数设置生成的target-script.js文件的链接地址。我们需要将这个js文件引入到待测试的页面中。要注意的是不要使用localhost:8080打开Weinre服务，否则生成的TargetScript链接也以localhost开头，这样直接复制到手机，就无法获取到文件了。 小结1234567891011//安装npm -g install weinre//默认端口8080启动weinre --boundHost -all-//更改端口为8082weinre --httpPort 8082 --boundHost -all-//在调试页面引入文件&lt;script src=&quot;http://172.16.0.140:8082/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt;//使用本地ip+端口号调试，在公司一般为局域网，如：http://172.16.0.140:8082注意输入命令行后直至调试完后才能关闭 否则会断线]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记]]></title>
    <url>%2Fpost%2F%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[不知道从什么时候开始，开始有点厌倦了自己的生活。除了工作上学习新技术给自己带来新鲜的冲击，其他很多时候我甚至都觉得自己体内的血液都不是鲜活。每天就是早九晚六，按部就班。有时想想昨天做了什么，除了工作相关的一些事，竟也想不出个所以然来。如若不改变，我想一眼便可以看到头的生活。可我才二十多，二十多岁不该有安稳这样的字眼。我需要折腾。 刚开始工作时，会因为担心自己无法胜任工作要求，每天晚上回家经常学习到深夜。如今可能不再有那样的冲劲，工作之外更多的时间花在没有价值的新闻和一笑而过的段子上。我投入生活的业余时间，并没有给我带来任何长远的习惯性的好处，只是片刻的欢愉。 我可能会因为神经大条，不知道自己身上某块淤青在哪里撞到的；自己的生理期延迟了多久；多久没锻炼；脸上痘痘怎么长起来的；吃了什么拉肚子……一直都未曾将注意力放在自己生活上面，身体上的一些小细节尚且没有注意到，更别说高质量的生活。 我常常惊讶于身边一些比自己大不了几岁的，有的谈起生活养生，口若悬河；有的写一手让我膜拜的字；有的精通各种乐器；有的能静下心来读万卷书……他（她）们都是鲜明的个性。虽然我有很多的兴趣，也常常会因为这些兴趣买下所需要的东西，但常常用过两三次后，因为时间太漫长才看到成果等各种原因，它们便被我打入冷宫。比如为了练习毛笔字的笔墨纸砚，水写布；比如全套的烘焙工具和烤箱；比如一把还没有更换的新手吉他；比如一副质量较好的羽毛球拍（虽然没人跟我打）…… 你对待生活冷漠，生活也将对你不客气。很快自己身体出现了一些问题。一些业余爱好也因为不精通而慢慢丧失。 今日在健身房，在跑步机上气喘吁吁时，我本以为时间过去了好久，结果也不过两分钟，消耗自然也不多。我一直让自己坚持坚持，过程真的很痛苦。那刻我突然意识到，享受会慢慢衍生懒惰，对自己降低要求，便也就失去了所谓的要求。对待生活怎样，生活也将如何待你。 做任何事都是漫长的过程。兴趣只给予了最初你学习它的愿望，却不一定能战胜懒惰。任何一种习惯和爱好，并非朝夕间，就能养成。 But you life belongs to nobody else.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断UA]]></title>
    <url>%2Fpost%2F%E5%88%A4%E6%96%ADUA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[UA即用户代理（User Agent），代表用户行为的软件（软件代理程序）所提供的对自己的一个标识符，被广泛用来标识浏览器客户端信息。想想项目测试阶段，测试拿着两补手机跑过来问你这两种设备为什么UI表现不一样时，我们首要要做的就是查到这两部设备的UA，才能做兼容。 判断各个平台的设备【推荐】12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; //判断 var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; //移动终端浏览器版本信息 trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核 presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核 webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或uc浏览器 iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase() &#125; //调用//document.writeln(&quot;语言版本: &quot;+browser.language);//document.writeln(&quot; 是否为移动终端: &quot;+browser.versions.mobile);//document.writeln(&quot; ios终端: &quot;+browser.versions.ios);//document.writeln(&quot; android终端: &quot;+browser.versions.android);//document.writeln(&quot; 是否为iPhone: &quot;+browser.versions.iPhone);//document.writeln(&quot; 是否iPad: &quot;+browser.versions.iPad);//document.writeln(navigator.userAgent); //实际调用小例子 var intro=document.getElementById(&apos;intro&apos;); if(browser.versions.mobile)&#123; if(browser.versions.android)&#123; intro.style.padding=&quot;10% 20% 0 20%&quot;; &#125;else if(browser.versions.ios)&#123; intro.style.padding=&quot;30% 20% 0 20%&quot;; &#125; &#125;else&#123; intro.style.padding=&quot;3% 20% 0 20%&quot;; &#125;&lt;/script&gt; 判断手机横竖屏：1234567891011&lt;style&gt;/*横屏时字体红色*/@media all and (orientation : landscape) &#123; h2&#123;color:red;&#125;&#125;/*竖屏时字体绿色*/@media all and (orientation : portrait)&#123; h2&#123;color:green;&#125;&#125;&lt;/style&gt; 判断移动端还是pc端【另种方法】1234567891011&lt;script type=&quot;text/javascript&quot;&gt; if(/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) &#123; window.location.href =&quot;mobile.html&quot;; // 如果是苹果机，就打开苹果的页面 &#125; else if (/(Android)/i.test(navigator.userAgent)) &#123; //如果是安卓机，就打开安卓页面 window.location.href =&quot;mobile.html&quot;; &#125; else &#123; //不是移动设备，就是pc端的 window.location.href =&quot;pc.html&quot;; &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>UA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git和GitHub总结]]></title>
    <url>%2Fpost%2FGitHub%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在过去一年中可能GitHub接触的相对较多，不过也仅限于在上线download一些demo。公司里面一直用的svn，所以对于git了解甚少。此次搭建个站接触到了git，借此发文总结。 Git介绍Git和SVN虽然SVN和Git都有使用到，但也仅仅是会日常的一些操作，对于它们背后的原理和流程不甚了解。熟悉SVN的对Git嗤之以鼻，熟悉Git的对SVN不屑一顾。工具本无对错，只有熟悉和用在适合的地方而已。总的来说，SVN是集中式的版本控制系统，而Git是分布式。分布式中，每个人手中都有一套完整的版本库。Git和其他版本控制系统还有个最大的不同就是它有暂存区的概念。 Git和GitHubGitHub为Git提供仓库托管服务，是Git的远程仓库，要付费选择不公开仓库代码。正常工作中，跟SVN一样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 在本机创建Git仓库（repository）个人理解是通过此步骤，讲本地项目与Git关联起来，便于Git命令行对项目操作以及跟踪文件操作的历史记录。 1、安装Git：（windows下）Git下载地址直接next到底即可。随便打开文件目录，右键看到【Git Bash Here】则安装成功。安装完成后，进行个人身份验证：(可填GitHub上的账户名和密码)12$ git config --global user.name &quot;Your Name&quot; //--g 表示此台电脑所有用户可用$ git config --global user.email &quot;email@example.com&quot; 2、选择适合的项目文件夹执行$ git init即可，在文件夹根目录会生成.git文件夹Git对项目文件的常用操作：新增文件：往Git版本库里添加的时候，是分两步执行的：先提交至暂存区，在提交到分支。之后所有的操作也是如此。 执行$ git status可以掌握仓库文件当前的状态【此步骤可省】 执行$ git add .将文件修改添加到暂存区 执行$ git commit -m &quot;提交要备注的信息&quot;将暂存区内容提交到当前分支 执行$ git push将新增的内容上传到远程仓库中（GitHub或者服务器） 删除文件：正常情况下： 1、直接在项目中删除 2、执行$ git status,提醒删除的文件（可省略） 3、执行$ git rm和$ git commit -m &quot;提交要备注的信息&quot;删除并提交 4、万一删错了执行 $ git checkout -- 文件名.后缀名笔者通常是在项目中删除后，直接commit，目前未发现异常情况 版本回退：实际开发过程中，会遇到各种情况需要回复到上一版本的情况，Git提供git log来查看历史记录。git log命令显示从最近到最远的提交日志，输入$ git log --pretty=oneline可以只输出版本号和改变内容，更加精简。12345$ git reset --hard HEAD^ // 回退到上一版本$ git reset --hard HEAD^^ //回退到上上一版本$ git reset --hard HEAD~5 //回退到往上5个版本//若只想回退到往上第二版本，却到了第三版本，执行$ git reset --hard 3628164（第二版本commit id，可在git log中查到） 管理修改：由于Git存在暂存区概念，所以一定要先全部修改到暂存区，最后一次性执行commit，否则会出现有些文件修改后没有被提交。 创建合并分支：让在同一个项目下的文件可以分布在不同的分支，互不干扰，完成后可合并。 创建dev分支，然后切换到dev分支：$ git checkout -b dev 查看当前分支$ git branch ，带星号 切换分支$ git checkout 分支名 将dev分支合并至主分支$ git merge dev 删除dev分支$ git branch -d dev 查看分支$ git branch Git与GitHub相互传输：GitHub → Git 在个人GitHub平台下新建仓库 在本机选择合适路径执行$ git clone git@github.com:用户名/仓库名.git Git → GitHub 第一步相同，新建仓库 按照空的新项目，GitHub给出的命令行依次执行本地项目推送至GitHub就拥有分布式版本库。 更新远程代码到本地仓库 查看远程仓库$ git remote -v 从远程获取最新版本到本地$ git fetch origin master 比较本地的仓库和远程参考的区别$ git log -p master.. origin/master 把远程下载下来的代码合并到本地仓库，远程的和本地的合并$ git merge origin/master]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>Stylus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之内部类]]></title>
    <url>%2Fpost%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[今天看到一种特殊的类，在一个类中，还包含一个类，称为内部类，下面加以总结。内部类按照位置分为：成员内部类、局部内部类、静态内部类。 一、成员内部类在类中成员的位置上，和其他成员位置一样。可以访问外部类中所有的方法和变量，包括私有的。格式：Outer.Inner oi = new Outer().new Inner();123456789101112//在main方法中Outer.Inner oi = new Outer().new Inner();oi.method();class Outer&#123; class Inner&#123; public void method()&#123; System.out.println(10); &#125; &#125;&#125; 成员内部类使用的修饰符在内部类中可以使用public protected 默认的权限（不写） static,不能使用private修饰，因为对本类私有的成员对外部不可见，无法创建对象。值得注意的是使用static来修饰内部类时，无须在创建内部类对象，直接类名调用123456789101112131415public class Test &#123; public static void main(String[] args) &#123; Outer.Inner o = new Outer.Inner(); o.method(); &#125;&#125; class Outer&#123; static class Inner&#123; //如果内部类的成员方法也加静态的话只用直接调用即可 Outer.Inner.method(); public void method()&#123; System.out.println(&quot;Inner Function&quot;); &#125; &#125;&#125; 二、局部内部类局部内部类和局部变量一样，在方法内声明。由于局部内部类存在于方法内，所以除了方法外是无法被调用的，除了该类也是无法被调用的。12345678910111213141516171819public class Test03 &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.function(); &#125;&#125; class Outer&#123; public void function()&#123; class Inner&#123; public void method()&#123; System.out.println(&quot;Inner Function&quot;); &#125; &#125; //要在内部类 声明后 创建对象 Inner i = new Inner(); i.method(); &#125;&#125; 三、匿名内部类匿名内部类就是没有名字的内部类，定义在方法中，所以也称为，匿名局部内部类。必须在定义匿名内部类的时候同时创建对象！创建继承这个类的子类对象或者是创建了实现这个接口的子类对象。匿名内部类的格式:new 类名/接口名(){ 重写该父类的方法体/重写接口中的所有抽象方法}; 应用场景：用于父类是抽象类或者接口时引用子类对象，该子类对象只当做参数或者返回值使用时，使用匿名内部类12345678910111213141516171819202122232425262728293031323334353637383940414243//当做参数传递public class Test&#123; public static void main(String[] args) &#123; //如果一个Animate的子类只是作为一个参数传递，就没有必要再创造一个类，直接使用匿名内部类即可。 method( new Animate()&#123; public void eat()&#123; System.out.println(&quot;吃饭&quot;); &#125; &#125; ) &#125; public static void method(Animate a)&#123; a.eat(); &#125;&#125;interface Animate&#123; public void eat();&#125;//返回值public class Test02&#123; public static void main(String[] args) &#123; /* Demo可以直接.调用method方法不用创建对象调用说明该方法是静态的， 调完method方法后还能调用show方法，说明返回值是一个对象 在接口Animate中有show方法，可以使用匿名内部类实现该接口再将其返回 */ Demo.method.show(); &#125;&#125;interface Animate&#123; public void eat();&#125;class Demo&#123; public static Animate method ()&#123; return new Animate()&#123; public void eat()&#123; System.out.println(&quot;HelloWorld&quot;); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之抽象类和接口]]></title>
    <url>%2Fpost%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[一、抽象类1.1、抽象类的概述和特点：当子类中有相同的方法，但方法体不同，父类只提供方法声明，不提供方法体。称为抽象方法。抽象方法所在的类只能是抽象类。题主在初学的时候会不太明白抽象类存在的意义，直接不继承，子类各自实现各自功能即可，为什么要这么麻烦去继承一个抽象类呢？事实上继承一个抽象类起到了规范的作用，在不明确方法体的情况下，要重写该方法，但方法的定义方式要和父类保持一致。 特点： 抽象类和抽象方法都被abstract修饰。 抽象类中的成员方法可以是非抽象的，但有抽象方法的类一定是抽象类或者接口 抽象类无法被实例化，（即不能创建对象） 抽象类的子类必须要重写父类的所有抽象方法，或者该子类也是抽象类。 抽象类中如果没有抽象方法，目的只有一个，不让你实例化该类，创建该类对象，和工具类原理相同，工具类中的方法都是静态的，必须私有工具类的构造方法。 1.2、抽象类的成员特点：在抽象类特点中已总结，抽象类的成员变量可以是变量，也可以是常量（被final修饰）；成员方法可以是抽象方法也可是非抽象方法；有构造方法，不能被实例化。存在的意义：用来初始化成员变量。可以按照多态的方式，有子类实例化。抽象类多态。比如： 123456789101112131415161718192021public class AbstractDemo &#123; public static void main(String[] args) &#123; // 抽象类不允许被实例化,但可以通过子类进行实例化，初始化成员变量。 Animate_1 a = new Cat_1(); a.num = 20; //正常情况下是用get、set方法获取和修改 &#125;&#125;abstract class Animate &#123; int num; public abstract void eat(); &#125;class Cat extends Animate &#123; int num = 10; @Overrides public void eat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125;&#125; 1.3、final关键字特点：被final修饰的变量变成常量;被final修饰的类,不能被继承;被final修饰的成员方法,不能被重写。final修饰的变量要么在定义的时候就完成初始化；要么在构造方法中完成初始化。 1.4、abstract不能和其他关键字共存A、不能和final共存：被abstract修饰的成员，强制子类重写，final不能重写。B、不能和static共存：被static修饰的类，可以通过类名直接调用，abstract修饰的抽象类直接调用无意义。C、不能和private共存：被private修饰的类，外界无法访问，无法被重写。 二、接口2.1、接口的概述：java中的继承规则是单继承，如果一个类是多面性的，可以继承多个类的情况下，java提供了接口类。类与接口是实现关系，可以多实现，也可以但实现。接口之间也存在继承关系，可以单继承，也可以多继承。implement InterA,InterB 使用逗号连接。 2.2、接口的成员特点： 接口中的所有方法都是抽象方法，用public abstract 修饰。一个类实现接口，必须要重写所有的抽象方法，或者该类也是抽象类 接口中的成员变量前默认加有 public static final 修饰符，即接口中只有常量。 接口没有构造方法，和抽象类一样不能实例化，但可以通过父类引用指向子类对象进行实例化。不同的是抽象类有构造方法。 三、匿名对象定义：没有名字的对象应用场景：当方法只调用一次的时候可以使用匿名对象，可以当作参数进行传递，但是无法在传参之前做其他事情注意：匿名对象可以调用成员变量并赋值，但是赋值并没有意义 四、static关键字4.1、特点：static关键字优先于对象的存在，随着类的加载而加载，被类中所有成员共享，可以通过类名调用。【推荐类名调用】静态的方法只能访问静态的成员，静态方法中没有this关键字。 4.2、静态变量（类变量）和成员变量（对象变量） 静态变量属于类，随着类的加载而加载，可以通过类名或者对象调用，存放在方法区的静态区中 成员变量属于对象，随着对象的创建而存在，只能通过对象名调用，存放在堆内存中 局部变量，随着方法的进栈而存在，存放在栈中。 五、代码块局部代码块：在方法中出现；限定变量生命周期，及早释放，提高内存利用率构造代码块：在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行静态代码块： 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。一般用于加载驱动同步代码块(多线程讲解)]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之继承和多态]]></title>
    <url>%2Fpost%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[此篇题主主要总结下面向对象的其他特性，继承和多态。假设两个类中有大量相同的成员特点，可以向上抽取一个类，使这两个类来继承该类，就可以在两个类中省掉大量重复性的代码。继承提高了代码的复用性和维护性，同时也增强可耦合性【弊端】，开发的原则：高内聚，低耦合。继承是多态的前提。 一、继承性的特点1.1、java中继承的特点：java中只支持单一继承，不支持多继承。也就是说class JiafeiCat extends Cat,Animate(){} 是错误写法。但是支持多级继承，Cat继承Animate类，JiafeiCat继承Cat类。如果想看继承体系中的共性特点，查看最顶层的类；向看该继承体系中所有的功能，查看最底层的类。 1.2、继承中成员变量的特点： 子类只能继承父类中非私有的成员，私有的成员变量无法被继承，但可以通过get、set、方法修改和获取 子类中已有的成员变量，就无需使用父类中存在的同名成员变量。就近原则：局部变量 – 子类中的成员变量 – 父类中的成员变量。如下： 1234567891011121314class Father&#123; int num = 10;&#125;class son extends Father&#123; int num = 20; public void show()&#123; int num = 30; System.out.println(num); //30 System.out.println(this.num); //20 //可以通过super关键字访问父类的成员 System.out.println(super.num); //10 &#125; &#125; 1.3、继承中成员方法的特点：如果父类的成员方法无法完全满足子类的要求，可已在子类中重写成员方法，再加上super关键字调用父类中满足的功能。如果满足直接调用即可。123456789101112class Father&#123; public void show()&#123; System.out.println(&quot;aa&quot;); &#125;&#125;@overrideclass Son extends Father&#123; public void show()&#123; System.out.println(&quot;bb&quot;); super.show(); &#125;&#125; A、方法重写的注意事项： 子类重写父类方法时，建议在重写方法前加上@override注解。 重写的方法权限必须大于等于父类，和父类保持一致就好。public &gt; protected &gt; 默认 &gt; private 父类中被私有的方法无法被重写 B、方法重写和方法重载的区别： 方法重写（override）：子类中出现了和父类中方法声明一模一样的方法，参数列表也相同。与返回值类型有关,返回值是一致(或者是子父类)的 方法重载（overload）：方法名相同，参数列表不同（参数类型、参数个数、参数顺序），无返回值无关 1.4、继承中构造方法的特点：注意：子类不能继承父类的构造方法！a、父类对象是优先于子类对象进栈的， 子类中的构造方法（不论是空参还有有参）默认会访问父类中的无参构造。子类初始化之前，一定要先完成父类数据的初始化每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。b、当子类构造方法中第一条语句已经定义了super()、this()语句，将不再默认访问父类的无参构造 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ExtendsDemo &#123; public static void main(String[] args) &#123; //实例化无参构造对象 //Zi z = new Zi(); //实例化无参构造对象有参构造 Son s = new Son(1); &#125;&#125;class Fu &#123; public Fu()&#123; System.out.println(&quot;父类的无参构造&quot;); &#125; public Fu(int num)&#123; System.out.println(&quot;父类的有参构造&quot;); &#125;&#125;class Zi extends Fu &#123; public Zi()&#123; //默认情况下，子类构造在第一行都有该方法，如果给出其他方法，将不再有super()方法 //super(); //父类的无参构造、子类的无参构造 //调用本类的有参构造方法 默认会方法父类的空参构造 //this(1); //父类无参、子类有参、子类无参 //调用父类有参构造 //super(1); //父类的有参构造、子类的无参构造 System.out.println(&quot;子类的无参构造&quot;); &#125; public Zi(int num)&#123; System.out.println(&quot;子类的有参构造&quot;); &#125;&#125;class Son extends Fu&#123; public son()&#123;&#125; public son()&#123; //默认情况下，子类构造在第一行都有该方法，如果给出其他方法，将不再有super()方法 //super(); //父类的无参构造、子类的有参构造 //调用父类有参 //super(1); //父类的有参构造、子类的有参构造 //调用本类无参，默认会先调用父类无参 //this(); //父类无参 子类的无参构造 子类的有参构造 System.out.println(&quot;子类的有参构造&quot;); &#125;&#125; 二、super和thissuper和this都可以调用成员方法，成员变量，构造方法。super代表当前对象父类的引用，this指向当前引用对象。1、调用成员变量和成员方法this.成员变量\成员方法，本类和父类的成员都可调用，就近原则。super.成员变量\成员方法，只能调用父类的。2、调用构造方法this(参数) 调用本类的构造方法super(参数) 调用父类的构造方法 三、多态概述多态的条件：继承、方法重写、父类引用子类对象。动态绑定：运行期间调用的方法，是根据其具体的类型。格式： Father f = new Son(); 3.1、多态的优缺点缺点：父类无法访问子类特有的成员变量和静态方法。优点：多态的前提是继承，所以也是提高代码复用性。同时多态的优点是扩展性，可以将父类写作方法参数，传入子类【常见】 3.2、多态中成员的特点：A、成员变量：f在访问son中的成员变量时，编译和运行都以父类为主，如果父类没有该变量，编译报错。B、成员方法：在访问子类中成员方法时，编译看父类，运行看子类。（体现了多态的三个前提）C、静态方法：编译和运行都看父类 12345678910111213141516171819202122232425//在main方法中创建对象Father f = new son(); f.show(); //父类成员方法f.print(); //父类静态方法System.out.println(num); //10class Father&#123; int num = 10; public void show()&#123; System.out.println(&quot;父类成员方法&quot;); &#125; public static void print()&#123; System.out.println(&quot;父类静态方法&quot;); &#125;&#125;class Son extends Father&#123; int num = 20; public void show()&#123; System.out.println(&quot;子类成员方法&quot;); &#125; public static void print()&#123; System.out.println(&quot;子类静态方法&quot;); &#125;&#125; 四、多态中的向上转型和向下转型：默认情况下是向上转型：Animate a = new Cat();向下转型：Cat c = (Cat) new Animate();向下转型后，可以调用子类独有的方法。 五、多态的扩展性体现：将父类作为参数传递，无需创建子类对象：123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) &#123; //静态的方法可以直接类名调用，无需创建对象 speaker.compare(new woman()); speaker.compare(new man()); &#125;&#125;class speaker&#123; public static void compare(Inter i)&#123; i.speak(); &#125;&#125;interface Inter&#123; public abstract void speak();&#125;class woman implement Inter&#123; @Override public void speak() &#123; System.out.println(&quot;女人演讲&quot;); &#125;&#125;class man implement Inter&#123; @Override public void speak() &#123; System.out.println(&quot;男人演讲&quot;); &#125;&#125;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之封装性]]></title>
    <url>%2Fpost%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言面向对象在很多语言中都有体现，但在java语言中体现的最为明显。面向对象开发可以让工作效率大幅提升，也可以省掉很多重复的步骤。面向对象的思想就是不断的创建对象，调用对象。与面向对象相对的是面向过程开发，比如C语言。 一、类的介绍在介绍对象之前，要先介绍类的概念，对象是类的具体体现。现实生活中的事物基本都可以使用java中的一个类来描述。事物的属性对应类的成员变量，事物的行为对应类的成员方法。一个标准类中应该有成员变量、成员方法、构造方法（以便创建对象） 1.1、类中成员变量和局部变量的区别：成员变量是定义在类中方法外的变量，随着对象的创建而存在，随着对象的消失而消失，所以和对象一样存放在堆内存中，堆内存中都有默认值。局部变量是定义在方法内或方法声明上，随着方法的弹栈而消失，存放在栈内存中，没有默认值，必须初始化后才能使用。 1.2、private关键字：用private修饰的成员方法或变量只能在本类中才能访问，外面必须通过给出的set、get方法才能访问，而不能直接修改成员变量，提高了安全性。比如学生类中的成员变量age，为了防止外部给其设置为非法数值，可以在set方法中加以控制。 1.3、构造方法：格式：public 类名(){};构造方法分为无参构造和有参构造，当没有自定义有参构造时，系统会给出无参构造，一旦自定义了有参构造，系统将不会再给出。构造方法是为了给对象初始化数据的。 所以可以此时可以通过set方法+无参的构造方法来给对象赋值，或者带参的构造方法赋值。区别：使用set方法赋值，可以多次赋值，带参构造只能赋一次值。 带参和无参的构造方法相当于方法的重载。【注意区分方法重写概念】 二、封装封装是面向对象的三大特性之一，是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装的原则：将不需要对外提供的内容都隐藏起来，提供公共的方法对其访问。提高了安全性，将方法进行封装，提高了代码复用性。 2.1、this关键字this代表当前类的引用对象，解决了构造方法中局部变量和成员变量重名的问题，使用this指向对象的成员变量。 2.2、标准学生类：123456789101112131415161718192021222324252627282930public class Student &#123; //成员变量 private String name; private int age; //成员方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; //构造方法 public Student()&#123;&#125;; public Student(String name,int age)&#123; this.name = name; this.age = age; &#125;&#125;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String对象常用API]]></title>
    <url>%2Fpost%2FString%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[因为JavaScript的一些知识先入为主，两种语言有相似的地方，也有截然不同的东西。Java是强类型语言，JavaScript是弱类型语言,前者数据类型分为：基本数据类型（四类八种）、和引用数据类型（类、接口、数组）。后者分为简单数据类型（也称为基本数据类型）：Boolean、Number、String、Null、Undefined、和复杂数据类型。今天介绍的String字符串，在JS中将String划归为简单数据类型，在Java中，String是一个类，属于引用数据类型。 一、String对象的构造方法：1.1、把字符串数据封装成字符串对象：12String s = new String(&quot;HelloWorld&quot;);String s1 = &quot;HelloWorld&quot;; 以上两者都可以创建一个字符串对象，但是s不等于s1，因为两者的地址值不同。前者是new出来的东西在内存空间中存储在堆中，后者直接存储在方法区的常量池中。字符串内容是储存在方法区的常量池中的，为了方便重复使用。new出来的也是，只不过从堆再指向方法区的常量池而已。 1.2、将字符数组，封装成字符串对象：12String s = new String(char[] 字符数组名);String s = new String(char[] 字符数组名,int index,int count); 以上都是讲字符数组封装成字符串对象，后者试讲将字符数组中，索引为index的元素开始数count个，封装成字符串对象。 二、String判断功能; 【返回boolean类型】 s1.equals(s2) //字符串s1和字符串s2是否完全相同 【账户名密码登录】 s1.equalsIgnoreCase(s2) //忽略大小写 是否相同 【验证码】 s1.starWith(str) //字符串s1是否以字符串str开头 s1.endWith(str) //是否以str 结尾 s1.isEmpty() //s1是否是空字符串 s1.contain(str) //s1是否包含str 三、String获取功能： s1.length() //获取字符串对象的长度 s1.charAt(int index) //获取字符串对象的某个字符【用于遍历字符串】 s1.indexOf(String str) //字符串str在字符串s1中的位置 s1不存在str则返回-1 s1.subString(int start) //截取索引从start开始到最后一位的字符串对象 s1.subString(int start,int end) //包括start不包括end 四、String转换功能 s1.toUpperCase() //全都转换为大写 s1.toLowerCase() //全都转换为小写 s1.toCharArray() //将字符串对象转换为char数组【可用于字符串遍历】 返回一个字符数组 byte[] getByte() 把字符串转换为字节数组 返回一个byte数组 valueOf() 将任意类型转换成字符串 concat(String str) 字符拼接 五、String去除左右两边的空格以及分割功能 s1.replace(char old,char new) //字符串中新字符替换存在的旧字符 s1.replace(String old,String new) //字符串中新字符串替换存在的旧字符串 s1.trim() //只能去除左右两边的空格 不能去中间的 String s = “11,ss,dd,ff”;String[] arr = s.split(“,”); //在遍历arr即可得到分割后的字符串 六、StringBuilder对象由于字符串拼接会产生很多内存垃圾，而StringBuilder对象无论追加多少个，都存在同一个地方，所以引入StringBuilder对象。 6.1、StringBuilder构造方法：StringBuilder sb = StringBuilder(); 容量：sb.capacity() //理论值 长度：sb.length() //实际值 6.2、StringBuilder的添加功能和反转功能： 添加功能 StringBuilder s = sb.append(“aa”).append(“bb”).append(“vv);无论append多少次，返回的都是对象，输出s==sb 返回true 地址相同 反转功能 System.out.print(s.reverse()) //vvbbaa 6.3、StringBuilder和String相互转换：1234567StringBuilder → String: StringBuilder sb = StringBuilder(); String s = sb.toString();String → StringBuilder: String str = &quot;aa&quot;; StringBuilder sb = StringBuilder(str); StringBuilder和String都有各自强大的功能，做字符串拼接和反转时，可以转换为StringBuilder来实现。操作字符串的获取、判断、转换功能时，转换为String来实现。 七、其他7.1、键盘录入String12Scanner sc = new Scanner(System.in);String str = sc.nextLine(); 7.2、判断字符是大小写或者数字的方法在ASC码表中，可以查到‘A’= 65;’a’=97;’0’=48,且26个大小写字母，0-9都是连续的。所以有以下规律：大写 str&gt;= ‘A’ 65 &amp;&amp; str&lt;=’Z’小写 str&gt;=’a’ 97 &amp;&amp; str&lt;=’z’数字 str&gt;=’0’ 48 &amp;&amp; str&lt;=’9’ 7.3、字符串的反转：思路一： 【推荐】 转化为StringBuilder，使用reverse()方法思路二： String s = “”; 将字符串对象转换为字符数组 char chs[] = str.toCharArray(); 再倒着遍历数组即可s+=chs[i];思路三： 将chs数组反转，索引start end思想 在遍历chs 最后字符串拼接 7.4、字符串易错题：123456789101112131415161718192021222324252627282930//1.判断定义为String类型的s1和s2是否相等String s1 = &quot;abc&quot;;String s2 = &quot;abc&quot;;System.out.println(s1 == s2); // true 字符串存放在方法区的常量池中，地址值相同。只有new出来的存放在堆内存中System.out.println(s1.equals(s2)); // true//2.下面这句话在内存中创建了几个对象?String s1 = new String(&quot;abc&quot;);//答案：创建两个对象,一个在常量池中,一个在堆内存中//3.判断定义为String类型的s1和s2是否相等String s1 = new String(&quot;abc&quot;);String s2 = &quot;abc&quot;;System.out.println(s1 == s2); // falseSystem.out.println(s1.equals(s2)); // true// 分别记录的是堆内存和常量池中的地址值//4.判断定义为String类型的s1和s2是否相等String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;String s2 = &quot;abc&quot;;System.out.println(s1 == s2); //true,java中有常量优化机制System.out.println(s1.equals(s2)); //true//5.判断定义为String类型的s1和s2是否相等String s1 = &quot;ab&quot;;String s2 = &quot;abc&quot;;String s3 = s1 + &quot;c&quot;;System.out.println(s3 == s2);// falseSystem.out.println(s3.equals(s2));// true 总结：直接定义的字符串是存放在方法区的常量池中，new出来的是现在堆内存中开辟空间，再指向常量池。所有直接定义的字符串地址值都相同 /n 换行 * // 一个斜杠/ * /t 相当于tab键 * /&quot; &quot;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识总结（三）]]></title>
    <url>%2Fpost%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在网上刷了一些基础题目，有些题目的思路想记录下来。可能以后随着经验丰富再回头看，可能那些思路已经是很常规的套路，可对于现阶段的自己还是想多多总结。 一、寻找数字类逻辑题1.1、判断101-200之间有多少个素数，并输出所有素数。分析：素数的定义为，除了1和自己，不能被任何数整除。实现步骤：循环遍历101-200（i），在循环2- i,i取不到（j），两个循环嵌套，如果i%j==0，则该数不为素数。 1.2、将一个正整数分解质因数。例如：输入90,打印出90=233*5。分析：用该数n除以最小质数2，并用将商从新赋值给n（递归思想）;最后很重要的一步，将循环变量在变为初始化2，因为分解质因数可以重复。12345678910111213141516171819public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.print(n+&quot;=&quot;); for (int k = 2; k &lt;= n/2; k++) &#123; if(n%k==0)&#123; //输出k System.out.print(k+&quot;*&quot;); //重新赋值n 递归 n = n/k; //k返回初始值 k = 2; &#125; &#125; //最后一次递归的n无法再分解，直接输出 System.out.println(n);&#125; 1.3、一个数如果恰好等于它的因子之和，这个数就称为“完数”,找出1000以内的所有完数。例如6=1＋2＋3。分析：首先循环1-1000的数字（i），在嵌套一次循环寻找i的因子（j）,j必须小于i。将i的因子相加如果恰好与i相等,输出i.123456789101112131415public static void main(String[] args) &#123; for (int i = 1; i &lt;= 1000; i++) &#123; //每次循环前要清零 int sum = 0; for (int j = 1; j &lt; i; j++) &#123; if(i%j==0)&#123; sum+=j; &#125; &#125; if(i==sum)&#123; System.out.print(i+&quot;,&quot;); &#125; &#125; &#125; 1.4、题目：求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时 共有5个数相加)，几个数相加有键盘控制。1234567891011121314151617public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要重复的数字：&quot;); int a = sc.nextInt(); System.out.println(&quot;请输入相加的个数：&quot;); int b = sc.nextInt(); int sum = 0; //循环相加的个数 for (int i = 1; i &lt;= b; i++) &#123; //得到每个数字 j取值范围1-i; for (int j = 0; j &lt; i; j++) &#123; int item = (int) (a*Math.pow(10, j)); //2 2 20 sum+=item; &#125; &#125; System.out.println(&quot;sum:&quot;+sum);&#125; 1.5、打印杨辉三角12345678910111213141516171819202111 11 2 11 3 3 11 4 6 4 1public static void main(String[] args) &#123; System.out.println(&quot;输入行数：&quot;); Scanner sc = new Scanner(System.in); int lines = sc.nextInt(); int[] a = new int[lines + 1]; int previous = 1; for (int i = 1; i &lt;= lines; i ++)&#123; for (int j = 1; j &lt;= i; j++)&#123; int current = a[j]; a[j] = previous + current; previous = current; System.out.print(a[j] + &quot; &quot;); &#125; System.out.println(); &#125;&#125; 打印图形类逻辑题]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识总结（二）]]></title>
    <url>%2Fpost%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上篇总结了java的一些数据类型和发展之类，最后介绍了键盘录入对象，此篇继续总结java中的一些基础知识，接上篇。 一、使用Random类产生随机数和上篇结尾介绍的键盘录入对象的格式和步骤类似，随机数的产生也分为三个步骤： 导包：import java.util.Random;(位置还是在package和class中间，快捷键ctrl+shift+o) 创建对象：Random r = new Random(); 接收数据：int num = nextInt(a); 此处有一个整数a，表示产生[0,a)的随机数，不包括aps:若想产生[60,100]的随机数: int num = nextInt(41)+60; 二、数组和其他语言一样，java中也有数组类型，但是定义数组的格式却不同。并且值得强调的是：在js中对同一个数组元素数据类型没有特殊要求，但在java中，要求同一个数组内的元素必须同一种数据类型。 2.1、一维数组:2.1.1、数组的定义： int[] arr 【推荐】 int arr[] 2.1.2、数组的初始化：数组必须经过初始化才能使用，初始化的过程其实就是为数组元素分配内存空间，并赋值的过程。a.动态初始化：只指定数组长度，由系统分配初始值:int[] arr = new int[5]; 即：arr.length=5该初始值为给该数据类型的默认值:基本数据类型的默认初始化：byte short int long → 0 、char → ‘\u0000’、boolean → false、float double → 0.0引用数据类型的默认初始值是：nullb.静态初始化：给定数组元素具体值：int[] arr = new int[]{1,2,3,4,5,6}; 或 int[] arr = {1,2,3,4,5,6}; 2.2、二维数组二维数组其实就是元素为一元数组的数组。A、定义：int[][] arr = new int[m][n]; 或者int[][] arr = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };B、和一维数组的区别： arr.length 表示的不在是数组的长度，而是一元数组的长度 arr[0] 表示的不是第一个元素，而是第一个一维数组的地址值 arr[0][0] 表示的是第一个一维数组的第一个元素 C、二维数组的便利：使用两个循环嵌套123456int[][] arr = new int[m][n];for(int y=0; y &lt; m; y++) &#123; for (int x = 0; x &lt; n; x++) &#123; System.out.print(arr[y][x] + &quot; &quot;); &#125; &#125; 2.3、数组使用常报的错误：java.lang.NullPointerException 空指针异常java.lang.ArrayIndexOutOfBoundsException 数组越界异常 三、方法将实现某一项特定功能的代码封装在一起，方便调用称之为方法，即js中的函数。使用Java方法时,需要明确返回值类型以及参数类型和个数。 3.1、方法定义格式：A、有明确返回值类型的方法：12345678修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) &#123; 函数体; return 返回值;&#125;//求和方法 public static int sum (int a,int b)&#123; return a+b;&#125;; B、无明确返回值类型的方法：1234567891011121314修饰符 void 方法名(参数类型 参数名1，参数类型 参数名2…) &#123; 函数体;&#125;//打印标注数组格式public static void print(int[] arr)&#123; System.out.print(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if(i==arr.length-1)&#123; System.out.println(arr[i]+&quot;]&quot;); &#125;else&#123; System.out.print(arr[i]+&quot;,&quot;); &#125; &#125;&#125; 3.2、方法调用：A、有明确返回值类型（比如返回值为一个数字）的方法的调用有三种方式：直接调用、输出调用、赋值调用;以上求和方法为例： 直接调用：sum(3,4); 无意义，不会有输出 输出调用：System.out.println(sum(3,4));会输出7，但是若想对返回值加以处理，此种方法不是最优解 赋值调用：int sum = sum(3,4);System.out.println(sum);【推荐】 B、无明确返回值类型的方法只有一种调用方式，直接调用。以上打印数组为例调用：12int[] arr = &#123;1,2,3,4,5&#125;;print(arr); //直接输出 [1,2,3,4,5] 3.3、方法重载：定义：在同一个类中，出现方法名相同，参数类型不同、个数不同、或者参数顺序不同的方法，称为方法重载。特点：与返回值类型无关，只看方法名和参数列表；在调用时，虚拟机通过参数列表的不同来区分同名方法。 3.4、不同类型参数传递的相互影响Java方法的参数可以为基本数据类型（byte\short\int\long\float\double\boolean\char）也可以为引用数据类型（类\接口\数组）。A、参数为基本数据类型时，形式参数的改变不影响实际参数的改变。1234567891011121314//因为形参和实参都是局部变量，都是存储在栈中。在栈中开辟两块内存存放main方法（以及里面的实参）、baseData方法（以及里面的形参），//因为两者是独立存在的，所以形参无法影响实参。public static void main(String[] args) &#123; int a = 10; int b = 20; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); // 10 20 baseData(a,b); System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); // 10 20&#125;public static void baseData(int a,int b)&#123; a = b; //a=20 b = a + b; //b=40 System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); // 20 40&#125; B、参数为引用数据类型时，形式参数的改变会影响实际参数的改变。12345678910111213141516171819//由于new出来的东西存在堆内存中，且有特定的地址值，而形参和实参都指向堆内存该地址值，形参改变后，实参也会发生改变。public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5,6,7&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+&quot; &quot;); //1 2 3 4 5 6 7 &#125; changeArr(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+&quot; &quot;); //1 4 3 8 5 12 7 &#125;&#125; public static void changeArr(int[] arr)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]%2==0)&#123; arr[i]*=2; &#125; &#125;&#125; 三、JVM的内存分配Java 程序在运行时，需要在内存中的分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。内存分配包括： 栈：存储的都是局部变量（在方法中定义的） 堆：只要是new后面的东西都存储在堆中（如：数组、对象等） 方法区（面向对象） 本地方法区（硬盘上的东西） 寄存去（给CPU） 注意：放在栈内存里的东西，执行完后马上被垃圾回收；而堆内的东西等到垃圾回收机制空闲时回收。 四、Eclipse断点调试和浏览器断电调试类似，双击Eclipse相应的行数，打断点 → 右键 → Debug as → Java Application → debug视图 → F6下一步注意：有方法调用的时候，要想看到完整的流程，每个方法都要加断点，建议方法进入的第一条有效语句加断点 调节字体、主题等个性化设置在windows – preferences]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识总结（一）]]></title>
    <url>%2Fpost%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[俗话说不会后台的前端不是好全栈^-^,这段时间得空总结下java基础方面的姿势，谨以此篇以及之后的系列文章总结。 一、Java语言平台有关文档和书籍上，关于语言发展史有长的篇幅介绍。简而言之，Java有三种语言平台： JavaSE标准版，开发桌面应用 JavaME小型版，开发移动端，现被Android替代 JavaEE企业版，针对web应用开发，现在一般说java工程师指的就是就是这个版本。 二、JVM,JRE,JDK 及配置环境变量2.1、JVM,JRE,JDK JVM(java virtual machine)：java虚拟机，java程序需要运行在虚拟机上，不同平台有自己的虚拟机，java的跨平台性主要依赖于java各个平台的虚拟机。 JRE(ava runtime environment)：java运行环境，包括JVM和java程序所需的核心类库等。 JDK(java development kit)：java开发工具包，包括JRE和java开发工具。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等。 JDK提供给Java开发人员使用，若只是想在电脑中运行一个Java程序，只需要装JRE即可。三者关系JDK &gt; JRE &gt; JVM ，开发中只需要电脑中装有JDK即可。JDK下载地址注：JDK安装时建议不要安装到C盘，且安装的文件名千万不要为中文和带有空格！ 2.2、配置环境变量：电脑中装好JDK后，需要配置环境变量，因为开发中项目的位置不可能固定在jdk安装的bin目录下。步骤：1、配置JAVA_HOME：我的电脑右键属性 → 高级系统设置 → 环境变量 → 系统环境变量 → 新建：变量名JAVA_HOME、变量值上述jdk安装的目录 → 确定2、配置PATH：我的电脑右键属性 → 高级系统设置 → 环境变量 → 系统环境变量 → 找到PATH → 编辑 → 新建：%JAVA_HOME%/bin → 确定3、验证环境变量的配置：在doc命令中输入java和javac 三、关键字、标识符、变量常量、运算符3.1、关键字和js一样，关键字是指被赋予特殊含义的单词,在编辑器中通常有高亮显示，且都为小写。比如：public static void if class true false int…. 3.2、标识符和其他语言一样，用于去名字，包括Unicode编码(大小写字母，数字，汉字-最好不要用)、下划线_、美元符号$。注意使用标识符时，不能以数字开头，不能使用关键字。 java中标识符使用规则： 包的命名：全部小写，多级用.分割，一般是公司网站网址倒着写，比如：com.uhoem 类的命名：每个单词的首字母都要大写，比如：HelloWorld 变量和方法命名：从第二个单词开始首字母大写：比如findMaxNumber 常量的命名：每个单词都要大写，多个单词用下划线分割： MAX_NUMBER 3.3、变量常量和JS不同，Java是强类型语言。所以在变量和常量方面有很大不同：常量包括：整数常量、浮点常量、字符常量、字符串常量、布尔型常量、空常量null变量：见下面数据类型。 3.4、运算符： 算数运算符：+ - * / % ++ – 赋值运算符：= += -= *= /= %= 逻辑运算符：&amp; | &amp;&amp; || ^ ! 关系运算符：&gt; &gt;= &lt; &lt;= == != 三元运算符：关系表达式 ? 表达式1 : 表达式2;注意：a.在java中，算数运算符中的/，以下方法，输出的是2，在js中输出2.5，因为java是强类型语言，两个int数运算得到的还是int数。12345int a = 10;int b = 4;System.out.print(a/b);//如果想要得到小数的结果,需要浮点数参与运算//System.out.print(1.0F*a/b); b.和js不同，在java中负数也可以取模%，在js中一旦除数或者被除数为负数，得到的结果都是-0，在java中负数参与取模运算，结果的正负号和被除数保持一致；1234567891011//int a = -8;//int b = 14;//System.out.println(b%a); // 14%（-8） = 6 //int a = -8;//int b = -14;//System.out.println(b%a); // (-14)%(-8) = -6 int a = 8;int b = -14;System.out.println(b%a); // (-14)%8 = -6 c.和js一样，算术运算符中的++和–前置和后置，在做普通运算时效果都是起到自增或自减的操作，但是在参与到其他运算时有不同，比如：12345int x = 4; // x=3 x=2 int y = (--x)+(x--)+(x*10); // y= 3 + 3 + 20 ++,-- 后置时，只会改变本身的值，不会对被赋值的y起到影响 System.out.println(&quot;x = &quot; + x + &quot;,y = &quot; + y); //x=2,y=26 d.赋值运算符在使用时，默认发生了强制类型转换。12byte a = 3;byte b+=a; //等价于 byte b = a + b; 原本会报错，但是赋值运算符默认发生了强制类型转换 byte b = (byte)(a+b); e.逻辑运算符中&amp;&amp;和&amp;、||和|在判断的时候，结果都一致，前者遇false则false,后者遇true则true,但是双个具有短路效果。即&amp;&amp;的左边为false时，右边不执行；||左边为true时，右边不执行。123456789101112int x = 1,y = 1;if(x++==2 &amp; ++y==2) &#123; //false &amp; true x =7;&#125;System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); //x=2,y=2int a = 1,b = 1;if(a++==2 &amp;&amp; ++b==2) &#123; //false &amp;&amp; true(但是此时右边不执行) a =7;&#125;System.out.println(&quot;a=&quot;+a+&quot;,b=&quot;+b); //a=2,b=1 f.逻辑运算符中异或^ ,规则为：相同为false,不同为true,即有false和true才为trueg.逻辑运算符合关系运算符得到的结果均为boolean类型 三、数据类型以及强隐式转换3.1、基本数据类型A、整数类型：byte、short、int（默认）、long、分别占1,2,4,8个字节；由于默认整数类型为int，所以在声明long类型时，要在后面加上L或l(建议采用大写)：long a = 999L; B、浮点类型：float、double（默认）、分别占4、8个字节；尽管float和int一样占4个字节，但是float远大于int类型；由于默认浮点类型为double，所以在声明float类型时，要在后面加上F或f:float a = 1.02F; C、字符类型：char 占2个字节，char类型在参与运算时，可以转换为int类型，在ASC码表中，每个字符都有对应的数字，范围是0-65535。比如：’A’ → 65；’a’ → 97；’0’ → 48；（记住这三个常用的，可以往后推，都是连续的）汉字也有对应的数字：char a = ‘我’;System.out.println((int) a);即可得到对应数字 D、布尔类型：true、false理论上占1/8个字节,因为只有两个值，相当于开关的开合，也有人认为占1个字节，没有明确规定 每种数据类型所占的内存空间，见下第六点。 3.2、基本数据类型的强隐式转换：简而言之，在参与运算时，小的必须要做隐式转换为大的：byte,short,char → int → long → float → double;赋值运算符在使用时，默认发生了强制类型转换;强制转换格式：byte a = byte(b+c);通常不建议用，因为可能会损失精度 3.3、引用数据类型类、接口、数组。区别：a.储存的位置不同：引用数据类型在被创建时，它以特殊的方式(类似C指针)指向对象实体（具体的值），这类变量声明时不会分配内存，只是在栈上存储了一个内存地址，然后由栈上面的引用指向堆中对象的地址，而对象的具体信息都存储在堆内存上。基本数据类型在被创建时，java就会立刻分配给他内存空间，数值直接存储在栈上。b.初始化未赋值结果不同：基本数据类型在初始化时，必须要赋具体值，应用数据类型初始化时，可以为null 四、执行语句和js一样，Java中也有流程控制语句。分为顺序结构（从上到下，从左到右执行）、循环结构（if,while,do…while）、选择结构（if(){},switch语句）。还有跳出控制语句continue和break格式和js相同，值得注意和强调的是：1、switch语句中，表达式的只能为byte,short,int,char JDK5以后可以是枚举 JDK7以后可以是字符串 类型，case进行匹配，并且break;不能省略，否则会因为case的穿透性引起误差：1234567891011121314public static void main(String[] args) &#123; int x = 2,y=3; switch(x) &#123; default: y++; //default 无论在哪里都是最后执行，没有找到匹配后，走这里 y=4,没有break; case 3: //继续执行，已经匹配完毕后，不再匹配，case的穿透性 y=5,遇break；结束 y++; break; case 4: y++; &#125; System.out.println(&quot;y=&quot;+y); //y=5&#125; 2、循环结构中，do…while是先执行在判断条件是否符合，所以至少会执行一次。if和while可以相互转换3、死循环的通常写法是while(true){};需要break;终止循环4、break和continue跳出控制语句只能在循环中使用，break还可以在switch语句中使用，离开使用场景无效果。前者执行后，直接跳出循环，后面不执行了。后者可用于筛选一些不满足条件，结束一次循环，继续下一次的循环 五、键盘录入对象把数据改进为键盘录入，提高程序的灵活性步骤： 导包，在package和class中间导入（import java.util.Scanner;） 创建对象：Scanner sc = new Scanner(System.in); 接收数据：int num = sc.nextInt(); 六、内存转换和常见DOS命令6.1、内存转换：1byte(B) = 8 bit(b); 比特位1KB = 1024B;1MB = 1024KB;1GB = 1024MB;1TB = 1024GB;1PB = 1024TB; 可以将一个比特位看做一个开关，值为0和1，1byte的内存空间为：2^8,由于正负号要占一个比特位，所以java中基本数据类型的内存空间为：byte ：-2^7 - 2^7 -1(减去1)；short：-2^15 - 2^15 -1；int ：-2^31 - 2^31 -1；long ：-2^63 - 2^63 -1； float：-3.403E38 - 3.403E38-1;(科学技术法，所以内存远大于int和long类型，不需要记住具体范围)double：-1.798E308 - 1.798E308-1;char：表示一个字符，即两个字节可以表示一个汉字boolean:只有两个值，true、false 6.2、常见DOS命令 D: D盘符切换 cd test 进入test目录 cd.. 回退 cd\ 回到根目录 dir 列举该目录下的所有文件和文件夹 cls 清屏 exit 退出]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[侧边栏快捷入口导航]]></title>
    <url>%2Fpost%2F%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%BF%AB%E6%8D%B7%E5%85%A5%E5%8F%A3%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[此次网站改版时，有个页面专题商品很多，需要做一个快捷导航，点击对应项窗口滚动到对应专题位置。该案例中有两个事件，鼠标点击和窗口滚动事件； 两个事件效果相同：导航区选中部分高亮，窗口滚动到指定区域；最先想到的是:用a标签添加锚点跳转对应点的方法，这样虽然实现了串口滚动精确定位，但选中却没有高亮。 效果如下： 下面总结最终的解决方案： DOM结构123456789101112131415161718&lt;header class=&quot;header blank&quot;&gt;&lt;/header&gt;&lt;div class=&quot;aside-nav&quot;&gt; &lt;span class=&quot;turnTop&quot;&gt;上一专题&lt;/span&gt; &lt;ul class=&quot;turnList&quot;&gt; &lt;li class=&quot;current&quot;&gt;专题一&lt;/li&gt; &lt;li&gt;专题二&lt;/li&gt; &lt;li&gt;专题三&lt;/li&gt; &lt;li&gt;专题四&lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;turnBottom&quot;&gt;下一专题&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;section module1&quot;&gt;专题一&lt;/div&gt; &lt;div class=&quot;section module2&quot;&gt;专题二&lt;/div&gt; &lt;div class=&quot;section module3&quot;&gt;专题三&lt;/div&gt; &lt;div class=&quot;section module4&quot;&gt;专题四&lt;/div&gt;&lt;/div&gt;&lt;footer class=&quot;footer blank&quot;&gt;&lt;/footer&gt; 事件分析： 窗口滚动到一定高度时，侧边导航栏才出现，默认隐藏。 滚动窗口时，浏览至相应专题时侧边导航栏对应专题名要高亮 点击侧边专题名时，窗口要滚动只对应的地方 点击上一专题/下一专题 时，无论页面处于那一专题都要按照上/下顺序 滚动 第一版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script&gt;$(document).ready(function()&#123; //定以一个数组 存放各专题距离窗口顶部的高度，并非各个专题本身的高度 数组索引 = 专题索引 var l1,l2,l3; l1=$(&quot;.module1&quot;).height() + $(&quot;.header&quot;).height(); l2=l1 + $(&quot;.module2&quot;).height(); l3=l1 + l2 + $(&quot;.module3&quot;).height(); //console.log(l1,l2,l3); var arr=[0,l1,l2,l3]; var list=$(&apos;.turnList li&apos;); //1------窗口滚动事件 $(window).scroll(function()&#123; var t=$(&apos;body&apos;).scrollTop() || $(document).scrollTop(); //console.log(t); //滚动到280px处 侧边导航栏出现 if(t &gt; 280)&#123; $(&apos;.aside-nav&apos;).fadeIn(); &#125;else&#123; $(&apos;.aside-nav&apos;).fadeOut(); &#125; //循环数组内所有高度 当窗口滚动到数组内某数值时，记录该数值索引值（即对应专题的索引），实现选中高亮 for(var s=0;s&lt;arr.length;s++)&#123; if(t&gt;=arr[s])&#123; list.eq(s).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;); &#125; &#125; &#125;); //2------点击事件 $(&apos;.aside-nav ul li&apos;).click(function()&#123; $(&apos;body,html&apos;).animate(&#123;&apos;scrollTop&apos;:arr[$(this).index()]&#125;,300); &#125;); //3------上下点击 var num=0; $(&quot;.turnBottom&quot;).click(function()&#123; num++; if(num&gt;list.length - 1)&#123; num=0; &#125; list.eq(num).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); $(&apos;body,html&apos;).animate(&#123;&apos;scrollTop&apos;:arr[num]&#125;,300); &#125;); $(&quot;.turnTop&quot;).click(function()&#123; num--; if(num&lt;0)&#123; num=list.length - 1; &#125; list.eq(num).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); $(&apos;body,html&apos;).animate(&#123;&apos;scrollTop&apos;:arr[num]&#125;,300); &#125;)&#125;)&lt;/script&gt; 以上代码貌似很好的解决了所有问题，但经过事实证明，还是存在以下两个问题： 当滚动到最后一个菜单项时，会发现并没有选中，而且点击上下是的顺序乱掉了 所有专题都是后台可编辑的，可能会有新增或者删减的状态…我们不可能将所有的高度列举出来。 完整代码 当最后一项的高度 + 底部的高度 &lt;= 窗口的高度时 此时会出现第一个问题 当最后一项的高度 + 底部的高度 &gt; 窗口的高度时 则正常显示，故要分类讨论。 对于以上高度列举可以发现一定规律，下一专题 = 所有前面专题的叠加 + 自身的高度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;侧边导航栏快捷入口&lt;/title&gt; &lt;style&gt; *&#123;margin:0;padding:0;box-sizing: border-box;&#125; .blank&#123;background: #000;height:50px;&#125; .aside-nav &#123;position: fixed;z-index: 999;right: 0;top: 39%;&#125; .aside-nav li, .aside-nav span &#123;width: 72px;height: 50px;background-color: rgba(0, 0, 0, 0.6);color: #fff; font-size: 12px;margin-bottom: 2px;cursor: pointer;line-height: 50px;display: block;text-align: center; &#125; .aside-nav li.current, .aside-nav span.current &#123;color: #ee7800; &#125; .section&#123;width:100%;height:800px;background-color:aquamarine;line-height:200px;font-size:40px;text-align: center;&#125; .section:nth-child(2n)&#123;background-color:#f0f0f0;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;header class=&quot;header blank&quot;&gt;&lt;/header&gt;&lt;div class=&quot;aside-nav&quot;&gt; &lt;span class=&quot;turnTop&quot;&gt;上一专题&lt;/span&gt; &lt;ul class=&quot;turnList&quot;&gt; &lt;li class=&quot;current&quot;&gt;专题一&lt;/li&gt; &lt;li&gt;专题二&lt;/li&gt; &lt;li&gt;专题三&lt;/li&gt; &lt;li&gt;专题四&lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;turnBottom&quot;&gt;下一专题&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;section module1&quot;&gt;专题一&lt;/div&gt; &lt;div class=&quot;section module2&quot;&gt;专题二&lt;/div&gt; &lt;div class=&quot;section module3&quot;&gt;专题三&lt;/div&gt; &lt;div class=&quot;section module4&quot; style=&quot;height:200px&quot;&gt;专题四&lt;/div&gt;&lt;/div&gt;&lt;footer class=&quot;footer blank&quot;&gt;&lt;/footer&gt;&lt;script src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; var arr = new Array(); var length = $(&quot;.section&quot;).length; var Height = window.innerHeight; arr[0]=0; //数组第一项一定为0，默认选中第一个菜单 for(var i=1;i&lt;length;i++)&#123; if(i==1)&#123; arr[i]=$(&quot;.module1&quot;).height() + $(&quot;.header&quot;).height(); &#125;else&#123; arr[i] =arr[i-1] + $(&quot;.module&quot;+i).height(); //最后一项 if(i==length-1)&#123; if($(&quot;.module&quot;+(i+1)).height()+$(&quot;.footer&quot;).height() &gt; Height)&#123; arr[i] =arr[i-1] + $(&quot;.module&quot;+i).height(); &#125;else&#123; //画图便明了 如果最后一项和底部的高度小于屏幕的高度则倒数第二项也会看到一部分； //我们要得到倒数第二项上滑上去的部分+之前叠加的部分； //[之前叠加的部分,总和]即为最后一项的高亮区间 arr[i]=arr[i-1] + ($(&quot;.module&quot;+i).height()+$(&quot;.module&quot;+(i+1)).height()+$(&quot;.footer&quot;).height()-Height); console.log(arr[i]); &#125; &#125; &#125; &#125; var list=$(&apos;.turnList li&apos;); $(window).scroll(function()&#123; var t=$(&apos;body&apos;).scrollTop() || $(document).scrollTop(); //console.log(t); for(var s=0;s &lt; arr.length;s++)&#123; if(t&gt;=arr[s])&#123; list.eq(s).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); &#125; &#125; &#125;); //点击事件 list.click(function()&#123; $(&apos;body,html&apos;).animate(&#123;&apos;scrollTop&apos;:arr[$(this).index()]&#125;,300); &#125;); //上下点击 var num=0; $(&quot;.turnBottom&quot;).click(function()&#123; num++; if(num&gt;list.length - 1)&#123; num=0; &#125; list.eq(num).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); $(&apos;body,html&apos;).animate(&#123;&apos;scrollTop&apos;:arr[num]&#125;,300); &#125;); $(&quot;.turnTop&quot;).click(function()&#123; num--; if(num&lt;0)&#123; num=list.length - 1; &#125; list.eq(num).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); $(&apos;body,html&apos;).animate(&#123;&apos;scrollTop&apos;:arr[num]&#125;,300); &#125;)&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[font总结]]></title>
    <url>%2Fpost%2Ffont%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[letter-spacing字间距属性用于定义字间距，所谓字间距就是字符与字符之间的空白。其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing单词间距属性用于定义英文单词之间的间距，对中文字符无效。和letter-spacing一样，其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing和letter-spacing均可对英文进行设置。不同的是letter-spacing定义的为字母之间的间距，而word-spacing定义的为英文单词之间的间距。 text-decoration文本装饰，none：没有装饰（正常文本默认值）、underline：下划线、overline：上划线、line-through：删除线。 使用white-space属性可设置空白符的处理方式，normal：常规（默认值）、文本中的空格、空行无效，满行（到达区域边界）后自动换行、pre：预格式化，按文档的书写格式保留空格、空行原样显示；nowrap：空格空行无效，强制文本不能换行，除非遇到换行标记。内容超出元素的边界也不换行，若超出浏览器页面则会自动增加滚动条。（常和overflow:hidden一起用） word-break自动换行：normal 使用浏览器默认的换行规则、break-all 允许在单词内换行；（常用）、keep-all 只能在半角空格或连字符处换行。 word-wrap ：（长单词或 URL 地址换行到下一行），normal 只在允许的断字点换行（浏览器保持默认处理）、break-word 在长单词或 URL 地址内部进行换行。（常用） text-overflow：（一般与overflow:hidden何用;），clip :不显示省略标记（…），而是简单的裁切、ellipsis : 当对象内文本溢出时显示省略标记（…） 常见可继承的属性：color、cursor、font-size、font-family、font-style、font-weight、letter-spacing、white-space、word-spacing、line-height、list-style、text-align、text-indent…]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟键盘遇到的坑]]></title>
    <url>%2Fpost%2F%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前几天在做触屏版应用的时候，有碰到一个需求，将输入框固定在底部，当输入框聚焦时，弹出虚拟键盘，输入框跟随虚拟键盘上移，失去焦点时，输入框收回。wait、wait…WTF,这不是在原生应用中会遇到的场景嘛？ 本以为用个固定定位就ok啦，没想到做出来的效果各种机型表现都不同买就是没有见到预期的效果。常见的就是：获取焦点弹出系统虚拟键盘时，挡住input。 网上有很多解决方式，比如等，下面总结一个此次项目中用到的方法。 代码除评论框以外的元素都放在一个父元素，这里父元素是main。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;style&gt;.fixBottom&#123;position:fixed;bottom:0;left:0;&#125;.fixBottom.up&#123;position:static;margin:2rem auto;height:auto;&#125;.fixBottom textarea,.fixBottom input&#123;/*此处写失去焦点时的状态*/&#125;.fixBottom input.cancel&#123;display: none;&#125;/*按钮动态切换flex改变样式*/.fixBottom input.cancel.flex&#123;&#125;.fixBottom input.flex&#123;&#125;&lt;/style&gt;&lt;div class=&quot;pages&quot;&gt; &lt;div id=&quot;other&quot;&gt;其他内容&lt;/div&gt; &lt;form class=&quot;fixBottom&quot;&gt; &lt;textarea name=&quot;&quot; placeholder=&quot;在此输入您的回复&quot; class=&quot;falseReply&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; class=&quot;btns&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;取消&quot; class=&quot;btns cancel&quot;/&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; //虚拟键盘 var $all=$(&apos;.fixBottom&apos;); var $input = $(&apos;.falseReply&apos;); var originHieght; // 页面呼出键盘前的位置 $input.on(&apos;focus&apos;, function () &#123; // 纪录页面位置 originHieght = $(window).scrollTop(); $(&apos;#other&apos;).hide(); // 设置延时回到顶部，解决ios错位问题 window.setTimeout(function () &#123; $all.addClass(&apos;up&apos;); $(&apos;.btns&apos;).addClass(&apos;flex&apos;); $(window).scrollTop(0); &#125;, 100); &#125;); $input.on(&apos;blur&apos;, function () &#123; $all.removeClass(&apos;up&apos;); $(&apos;.btns&apos;).removeClass(&apos;flex&apos;); $(&apos;#other&apos;).show(); // 回到原始位置 $(window).scrollTop(originHieght); &#125;); $(&apos;.cancel&apos;).on(&apos;click&apos;, function () &#123; $input.blur(); &#125;);&#125;);&lt;/script&gt; 思想 将底部固定的输入框和页面其他元素置于同级 输入框聚焦时隐藏页面其他元素、将输入框从固定定位设置为静态定位、改变输入框按钮样式、 失去焦点时变为正常时候的样子。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>WebApp</tag>
        <tag>虚拟键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS七个数值单位]]></title>
    <url>%2Fpost%2FCSS%E4%B8%83%E4%B8%AA%E6%95%B0%E5%80%BC%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[CSS的度量单位其实有很多，常见的也是用的最多的是px，随着流式布局和自适应布局的流行，一些测量单位也在增加。比如今天介绍的rem、em、vh、vw、vmin、vmax、ex、ch刚开始出来时，很多浏览器不支持这种属性。时至今日，主流的浏览器也在支持这类度量单位。今天借以总结： rem &amp; em这两个度量单位我们都很熟悉了，基本思想都是以父元素为标准，增加或减少一定比例。前者是以根节点（root即html或者body）为标准，后者是以直系父节点为标准。 两者有很大的区别，如果body的字体大小为14px，结构为 body&gt;div&gt;div&gt;div 三个嵌套的div元素中的字体大小均为1.2em，结果会逐步叠加，第三个div的大小为24.192px。如果为1.2rem，则三个div的字体大小均为16.8px。 用rem用做响应式布局中，要在公共样式文件中使用媒体查询来设置不同分辨率下body的字体大小，以达到效果。假如设计师提供的UI图为750*1334，我们可以以此为标准，设置为50px或者100px（主要为方便计算，以及转化后数值不至于太大或大小）。其他分辨率下，按比例设置。 12345678910111213141516171819202122232425262728/*media Query*/@media only screen and (min-width: 320px) and (max-width: 359px) &#123; html&#123;font-size:22px;&#125;&#125;@media only screen and (min-width: 360px) and (max-width: 374px) &#123; html&#123;font-size:25px;&#125;&#125;@media only screen and (min-width: 375px) and (max-width: 479px) &#123; html&#123;font-size:26px;&#125;&#125;@media only screen and (min-width: 480px) and (max-width: 639px) &#123; html&#123;font-size:33px;&#125;&#125;@media only screen and (min-width: 640px) and (max-width: 719px) &#123; html&#123;font-size:44px;&#125;&#125;/*以此为标准*/@media only screen and (min-width: 720px) and (max-width: 749px) &#123; html&#123;font-size:50px;&#125;&#125;@media only screen and (min-width: 750px) and (max-width: 769px) &#123; html&#123;font-size:52px;&#125;&#125;/*最大适配尺寸*/@media only screen and (min-width: 770px) &#123; html&#123;font-size:55px;&#125; html,body&#123;width:770px;&#125;&#125; vh &amp; vw【推荐使用】vh和vw这两个单位是实际用途中还是比较多的，之前虽然有接触过，但是因为很多浏览器不支持，也就没有过多的关注。但现在，很多浏览器已经支持了，IE9+、Firefox19以上、Chrome20以上… 此处安利一个网站，可以查询CSS属性各大浏览器的兼容情况。戳这里 vh和vw定义：1%的视口高度、宽度。传统的响应式做法中宽度可以用百分比去表示，但是仅仅是继承直系父节点的百分比。而且高度时没办法继承的。vh和vw就很好的解决了这个问题。两者都是以视口即窗口的物理宽高为参照。假设浏览器高度950px, 1 vh = 9.5 px。设置为100vh、100vw则为满屏的宽高。 vmin &amp; vmaxvmin和vmax是关于视口高度和宽度两者的最小或者最大值。例如，如果浏览器的宽高分别为1100px和700px，则1vmin=7px，1vmax=11px。具体应用场景很少。 ex &amp; chex和ch是基于字体的度量单位，依赖于设定的字体。单位ch通常被定义为数字0的宽度。单位ex定义为当前字体的小写x的高度或者1/2的em。很多时候，它是字体的中间标志。很少用到，主要用于板式微调，比如上标下标（sup,sub）精确位置。不推荐使用，px更精确。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[compass总结]]></title>
    <url>%2Fpost%2Fcompass%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前面已提及sass是css的预处理器开发工具，而compass相当于sass的工具库。想想jQuery与javascript的关系，就明了了。用compass我们可以很轻松的书写css3属性、制作精灵图等，compass里也设定了很多混合器、模块和函数等供我们调用。compass官网中提到Compass is an open-source CSS Authoring Framework。总而言之，使用compass会让css更加精简和方便。 一、安装与创建compass项目由于compass和sass一样都是基于Ruby开发，倘若电脑里已安装sass则不必在安装Ruby，直接执行以下命令安装：（windows下）12gem install compasscompass create compass-test //初始化compass项目 如果你跟我一样在2016年12月之前安装的Ruby，会报如下错误：12ERROR: Could not find a valid gem &apos;compass&apos; (&gt;= 0), here is why: Unable to download data from https://rubygems.org/ - SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https://rubygems.org/specs.4.8.gz) 则需要版本升级 二、compass应用官网提供了很多compass方法，只总结常用几种。compass core提供七种，分别是Browser Support、reset、layout、CSS3、helpers、Typography、utilities。 浏览器支持：网页初始化：@import &quot;compass/reset&quot;【推荐】layout:【不建议使用】@import &quot;compass/layout&quot;背景栅格化、footer固定在网页地端、指定子元素占满父元素的空间 CSS3:【推荐】@import &quot;compass/css3&quot;;compass内置了许多CSS3混合器，以便使用，不用将统一个属性写多次以兼容各个浏览器 Helper函数Compass还提供一系列非常有用函数，比如image-width()和image-height()返回图片的宽和高等 Typography为排版提供许多混合器，如链接颜色，列表板式，文字相关属性（换行，省略。。）等等 utilities提供了很多方法，比如颜色、清除浮动、浏览器兼容、表格、精灵图等等，详细见文档，以下仅总结常用且方便的： 使用compass制作精灵图：1、将所有icon放在同一个文件（假设文件夹名为icons）加下，要求宽高比为1且格式为PNG2、在.scss文件下加入123@import &quot;compass/utilities/sprites&quot;;@import &quot;icons/*.png&quot;;@include all-icons-sprites; //icons为文件夹名称 3、调用 清除浮动1234import &quot;compass/utilities/&quot;; .clearfix &#123; @include clearfix; &#125; 三、编译compass同sass一样有四种编译风格，执行一下编译命令后会将sass文件夹的文件编译成css文件，保存于stylesheets目录下。 编译方式（两种）1、使用命令行 compass compile默认编译会有大量注释 compass compile --output-style compressed //使用–output-style参数+编译风格2、改变配置文件config.rb中的编译风格12output_style = :compressed再执行compass compile 3、通过指定environment的值（:production或者:development），智能判断编译模式。12environment = :development output_style = (environment == :production) ? :compressed : :expanded 4、用compass watch监控文件改动，自动编译【常用】]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Compass</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass总结]]></title>
    <url>%2Fpost%2Fsass%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[写在前面去年用了一些新东西，自后会相继更新几篇文章总结回顾，这是一篇有关sass的总结。 sass是css的预处理器开发工具。基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 安装sassSass是基于ruby语言写的。必须要先安装ruby,然后再安装sass。 安装ruby方法：Window 及Linux平台安装方法 安装完后，在开始菜单中，找到刚才我们安装的ruby，打开【Start Command Prompt with Ruby】然后再命令行中输入：1gem install sass 其他安装方法：戳这里 使用sass文件后缀名 后缀名为sass: 语法中不能含有大括号和分号； 后缀名为scss:（推荐使用） 与css文件格式差不多；使用大括号和分号； 基本用法常用命令行：1234567891011121314151617181920212223242526271.安装：gem install sass2.运行：sass input.scss output.css //编译成.css文件sass input.scss //在命令行中输出css格式代码3.编译成css的四种风格：nested （缩进、嵌套）expanded（扩展）compact（简洁）compressed （压缩） sass --style compressed test.sass test.css 4.监听改动（部分）：sass --watch input.scss:output.css5.监听文件夹：sass --watch app/sass:public/stylesheets6.sass、scss互换：# 将 Sass 转换为 SCSS：$ sass-convert style.sass style.scss# 将 SCSS 转换为 Sass：$ sass-convert style.scss style.sass 变量SASS允许使用变量，所有变量以$开头。如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。如：1234$side : left;.rounded &#123;border-#&#123;$side&#125;-radius: 5px;&#125; 变量名用下划线和中划线均可，两种用法互相兼容，用中划线声明的变量用下划线也可引用；申明多个变量时 用 nth(变量名，排名) 来引用 计算变量与变量之间的运算只有乘除 * /12345body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%;&#125; 嵌套 SASS允许选择器嵌套 123div &#123; hi &#123;color:red;&#125; → div h1&#123;color:red;&#125;&#125; 属性也可以嵌套比如border-color属性，可以写成(注意，border后面必须加上冒号。) 12345p &#123; border: &#123; color: red;width:1px; &#125;&#125; 父选择器的标识符&amp;在使用a:hover伪类时若按照以下方式，会出现空格 （sass在解开一个嵌套规则时会把.father通过一个空格 链接到子选择器的前边）；所以向下面这种方式.father里的所有元素hover时都变色； 123.father a &#123; :hover &#123;color: #ffb3ff;&#125; → .father a :hover&#123;color:#ffb3ff;&#125;&#125; 解决方法：使用特殊选择器&amp;1.father a&#123;&amp;:hover&#123;color:#ffb3ff;&#125;&#125; Tips:&amp;的位置很灵活，可以选择.father前后的元素：1234567#content aside &#123; color: red; body.ie &amp; &#123; color: green &#125;&#125;/*编译后*/#content aside &#123;color: red&#125;;body.ie #content aside &#123; color: green &#125; 群组选择器的嵌套123.container&#123; h1,h2,h3&#123;font-weight:normal;&#125;&#125; 注释方式：(使用英文注释否则会报错) 标准注释 / comment / ，会保留到编译后的文件。（常用） 单行注释 // comment，只保留在SASS源文件中，编译后被省略。 在/!重要注释!/，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 导入sass文件@import “文件名” （不需要写后缀名）； 有些sass文件用于导入，不希望为每个这样的局部文件单独地生成一个css文件。对此，sass用一个特殊的约定来解决，即以“_”开头，当导入该局部文件时，可以省略开头下划线；默认变量值：反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值；若没有被重新定义，则使用默认变量值（eg:$fancybox-width: 400px !default;） 代码重用继承：(@extend)SASS允许一个选择器，使用@extend命令继承另一个选择器。123456.class1 &#123; border: 1px solid #ddd;&#125;.class2&#123; @extend .class1;font-size:120%;&#125; 跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性；生成css体积更小； 当给同个元素添加相同属性的样式时，继承遵从权重规则，若权重相同定义在后的规则胜出。 继承只会在生成css时复制选择器；而不会复制属性值；但是如果你不小心，可能会让生成的css中包含大量的选择器复制。避免这种情况出现的最好方法就是不要在css规则中使用后代选择器（比如.foo .bar）去继承css规则。如果你这么做，同时被继承的css规则有通过后代选择器修饰的样式， 生成css中的选择器的数量很快就会失控：12.foo .bar &#123; @extend .baz; &#125;.bip .baz &#123; a: b; &#125; 在上边的例子中，sass必须保证应用到.baz的样式同时也要应用到.foo .bar（位于class=”foo”的元素内的class=”bar”的元素）。 例子中有一条应用到.bip .baz（位于class=”bip”的元素内的class=”baz”的元素）的css规则。 当这条规则应用到.foo .bar时，可能存在三种情况，如下代码:1234567891011121314151617&lt;!-- 继承可能迅速变复杂 --&gt;&lt;!-- Case 1 --&gt;&lt;div class=&quot;foo&quot;&gt; &lt;div class=&quot;bip&quot;&gt; &lt;div class=&quot;bar&quot;&gt;...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- Case 2 --&gt;&lt;div class=&quot;bip&quot;&gt; &lt;div class=&quot;foo&quot;&gt; &lt;div class=&quot;bar&quot;&gt;...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- Case 3 --&gt;&lt;div class=&quot;foo bip&quot;&gt; &lt;div class=&quot;bar&quot;&gt;...&lt;/div&gt;&lt;/div&gt; 为了应付这些情况，sass必须生成三种选择器组合（仅仅是.bip .foo .bar不能覆盖所有情况）。 如果任何一条规则里边的后代选择器再长一点，sass需要考虑的情况就会更多。 实际上sass并不总是会生成所有可能的选择器组合，即使是这样，选择器的个数依然可能会变得相当大，所以如果允许，尽可能避免这种用法。 可以放心地继承有后代选择器修饰规则的选择器（不管后代选择器多长），但有一个前提就是，不要继承有后代选择器。 定义混合器(@Mixin) 混合器Mixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。使用@include命令，调用这个mixin。 123456789101112131415161718@mixin rounded-corners &#123;-moz-border-radius: 5px;-webkit-border-radius: 5px;border-radius: 5px;&#125;notice &#123;background-color: green;border: 2px solid #00aa00;@include rounded-corners;&#125;//sass最终生成：.notice &#123;background-color: green;border: 2px solid #00aa00;-moz-border-radius: 5px;-webkit-border-radius: 5px;border-radius: 5px;&#125; 混合器传参 1234567@mixin link-colors($normal,$hover,$active)&#123;a&#123;color:$normal;&#125;a:hover&#123;color:$hover;&#125;a:active&#123;color:$active;&#125;&#125;//调用a&#123;@include link-colors(blue, red, green);&#125; 当定义了混合器后调用时可能会忘记参数的意义和顺序，可以不按照参数排列的顺利，只要一个都不少即可。 颜色函数SASS提供了一些内置的颜色函数，以便生成系列颜色。1234lighten(#cc3, 10%) // #d6d65c //变亮darken(#cc3, 10%) // #a3a329 //变暗grayscale(#cc3) // #808080 //灰度级complement(#cc3) // #33c //补充 高级用法if条件语句12345@if lightness($color) &gt; 30% &#123;background-color: #000;&#125; @else &#123;background-color: #fff;&#125; 循环语句12345@for $i from 1 to 10 &#123;.border-#&#123;$i&#125; &#123;border: #&#123;$i&#125;px solid blue; &#125;&#125; 自定义函数123456@function double($n) &#123;@return $n * 2;&#125;#sidebar &#123;width: double(5px);&#125;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo配置文件备份总结]]></title>
    <url>%2Fpost%2Fhexo%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[个站搭建起来后，在家里和公司都会有更新。但是换了电脑后，因为在原来电脑上面的修改如果没有备份云盘的话，很多东西都丢失了。如果每次在修改后压缩备份在download的替换，很麻烦，而且容易忘记。在网上找了很多资料formulahendry童鞋的方案给了我思路，借以总结。 利用GitHub托管源码执行git push把源文件托管GitHub(Source Repo)，所以流程变成了：123456789//step 1 ：将修改的文件部署至网站$ hexo g -d//step 2 : 将源码托管至GitHub$ git status → $ git add . → $ git commit -m &quot;modify&quot; → $ git push//step 3 : 换电脑后更新远程代码到本地仓库$ git remote -v //查看远程仓库$ git fetch origin master //从远程获取最新版本到本地$ git log -p master.. origin/master //比较本地的仓库和远程参考的区别`$ git merge origin/master //把远程下载下来的代码合并到本地仓库，远程的和本地的合并 上述过程依然麻烦…. 持续集成，一键发布对于前端工程化自动化，了解甚少，也是今后努力的方向，只是能理解，却不能讲述背后的流程。直接搬砖啦 持续集成（Continuous integration）：当有新的change push到Source Repo时，自动构建生成最新的静态网站。公司项目中我们架构师有用到的是Jenkins，本站根据教程使用的AppVeyor AppVeyor建立CI步骤1、使用GitHub登录并添加源码项目2、在项目根目录添加appveyor.yml文件【注意缩进不能省】123456789101112131415161718192021222324252627282930clone_depth: 5environment: access_token: secure: [Your GitHub Access Token]install: - node --version - npm --version - npm install - npm install hexo-cli -gbuild_script: - hexo generateartifacts: - path: publicon_success: - git config --global credential.helper store - ps: Add-Content &quot;$env:USERPROFILE\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot; - git config --global user.email &quot;%GIT_USER_EMAIL%&quot; - git config --global user.name &quot;%GIT_USER_NAME%&quot; - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\static-site - cd %TEMP%\static-site - del * /f /q - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\public&quot; &quot;%TEMP%\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1)) - git add -A - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;) 以上文件需要替换[Your GitHub Access Token]。3、关于生成Access Token: 到github，点击个人头像找到【settings】 在侧边栏找到【Personal access tokens】 点击【Generate new token】，填写描述，勾选对应选项，点击【Generate token】拿到Access Token4、到AppVeyor加密页面把Access Token加密之后再替换[Your GitHub Access Token]5、设置Appveyor。在源码的【settings】→【Environment】添加变量： STATIC_SITE_REPO就是github上放置发布后代码的地址（并非个站的https地址） TARGET_BRANCH就项目默认分支，一般默认为master GIT_USER_EMAIL和GIT_USER_NAME为GitHub账号的信息。6、将源码托管GitHub，网站自动。 部署中遇到的坑1、添加appveyor.yml文件时，没有缩进，执行错误1Error parsing appveyor.yml: &quot;environment&quot; section must be a mapping. (Line: 2, Column: 13) 2、执行成功后，一篇空白。。。原因next主题没有提交。解决方法：将next作为submodule提交，将themes/next 打包备份后删除，执行git submodule add git@github.com:iissnan/hexo-theme-next themes/nextt将next主题添加为源码的子模块，（不删除会报错该文件夹不为空），讲备份的文件夹中修改的文件替换过来即可。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE浏览器兼容性总结]]></title>
    <url>%2Fpost%2FIE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[常见问题：1、margin加倍的问题：【margin双边距问题】当元素有float属性，又有margin属性时，在IE6下面显示的margin的值是设置值的两倍。这个是IE6比较著名的BUG。解决方法： _display:inline。 2、IE6图片底侧会有像素间隙问题 ：解决方法：a. 将img标记与/div标记放在同一行1&lt;div&gt;&lt;img src=&quot;images/jd.gif&quot; /&gt;&lt;/div&gt; 但是这样写不太方便阅读，我们知道代码的可读性是最为重要的。b. 在CSS样式中给img上设置1img&#123;display:block;&#125; IE6下元素最小高度的问题：IE6浏览器里面有个默认的高度（行高）；19px以下的高度均不可设置；解决方法：overflow:hidden；font-size:0; IE6显示多余字符问题：在IE6下，当在浮动元素之间增加HTML注释时就会产生多余字符bug.解决办法： 可以考虑去掉HTML注释。 不设置浮动div的宽度。(如果可以不用加宽度) 在产生多余字符的那个元素CSS样式加position:relative; IE6下文字混排浮动3px间距BUG：在IE6中，当文本(或无浮动元素)跟在一个浮动的元素之后，文本和这个浮动元素之间会多出3px的间隔。如果元素左浮动或右浮动，则后面的行内文本环绕该元素时浮动与环绕文本之间会增加3px外边距，其他浏览器正常。解决办法：外边距可以是负值，所以给这个浮动的盒子加margin-right：-3像素的距离。 IE6下li里底部3px间距BUG：如果li里面内容过于复杂，那么li和li之间就出现白空隙。解决方法：vertical-align: middle bottom等 IE6中奇数宽高的BUG ：IE6还有奇数宽高的bug，解决方案:就是将外部相对定位的div宽度改成偶数。 了解ie6盒子会撑高的特性 ：内容有多大，盒子就撑多大【设置高度无用】解决方法：父标签使用overflow:hidden 左浮元素margin-bottom失效 ：解决方法：margin-bottom与float不同时作用于一个标签； 块元素中有文字及右浮动的行元素，行元素换行 ：解决方法：将行元素置于块元素内的文字前 position下的left，bottom错位解决方法：为父级(relative层)设置宽高或添加*zoom:1 IE6背景闪烁如果你给链接、按钮用CSS sprites作为背景，你可能会发现在IE6下会有背景图闪烁的现象。造成这个的原因是由于IE6没有将背景图缓存，每次触发hover的时候都会重新加载，可以用JavaScript设置IE6缓存这些图片：1document.execCommand(&quot;BackgroundImageCache&quot;,false,true); IE6 不支持min-height属性，认为height就是最小高度解决方法：使用ie6不支持但其余浏览器支持的属性!important。1#container &#123;min-height:200px; height:auto !important; height:200px;&#125; 针对IE各个版本解决方案——hacker前缀：ie6以下：语法：_selector:{属性：值；} ie7以下：语法：+selector:{属性：值；} ie7专属：语法：*+selector:{属性：值；} CSS后缀hack 针对的浏览器123456789color:red\9; IE6/IE7/IE8/IE9/IE10版本color:red\0; IE8/IE9/IE10版本color:red\9\0; IE9/IE10 /*mediaQuery*/@media screen\9&#123;body &#123; background: red; &#125;&#125; 只对IE6/7生效@media \0screen &#123;body &#123; background: red; &#125;&#125; 只对IE8生效@media \0screen\,screen\9&#123;body &#123; background: blue; &#125;&#125; 只对IE6/7/8有效@media screen\0 &#123;body &#123; background: green; &#125;&#125; 只对IE8/9/10有效@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; 只对IE10有效 条件注释：【缺点是在IE浏览器下可能会增加额外的HTTP请求数。】1.判断等于某个IE浏览器版本的语法：12语法：&lt;!--[if IE 7]&gt;只能被 IE7 识别;&lt;![endif]--&gt;例如： &lt;!--[if ie 5]&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/c.css&quot;&gt;&lt;![endif]--&gt; 2.判断IE浏览器的范围：gte,gt,lte,lt其中： gte:表示高于或等于某个IE浏览的版本 gt:表示高于某个IE浏览器的版本 lte:表示低于或等于某个IE浏览器的版本 lt:表示低于某个IE浏览器的版本12语法：&lt;!--[if gte ie 版本号]&gt;要判断的内容&lt;![endif]--&gt;例如：&lt;!--[if gte ie 5]&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/c.css&quot;&gt;&lt;![endif]--&gt; 3.判断非IE浏览器：12语法： &lt;!--[if ! ie]&gt;&lt;!--&gt;要判断的内容&lt;!--&lt;![endif]--&gt;例如：&lt;!--[if ! ie]&gt;&lt;!--&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/c.css&quot;&gt;&lt;!--&lt;![endif]--&gt; 4.判断是IE浏览器 语法：12&lt;!--[if ie]&gt;要判断的内容&lt;![endif]--&gt;例如： &lt;!--[if ie]&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/c.css&quot;&gt;&lt;![endif]--&gt; 5.其他ie判断 ：1234567&lt;!--[if lt IE 7]&gt; 内容&lt;![endif]--&gt;: 小于 IE7 的版本 ( Less than )；&lt;!--[if lte IE 7]&gt; 内容&lt;![endif]--&gt;: 小于或等于 IE7 的版本 ( Less than or equal )；&lt;!--[if gt IE 7]&gt; 内容&lt;![endif]--&gt;: 大于 IE7 的版本 ( Greater than )；&lt;!--[if gte IE 7]&gt; 内容&lt;![endif]--&gt;: 大于或等于 IE7 的版本 ( Greater than or equal )；&lt;!--[if !IE 7]&gt;内容&lt;![endif]--&gt; : 不等于 IE7 的版本 ( Not )；&lt;!--[if !IE]&gt;&lt;!--&gt;您使用不是 Internet Explorer&lt;!--&lt;![endif]--&gt; 不是IE浏览器gt:大于不包括；lt:小于不包括；gte：大于包括；lte:小于包括；！除此之外； 注意：顺序千万不要乱，因为当出现重复定义时，浏览器默认按最后一下渲染，所以一定要先正常，再*，最后_。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Hack</tag>
        <tag>CSS</tag>
        <tag>IE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[meta标签总结]]></title>
    <url>%2Fpost%2Fmeta%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTTP 标题信息(http-equiv)HTTP 标题信息(http-equiv)，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容,该枚举的属性定义，可以改变服务器和用户代理行为的编译。合理使用可增加 SEO 收录。编译的值取content 里的内容。简单来说即可以模拟 HTTP 协议响应头。eg: 1、设置编码类型:12&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;meta charset=&quot;uft-8&quot;/&gt; //在h5中 2、设置网页语言【Content-Language】3、指定时间刷新页面【Refresh】12345设置网页3s刷新一次：&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3&quot; /&gt;3秒钟后跳转页面；见文档3s种后跳转；&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3”; url=”http//www.uhoem.com” /&gt; 4、设定页面 cookie 过期时间【set-cookie】1&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT； path=/&quot;&gt; 5、页面最后生成时间【last-modified】6、可以用于设定网页的到期时间。一旦网页过期，必须到服务器重新传输。必须使用GMT的时间格式。【expires】1&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 12 Jan 2001 18:18:18 GMT&quot;&gt; 7、设置文档的缓存机制【cache-control】8、禁止浏览器从本地计算机的缓存中访问页面内容。【Pragma】1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; 页面描述信息(name)用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的 eg: 1、Keywords(关键字) 12//keywords用来告诉搜索引擎你网页的关键字是什么。 &lt;meta name =&quot;keywords&quot; content=&quot;science, education,culture,politics,ecnomics，relationships, entertaiment, human&quot;&gt; 2、description(网站内容描述) 12//description用来告诉搜索引擎你的网站主要内容。&lt;meta name=&quot;description&quot; content=&quot;This page is about the meaning of science, education,culture.&quot;&gt; 3、robots(机器人向导) 12//robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。 content的参数有all,none,index,noindex,follow,nofollow。默认是all。 &lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; 4、author(作者) 12//标注网页的作者&lt;meta name=&quot;author&quot; content=&quot;root,root@21cn.com&quot;&gt; 常用meta标签：12345678910111213141516171819202122232425262728&lt;!-- 视图窗口，移动端特属的标签。 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no&quot; /&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;!-- 是否启动webapp功能，会删除默认的苹果工具栏和菜单栏。仅在ios有效 --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;!-- 这个主要是根据实际的页面设计的主体色为搭配来进行设置。 --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;!-- 忽略页面中的数字识别为电话号码,email识别 --&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>meta</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo_NexT主题添加访问量统计]]></title>
    <url>%2Fpost%2FHexo-nexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[本文主要为如何为用Hexo的NexT主题的网站添加访问量和文章阅读量的总结。注意其他主题不适用。 突发奇想为个站添加访问量的功能，在网上查阅了很多资料后，发现大多数用的LeanCloud+不蒜子。故本站也已此来实现。 LeanCloud和不蒜子介绍LeanCloud:主要为移动应用提供云服务，包括存储、账号管理、社交分享、推送、应用统计等以及相关的技术支持和服务。此处，我们只用到的应用统计功能。 不蒜子:官方介绍：只需两行代码，搞定计数。 添加文章阅读量配置LeanCloud上配置： 打开官网，注册登录，点击右上【访问控制台】 创建新应用（名称随意，其他选择默认即可） 进入应用，点击【存储】下的【创建class】， 创建名为Counter 在【设置】下【应用key】拿到app_id和app_key 在【设置】-&gt;【安全中心】的【Web安全域名】中加入自己的博客域名（安全性考虑） 以后可以在【存储】下的【Counter】看到网站访问情况： 在NexT下：NexT 1、在NexT主题的 _config.yml 文件，在相应位置添加： 12345# add post viewsleancloud_visitors: enable: true app_id: **你的app_id** app_key: **你的app_key** //上步已拿到 2、在next\layout\ _scripts路径下，新建lean-analytics.swig文件，并添加以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!-- custom analytics part create by xiamo --&gt;&lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt;AV.initialize(&quot;&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;&quot;, &quot;&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;&quot;);&lt;/script&gt;&lt;script&gt;function showTime(Counter) &#123; var query = new AV.Query(Counter); $(&quot;.leancloud_visitors&quot;).each(function() &#123; var url = $(this).attr(&quot;id&quot;).trim(); query.equalTo(&quot;url&quot;, url); query.find(&#123; success: function(results) &#123; if (results.length == 0) &#123; var content = &apos;0 &apos; + $(document.getElementById(url)).text(); $(document.getElementById(url)).text(content); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var object = results[i]; var content = object.get(&apos;time&apos;) + &apos; &apos; + $(document.getElementById(url)).text(); $(document.getElementById(url)).text(content); &#125; &#125;, error: function(object, error) &#123; console.log(&quot;Error: &quot; + error.code + &quot; &quot; + error.message); &#125; &#125;); &#125;);&#125;function addCount(Counter) &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); url = $(&quot;.leancloud_visitors&quot;).attr(&apos;id&apos;).trim(); title = $(&quot;.leancloud_visitors&quot;).attr(&apos;data-flag-title&apos;).trim(); var query = new AV.Query(Counter); query.equalTo(&quot;url&quot;, url); query.find(&#123; success: function(results) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; counter.fetchWhenSave(true); counter.increment(&quot;time&quot;); counter.save(null, &#123; success: function(counter) &#123; var content = counter.get(&apos;time&apos;) + &apos; &apos; + $(document.getElementById(url)).text(); $(document.getElementById(url)).text(content); &#125;, error: function(counter, error) &#123; console.log(&apos;Failed to save Visitor num, with error message: &apos; + error.message); &#125; &#125;); &#125; else &#123; var newcounter = new Counter(); newcounter.set(&quot;title&quot;, title); newcounter.set(&quot;url&quot;, url); newcounter.set(&quot;time&quot;, 1); newcounter.save(null, &#123; success: function(newcounter) &#123; console.log(&quot;newcounter.get(&apos;time&apos;)=&quot;+newcounter.get(&apos;time&apos;)); var content = newcounter.get(&apos;time&apos;) + &apos; &apos; + $(document.getElementById(url)).text(); $(document.getElementById(url)).text(content); &#125;, error: function(newcounter, error) &#123; console.log(&apos;Failed to create&apos;); &#125; &#125;); &#125; &#125;, error: function(error) &#123; console.log(&apos;Error:&apos; + error.code + &quot; &quot; + error.message); &#125; &#125;);&#125;$(function() &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); if ($(&apos;.leancloud_visitors&apos;).length == 1) &#123; addCount(Counter); &#125; else if ($(&apos;.post-title-link&apos;).length &gt; 1) &#123; showTime(Counter); &#125;&#125;);&lt;/script&gt; 3、在next/layout/_macro路径下，编辑post.swig文件，找到相应的插入位置:（我该文件下默认有，就省略） 123456&#123;% if theme.leancloud_visitors.enable %&#125;&amp;nbsp; | &amp;nbsp;&lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt; &amp;nbsp;&#123;&#123;__(&apos;post.visitors&apos;)&#125;&#125; &lt;/span&gt;&#123;% endif %&#125; 4、next\layout目录下，编辑_layout.swig文件，在的上方，插入如下代码: 123&#123;% if theme.leancloud_visitors.enable %&#125;&#123;% include &apos;_scripts/lean-analytics.swig&apos; %&#125;&#123;% endif %&#125; 5、在next/languages/网站使用的配置文件的post里添加语言字段posted、sticky、visitors.以英文为例（其他语言，自行翻译） 12345post: sticky: Sticky posted: Posted on visitors: Views // 增加的字段 ... 添加网站访问量：两个概念： pv：网站的浏览次数。如：单个用户连续点击n篇文章，记录n次访问量 uv：网站的访客数。如：单个用户连续点击n篇文章，只记录1次访客数。你可以根据需要添加相应的统计功能。 安装不蒜子 打开并编辑next/layout/_partial/footer.swig文件，拷贝下面的代码至文件的开头 12&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 编辑该文件，在div.theme-info元素后添加一下代码： （任选一个） 123456789//显示pv统计量：【多】&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; Total visited &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; times&lt;/span&gt;//或显示pv统计量：【少】&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; Total visited &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; times&lt;/span&gt; 自定义样式：（推荐方法） 在next/source/css/目录下新建文件夹并新建.styl文件，并以stylus语法编辑样式 在同级打开main.styl文件，并将新建文件引入 123//My Layer //-------------------------------------------------- @import &quot;_my/mycss&quot;; stylus语法，之后总结]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>Stylus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo搭建博客]]></title>
    <url>%2Fpost%2F%E5%88%A9%E7%94%A8gitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面这是一篇使用GitHub Pages和Hexo搭建个人博客姿势总结。 Hexo是个快速搭建博客的框架，它也有丰富的UI主题，几乎不用自己写任何界面。很是方便而GitHub众所周知的免费代码托管仓库（同性交友平台），大神经常出没… 整个主要分为两大步： GitHub及Hexo的安装和配置 利用Hexo发布内容 关于对个人博客的期许和历程戳这里 对这俩词儿听说过么？观光团子们坐稳了~ Git GitHub GitHub Pages Hexo GitHub及Hexo的安装和配置在安装前需要下载node和git node.js git 配置GitHub 注册并登陆GitHub官网新建项目 【New repository】 在项目的【setting】里找到【GitHub Pages】下的【Source】选择master branch → save 在浏览器中打开网址1https://GitHub用户名.github.io,至此GitHub配置网址完成 配置SSH（为了本地用git操作github上的文件）1、生成SSH 检查是否已经有SSH Key，打开Git Bash，输入 1cd ~/.ssh 如果没有这个目录，则生成一个新的SSH，输入 1ssh-keygen -t rsa -C &quot;your e-mail&quot; 2、复制公钥内容到Github账户信息中打开~/.ssh/id_rsa.pub文件，(在c盘user目录下)复制里面的内容；打开Github官网，登陆后进入到个人设置(点击头像-&gt;setting)，点击右侧的SSH Keys，点击Add SSH key；填写title之后，将之前复制的内容粘贴到Key框中，最后点击Add key即可。 3、测试SSH是否配置成功在本地项目目录下输入1ssh -T git@github.com 若输出下面语句则配置成功12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 4、 解决push到github时，每次都要输入用户名和密码的问题在添加远程库的时候使用了https的方式。。所以每次都要用https的方式push到远程库，速度还慢。依次执行以下命令： git remote -v git remote rm origin git remote add origin git@github.com:username/repository.git（地址需要自己改变） git push -u origin master 安装Hexo及本地建站 选择本地文件夹放置项目，用npm install -g hexo-cli 命令安装Hexo 初始化 hexo init 安装npm包 npm install 解决执行hexo d 报错 npm install hexo-deployer-git –save 测试是否成功 hexo s 显示hexo默认效果 hexo官方文档 将网站内容发布至GitHub上打开项目根目录下的_config.yml文件，找到如下位置，填写12345# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy:type: gitrepo: git@github.com:Github账户名/Github账户名.github.io yml文件中，:后面都是要带空格的 打开下面链接，可以看到刚才本地服务默认的hexo界面1http://Github账户名.github.io 利用Hexo发布内容选择HexoUI主题（以本站为例_next主题）1、下载对应主题：1git clone https://github.com/iissnan/hexo-theme-next themes/next 2、打开项目根目录下的_config.yml文件，找到theme字段，将其修改为对应的主题名称1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: next 3、本地测试效果1hexo s -debug 4、上传至GitHub1hexo g -d 注意：在部署过程中，在报了 更多Hexo主题 发布内容1、在网站存放的根目录打开git bash，输入：1hexo n &quot;文章标题&quot; 2、打开source/_post/文章标题.md，在- - -下方添加正文内容编辑；使用markdown语法。语法查阅递送门3、给文章贴标签加分类:tages:[tag1, tag2, tag3, …]categories:XXX4、保存执行一下命令即刻更新1hexo g -d 草稿【相当于私密内容】1、新建草稿hexo new draft &quot;new draft&quot;2、把草稿变成文章hexo publish [layout] &lt;filename&gt; Hexo主题配置绑定个性域名地址太穷啦~~~~不做啦，略！]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客终于上线啦~~~]]></title>
    <url>%2Fpost%2F%E7%BB%88%E4%BA%8E%E4%B8%8A%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[前言一直以来都希望有个属于自己的个人网站。没入行前是因为听别人说起来很高大上的样子，现在是因为想有个自己的平台写一些东西。无论是生活体会，还是技术总结和学习笔记，都是自己所做所想。这是自己安静下来时大脑和心灵的对话。 有关技术软件行业技术百花齐放，日新月异。各种框架也层出不穷，我试图让自己跟上行业的脚步，学习最新的技术栈，但往往让自己学的杂而不精。往往是前半个月看了Angular，后半个月看到各种论坛上大神们对React津津乐道时，而转投React怀抱… 我想个站里的技术总结和学习模块会让自己浮躁而急措的步伐踏的慢一些稳一些。同时规范技术文档书写的能力也会相应提高 有关生活有时候生活的一些想法和感触往往是一闪而过的，美好的事情应该被留下来点缀生命长河。不圆满的东西用来吐槽这个世界。生命不息，折腾不止~ 有关了解一句曰之：让别人知道我在干什么，这是鲜活真实而相对全面的我。 你好，我是石璐。]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
</search>
